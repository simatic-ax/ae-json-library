; ModuleID = 'json-showcase'
source_filename = "json-showcase"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc"

%"$CD_UsingDeserializer" = type { i8*, i64, i16, [0 x { i64, i64, i8* }]*, [4 x i8*] }
%UsingDeserializer = type { i8*, %Simatic.Ax.Json.Deserializer, [1000 x i8], %STRING.0, %STRING.0, i32, i1 }
%Simatic.Ax.Json.Deserializer = type { i8*, [1000 x i8]* }
%STRING.0 = type { i8, i8, [255 x i8] }
%"$CD_Simatic.Ax.Json.Deserializer" = type { i8*, i64, i16, [0 x { i64, i64, i8* }]*, [19 x i8*] }
%"$CD_UsingSerializer" = type { i8*, i64, i16, [0 x { i64, i64, i8* }]*, [0 x i8*] }
%UsingSerializer = type { i8*, %Simatic.Ax.Json.JsonDocument, [21 x i8], %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonString }
%Simatic.Ax.Json.JsonDocument = type { i8*, [1000 x i8], %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*, i32, i32, i32 }
%Simatic.Ax.Json.IJsonElementMuteable = type { i8*, [3 x i8*] }
%Simatic.Ax.Json.IJsonElement = type { i8*, [2 x i8*] }
%Simatic.Ax.Json.JsonBoolean = type { %Simatic.Ax.Json.BaseJsonNumber, i1 }
%Simatic.Ax.Json.BaseJsonNumber = type { %Simatic.Ax.Json.AbstractJsonElement }
%Simatic.Ax.Json.AbstractJsonElement = type { i8*, %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*, %STRING.0, %Simatic.Ax.Json.IJsonElementMuteable* }
%Simatic.Ax.Json.JsonString = type { %Simatic.Ax.Json.AbstractJsonElement, %STRING.0 }
%"$CD_Simatic.Ax.Json.JsonDocument" = type { i8*, i64, i16, [0 x { i64, i64, i8* }]*, [7 x i8*] }
%"$CD_Simatic.Ax.Json.AbstractJsonElement" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%"$CD_Simatic.Ax.Json.BaseJsonNumber" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%"$CD_Simatic.Ax.Json.JsonBoolean" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%"$CD_Simatic.Ax.Json.JsonString" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%"$CD_Simatic.Ax.Json.JsonDInt" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonDInt = type { %Simatic.Ax.Json.BaseJsonNumber, i32 }
%"$CD_Simatic.Ax.Json.JsonInt" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonInt = type { %Simatic.Ax.Json.BaseJsonNumber, i16 }
%"$CD_Simatic.Ax.Json.JsonLInt" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonLInt = type { %Simatic.Ax.Json.BaseJsonNumber, i64 }
%"$CD_Simatic.Ax.Json.JsonUSInt" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonUSInt = type { %Simatic.Ax.Json.BaseJsonNumber, i8 }
%"$CD_Simatic.Ax.Json.JsonSInt" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonSInt = type { %Simatic.Ax.Json.BaseJsonNumber, i8 }
%"$CD_Simatic.Ax.Json.DeserializedObject" = type { i8*, i64, i16, [0 x { i64, i64, i8* }]*, [0 x i8*] }
%Simatic.Ax.Json.DeserializedObject = type { i8*, i16, i16, i16, i16 }
%"$CD_Simatic.Ax.Json.JsonObject" = type { i8*, i64, i16, [2 x { i64, i64, i8* }]*, [7 x i8*] }
%Simatic.Ax.Json.JsonObject = type { %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable* }
%AxUnit.Mocking.IPayload = type { i8*, [0 x i8*] }
%"$Task" = type { i32 }
%"STRING[0]" = type { i8, i8, [1 x i8] }
%"STRING[66]" = type { i8, i8, [67 x i8] }
%"STRING[4]" = type { i8, i8, [5 x i8] }
%"STRING[11]" = type { i8, i8, [12 x i8] }
%"STRING[9]" = type { i8, i8, [10 x i8] }
%"STRING[2]" = type { i8, i8, [3 x i8] }
%"STRING[27]" = type { i8, i8, [28 x i8] }
%"STRING[8]" = type { i8, i8, [9 x i8] }
%"STRING[12]" = type { i8, i8, [13 x i8] }
%"STRING[60]" = type { i8, i8, [61 x i8] }
%"STRING[49]" = type { i8, i8, [50 x i8] }
%"STRING[10]" = type { i8, i8, [11 x i8] }
%"STRING[85]" = type { i8, i8, [86 x i8] }
%"STRING[17]" = type { i8, i8, [18 x i8] }
%"STRING[3]" = type { i8, i8, [4 x i8] }
%"STRING[5]" = type { i8, i8, [6 x i8] }
%"$ax.ArrayBounds" = type { i32, i32, i32 }
%"$ax.ArrayWithBound" = type { i8*, i32, %"$ax.ArrayBounds"* }
%"STRING[6]" = type { i8, i8, [7 x i8] }
%"STRING[20]" = type { i8, i8, [21 x i8] }
%"STRING[1]" = type { i8, i8, [2 x i8] }
%"STRING[21]" = type { i8, i8, [22 x i8] }
%struct._iobuf = type { i8* }
%struct.__crt_locale_pointers = type { %struct.__crt_locale_data*, %struct.__crt_multibyte_data* }
%struct.__crt_locale_data = type opaque
%struct.__crt_multibyte_data = type opaque
%struct._ClassDescriptorStub = type { %struct._ClassDescriptorStub*, i64, i16, %struct._InterfaceTableEntry* }
%struct._InterfaceTableEntry = type { i64, i64, %struct._InterfaceDescriptorStub* }
%struct._InterfaceDescriptorStub = type { %struct._ClassDescriptorStub* }
%WSTRING.6 = type { i16, i16, [255 x i16] }

$printf = comdat any

$__local_stdio_printf_options = comdat any

$"??$$ax.Assign_String@DU$ax.ST_STRING@@@@YAXPEADPEBD@Z" = comdat any

$snprintf = comdat any

$"??$$ax.Assign_String@FU$ax.ST_WSTRING@@@@YAXPEAFPEBF@Z" = comdat any

$"??$ax_Concat_String@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBD0@Z" = comdat any

$"??$are_strings_ok_dss@Uax_ST_STRING@@@@YA_NPEAUax_ST_STRING@@PEBU0@1@Z" = comdat any

$"??$safe_add@Uax_ST_STRING@@@@YAEEE@Z" = comdat any

$"??$cap@Uax_ST_STRING@@@@YAEE@Z" = comdat any

$"??$min@E@std@@YAAEBEAEBE0@Z" = comdat any

$"??$get_string_sign@Uax_ST_STRING@@@@YAHPEBUax_ST_STRING@@_N@Z" = comdat any

$"??$are_strings_overlapping@Uax_ST_STRING@@@@YA_NPEBUax_ST_STRING@@0@Z" = comdat any

$"??$ax_Concat_String@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBF0@Z" = comdat any

$"??$are_strings_ok_dss@Uax_ST_WSTRING@@@@YA_NPEAUax_ST_WSTRING@@PEBU0@1@Z" = comdat any

$"??$safe_add@Uax_ST_WSTRING@@@@YAGGG@Z" = comdat any

$"??$cap@Uax_ST_WSTRING@@@@YAGG@Z" = comdat any

$"??$min@G@std@@YAAEBGAEBG0@Z" = comdat any

$"??$get_string_sign@Uax_ST_WSTRING@@@@YAHPEBUax_ST_WSTRING@@_N@Z" = comdat any

$"??$are_strings_overlapping@Uax_ST_WSTRING@@@@YA_NPEBUax_ST_WSTRING@@0@Z" = comdat any

$"??$ax_Substring@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z" = comdat any

$"??$ax_StrLen@Uax_ST_STRING@@@@YAHPEBD@Z" = comdat any

$"??$ax_Substring@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z" = comdat any

$"??$ax_StrLen@Uax_ST_WSTRING@@@@YAHPEBF@Z" = comdat any

$"??$ax_Insert@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDH0@Z" = comdat any

$"??$ax_Remove@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z" = comdat any

$"??$ax_Insert@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFH0@Z" = comdat any

$"??$ax_Remove@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z" = comdat any

$"??$ax_PositionOf@Uax_ST_STRING@@@@YAHPEBD0@Z" = comdat any

$"??$ax_PositionOf@Uax_ST_WSTRING@@@@YAHPEBF0@Z" = comdat any

$"??_C@_03OFAPEBGM@?$CFs?6?$AA@" = comdat any

$"?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA" = comdat any

$"??_C@_0FE@HKMFAKJH@The?5dimension?5for?5lower_bound?5is@" = comdat any

$"??_C@_0FE@MELOPMAH@The?5dimension?5for?5upper_bound?5is@" = comdat any

$"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@" = comdat any

$"??_C@_03IGPHLJKL@NIL?$AA@" = comdat any

$"??_C@_0P@EALMCFKA@STRING_CORRUPT?$AA@" = comdat any

@Input = global [65536 x i8] zeroinitializer
@Output = global [65536 x i8] zeroinitializer
@Memory = global [65536 x i8] zeroinitializer
@axunit_assertionData = global [300 x i8] zeroinitializer, !dbg !0
@axunit_globalTestIdPos = global i16 0, !dbg !28
@axunit_globalSectionPosName = global i16 0, !dbg !24
@axunit_assertionData_Size = global i16 0
@axunit_dispatcher_current_impl_var = global [1 x i16] zeroinitializer
@GlobalAssertValue = global i1 false
@"$itf_table_UsingDeserializer" = linkonce_odr hidden global [0 x { i64, i64, i8* }] zeroinitializer
@"$cd_UsingDeserializer" = linkonce_odr hidden global %"$CD_UsingDeserializer" { i8* null, i64 ptrtoint (%UsingDeserializer* getelementptr (%UsingDeserializer, %UsingDeserializer* null, i32 1) to i64), i16 0, [0 x { i64, i64, i8* }]* @"$itf_table_UsingDeserializer", [4 x i8*] [i8* bitcast (void (%UsingDeserializer*)* @"UsingDeserializer.GetValue_ARRAY$I@R@UsingDeserializer@this" to i8*), i8* bitcast (void (%UsingDeserializer*)* @"UsingDeserializer.GetValue_BASIC_DATA_TYPES$I@R@UsingDeserializer@this" to i8*), i8* bitcast (void (%UsingDeserializer*)* @"UsingDeserializer.GetValue_Nested$I@R@UsingDeserializer@this" to i8*), i8* bitcast (void (%UsingDeserializer*)* @"UsingDeserializer.GetValue_Nested_in_Nested$I@R@UsingDeserializer@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.Deserializer" = linkonce_odr hidden global [0 x { i64, i64, i8* }] zeroinitializer
@"$cd_Simatic.Ax.Json.Deserializer" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.Deserializer" { i8* null, i64 mul nuw (i64 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i64), i64 2), i16 0, [0 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.Deserializer", [19 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.Deserializer*, [1000 x i8]*)* @"Simatic.Ax.Json.Deserializer.SetBuffer$I@R@Simatic.Ax.Json.Deserializer@this?I@V@REF_TO ARRAY [0..999] OF CHAR@_buffer" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i32*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int32@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int16@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i64*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int64@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int8@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@STRING@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i32*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt32@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt16@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i64*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt64@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt8@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i32*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int32@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i16*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i64*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int64@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int8@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@STRING@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i32*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt32@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i16*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt16@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i64*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt64@value" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i8*)* @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt8@value" to i8*)] }
@"$itf_table_UsingSerializer" = linkonce_odr hidden global [0 x { i64, i64, i8* }] zeroinitializer
@"$cd_UsingSerializer" = linkonce_odr hidden global %"$CD_UsingSerializer" { i8* null, i64 ptrtoint (%UsingSerializer* getelementptr (%UsingSerializer, %UsingSerializer* null, i32 1) to i64), i16 0, [0 x { i64, i64, i8* }]* @"$itf_table_UsingSerializer", [0 x i8*] zeroinitializer }
@"$itf_table_Simatic.Ax.Json.JsonDocument" = linkonce_odr hidden global [0 x { i64, i64, i8* }] zeroinitializer
@"$cd_Simatic.Ax.Json.JsonDocument" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonDocument" { i8* null, i64 ptrtoint (%Simatic.Ax.Json.JsonDocument* getelementptr (%Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* null, i32 1) to i64), i16 0, [0 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonDocument", [7 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.JsonDocument*, i8)* @"Simatic.Ax.Json.JsonDocument.AddChar$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@Char@c" to i8*), i8* bitcast (void (%Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.JsonDocument.AddElement$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.JsonDocument.AddString$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@STRING@s" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonDocument.GetLength$I@R@Simatic.Ax.Json.JsonDocument@this" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElement* (%Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonDocument.GetRootElement$I@R@Simatic.Ax.Json.JsonDocument@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.JsonDocument*, %"$ax.ArrayWithBound"*)* @"Simatic.Ax.Json.JsonDocument.Serialize$I@R@Simatic.Ax.Json.JsonDocument@this?I@R@ARRAY [*] OF CHAR@buf" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonDocument.ToString$I@R@Simatic.Ax.Json.JsonDocument@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.AbstractJsonElement" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.AbstractJsonElement"* @"$cd_Simatic.Ax.Json.AbstractJsonElement" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.AbstractJsonElement" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.AbstractJsonElement"* @"$cd_Simatic.Ax.Json.AbstractJsonElement" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.AbstractJsonElement" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.AbstractJsonElement" to i8*) }, { i64, i64, i8* } { i64 mul nuw (i64 ptrtoint (i1** getelementptr (i1*, i1** null, i32 1) to i64), i64 2), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.AbstractJsonElement" to i8*) }]
@"$cd_Simatic.Ax.Json.AbstractJsonElement" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.AbstractJsonElement" { i8* null, i64 ptrtoint (%Simatic.Ax.Json.AbstractJsonElement* getelementptr (%Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.AbstractJsonElement", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.AbstractJsonElement.Serialize$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.ToString$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.AbstractJsonElement*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.ToStringHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.BaseJsonNumber" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.BaseJsonNumber" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.BaseJsonNumber" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.BaseJsonNumber" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.BaseJsonNumber" to i8*) }]
@"$cd_Simatic.Ax.Json.BaseJsonNumber" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.BaseJsonNumber" { i8* bitcast (%"$CD_Simatic.Ax.Json.AbstractJsonElement"* @"$cd_Simatic.Ax.Json.AbstractJsonElement" to i8*), i64 ptrtoint (%Simatic.Ax.Json.AbstractJsonElement* getelementptr (%Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.BaseJsonNumber", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*)* @"Simatic.Ax.Json.BaseJsonNumber.ToString$I@R@Simatic.Ax.Json.BaseJsonNumber@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonBoolean" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonBoolean"* @"$cd_Simatic.Ax.Json.JsonBoolean" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonBoolean" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonBoolean"* @"$cd_Simatic.Ax.Json.JsonBoolean" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonBoolean" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonBoolean" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonBoolean" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonBoolean" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonBoolean" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonBoolean* getelementptr (%Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonBoolean", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonBoolean.Serialize$I@R@Simatic.Ax.Json.JsonBoolean@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonBoolean*)* @"Simatic.Ax.Json.JsonBoolean.ToString$I@R@Simatic.Ax.Json.JsonBoolean@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonString" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonString"* @"$cd_Simatic.Ax.Json.JsonString" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonString" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonString"* @"$cd_Simatic.Ax.Json.JsonString" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonString" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonString" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonString" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonString" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonString" { i8* bitcast (%"$CD_Simatic.Ax.Json.AbstractJsonElement"* @"$cd_Simatic.Ax.Json.AbstractJsonElement" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonString* getelementptr (%Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonString", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonString.Serialize$I@R@Simatic.Ax.Json.JsonString@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonString*)* @"Simatic.Ax.Json.JsonString.ToString$I@R@Simatic.Ax.Json.JsonString@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.AbstractJsonElement*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.ToStringHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonDInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonDInt"* @"$cd_Simatic.Ax.Json.JsonDInt" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonDInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonDInt"* @"$cd_Simatic.Ax.Json.JsonDInt" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonDInt" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonDInt" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonDInt" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonDInt" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonDInt" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonDInt* getelementptr (%Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonDInt", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonDInt*)* @"Simatic.Ax.Json.JsonDInt.ToString$I@R@Simatic.Ax.Json.JsonDInt@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonInt"* @"$cd_Simatic.Ax.Json.JsonInt" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonInt"* @"$cd_Simatic.Ax.Json.JsonInt" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonInt" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonInt" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonInt" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonInt" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonInt" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonInt* getelementptr (%Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonInt", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonInt*)* @"Simatic.Ax.Json.JsonInt.ToString$I@R@Simatic.Ax.Json.JsonInt@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonLInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonLInt"* @"$cd_Simatic.Ax.Json.JsonLInt" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonLInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonLInt"* @"$cd_Simatic.Ax.Json.JsonLInt" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonLInt" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonLInt" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonLInt" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonLInt" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonLInt" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonLInt* getelementptr (%Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonLInt", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonLInt*)* @"Simatic.Ax.Json.JsonLInt.ToString$I@R@Simatic.Ax.Json.JsonLInt@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonUSInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonUSInt"* @"$cd_Simatic.Ax.Json.JsonUSInt" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonUSInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonUSInt"* @"$cd_Simatic.Ax.Json.JsonUSInt" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonUSInt" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonUSInt" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonUSInt" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonUSInt" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonUSInt" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonUSInt* getelementptr (%Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonUSInt", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonUSInt*)* @"Simatic.Ax.Json.JsonUSInt.ToString$I@R@Simatic.Ax.Json.JsonUSInt@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonSInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonSInt"* @"$cd_Simatic.Ax.Json.JsonSInt" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonSInt" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonSInt"* @"$cd_Simatic.Ax.Json.JsonSInt" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonSInt" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonSInt" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.BaseJsonNumber }, { %Simatic.Ax.Json.BaseJsonNumber }* null, i32 0, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonSInt" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonSInt" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonSInt" { i8* bitcast (%"$CD_Simatic.Ax.Json.BaseJsonNumber"* @"$cd_Simatic.Ax.Json.BaseJsonNumber" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonSInt* getelementptr (%Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonSInt", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonSInt*)* @"Simatic.Ax.Json.JsonSInt.ToString$I@R@Simatic.Ax.Json.JsonSInt@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)* @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString" to i8*)] }
@"$itf_table_Simatic.Ax.Json.DeserializedObject" = linkonce_odr hidden global [0 x { i64, i64, i8* }] zeroinitializer
@"$cd_Simatic.Ax.Json.DeserializedObject" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.DeserializedObject" { i8* null, i64 ptrtoint (%Simatic.Ax.Json.DeserializedObject* getelementptr (%Simatic.Ax.Json.DeserializedObject, %Simatic.Ax.Json.DeserializedObject* null, i32 1) to i64), i16 0, [0 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.DeserializedObject", [0 x i8*] zeroinitializer }
@"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonObject" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElementMuteable { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonObject"* @"$cd_Simatic.Ax.Json.JsonObject" to i8*), [3 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElementMuteable*)* @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this" to i8*)] }
@"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonObject" = linkonce_odr hidden global %Simatic.Ax.Json.IJsonElement { i8* bitcast (%"$CD_Simatic.Ax.Json.JsonObject"* @"$cd_Simatic.Ax.Json.JsonObject" to i8*), [2 x i8*] [i8* bitcast (i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)* @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.IJsonElement*)* @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this" to i8*)] }
@"$itf_table_Simatic.Ax.Json.JsonObject" = linkonce_odr hidden global [2 x { i64, i64, i8* }] [{ i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElementMuteable** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 1) to i64), i64 -1600813877, i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable_Simatic.Ax.Json.JsonObject" to i8*) }, { i64, i64, i8* } { i64 ptrtoint (%Simatic.Ax.Json.IJsonElement** getelementptr ({ %Simatic.Ax.Json.AbstractJsonElement }, { %Simatic.Ax.Json.AbstractJsonElement }* null, i32 0, i32 0, i32 2) to i64), i64 -274380306, i8* bitcast (%Simatic.Ax.Json.IJsonElement* @"$Simatic.Ax.Json.IJsonElement_Simatic.Ax.Json.JsonObject" to i8*) }]
@"$cd_Simatic.Ax.Json.JsonObject" = linkonce_odr hidden global %"$CD_Simatic.Ax.Json.JsonObject" { i8* bitcast (%"$CD_Simatic.Ax.Json.AbstractJsonElement"* @"$cd_Simatic.Ax.Json.AbstractJsonElement" to i8*), i64 ptrtoint (%Simatic.Ax.Json.JsonObject* getelementptr (%Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* null, i32 1) to i64), i16 2, [2 x { i64, i64, i8* }]* @"$itf_table_Simatic.Ax.Json.JsonObject", [7 x i8*] [i8* bitcast (void (%Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.IJsonElement*)* @"Simatic.Ax.Json.JsonObject.AddElement$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem" to i8*), i8* bitcast (%Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.AbstractJsonElement*)* @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this" to i8*), i8* bitcast (i1 (%Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonDocument*)* @"Simatic.Ax.Json.JsonObject.Serialize$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc" to i8*), i8* bitcast (i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.JsonObject*)* @"Simatic.Ax.Json.JsonObject.ToString$I@R@Simatic.Ax.Json.JsonObject@this" to i8*), i8* bitcast (%STRING.0 (%Simatic.Ax.Json.AbstractJsonElement*, i8*)* @"Simatic.Ax.Json.AbstractJsonElement.ToStringHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@STRING@valueAsString" to i8*)] }
@axunit_payload_default_value = global %AxUnit.Mocking.IPayload* null
@axunit_dispatcher_current_payload_var = global [1 x %AxUnit.Mocking.IPayload*] zeroinitializer
@Main = global %"$Task" zeroinitializer
@axunit_TestsExecuted = global i16 0, !dbg !30
@axunit_Test_0_Result = global i8 3, !dbg !34
@axunit_Test_1_Result = global i8 3, !dbg !38
@axunit_Test_2_Result = global i8 3, !dbg !40
@axunit_Test_3_Result = global i8 3, !dbg !42
@axunit_testfixture_instance_UsingDeserializer = global %UsingDeserializer { i8* bitcast (%"$CD_UsingDeserializer"* @"$cd_UsingDeserializer" to i8*), %Simatic.Ax.Json.Deserializer { i8* bitcast (%"$CD_Simatic.Ax.Json.Deserializer"* @"$cd_Simatic.Ax.Json.Deserializer" to i8*), [1000 x i8]* null }, [1000 x i8] zeroinitializer, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, i32 0, i1 false }, !dbg !44
@axunit_testfixture_instance_default_valuesUsingDeserializer = global %UsingDeserializer { i8* bitcast (%"$CD_UsingDeserializer"* @"$cd_UsingDeserializer" to i8*), %Simatic.Ax.Json.Deserializer { i8* bitcast (%"$CD_Simatic.Ax.Json.Deserializer"* @"$cd_Simatic.Ax.Json.Deserializer" to i8*), [1000 x i8]* null }, [1000 x i8] zeroinitializer, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, i32 0, i1 false }, !dbg !79
@"$cStr" = internal global %"STRING[0]" zeroinitializer
@"$cStr.1" = internal global %"STRING[0]" zeroinitializer
@"$cStr.2" = internal global %"STRING[0]" zeroinitializer
@"$cStr.3" = internal global %"STRING[0]" zeroinitializer
@"$cStr.4" = internal global %"STRING[66]" { i8 66, i8 66, [67 x i8] c"{ \22key1\22: \22stringValue\22, \22key2\22: 10, \22key3\22: 1234, \22key4\22: \221234\22}\00" }
@"$cStr.5" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key1\00" }
@"$cStr.6" = internal global %"STRING[11]" { i8 11, i8 11, [12 x i8] c"stringValue\00" }
@"$cStr.7" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key2\00" }
@"$cStr.8" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key3\00" }
@"$cStr.9" = internal global %"STRING[9]" { i8 9, i8 9, [10 x i8] c"Not a key\00" }
@"$cStr.10" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key2\00" }
@"$cStr.11" = internal global %"STRING[2]" { i8 2, i8 2, [3 x i8] c"10\00" }
@"$cStr.12" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key4\00" }
@"$cStr.13" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key1\00" }
@"$cStr.14" = internal global %"STRING[27]" { i8 27, i8 27, [28 x i8] c"{ \22arraykey\22: [1234, 5678]}\00" }
@"$cStr.15" = internal global %"STRING[8]" { i8 8, i8 8, [9 x i8] c"arraykey\00" }
@"$cStr.16" = internal global %"STRING[12]" { i8 12, i8 12, [13 x i8] c"[1234, 5678]\00" }
@"$cStr.17" = internal global %"STRING[60]" { i8 60, i8 60, [61 x i8] c"{ \22key1\22: {\22nestedkey1\22: \22nested value\22, \22nestedkey2\22: 456}}\00" }
@"$cStr.18" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key1\00" }
@"$cStr.19" = internal global %"STRING[49]" { i8 49, i8 49, [50 x i8] c"{\22nestedkey1\22: \22nested value\22, \22nestedkey2\22: 456}\00" }
@"$cStr.20" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key1\00" }
@"$cStr.21" = internal global %"STRING[10]" { i8 10, i8 10, [11 x i8] c"nestedkey1\00" }
@"$cStr.22" = internal global %"STRING[12]" { i8 12, i8 12, [13 x i8] c"nested value\00" }
@"$cStr.23" = internal global %"STRING[85]" { i8 85, i8 85, [86 x i8] c"{ \22key1\22: {\22nestedkey1\22: \22nested value\22, \22nestedkey2\22: {\22nested_nested_key\22 : 1234}}}\00" }
@"$cStr.24" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"key1\00" }
@"$cStr.25" = internal global %"STRING[10]" { i8 10, i8 10, [11 x i8] c"nestedkey2\00" }
@"$cStr.26" = internal global %"STRING[17]" { i8 17, i8 17, [18 x i8] c"nested_nested_key\00" }
@"$cStr.27" = internal global %"STRING[0]" zeroinitializer
@"$cStr.28" = internal global %"STRING[0]" zeroinitializer
@"$cStr.29" = internal global %"STRING[2]" { i8 2, i8 2, [3 x i8] c", \00" }
@"$cStr.30" = internal global %"STRING[2]" { i8 2, i8 2, [3 x i8] c", \00" }
@"$cStr.31" = internal global %"STRING[3]" { i8 3, i8 3, [4 x i8] c": \22\00" }
@"$cStr.32" = internal global %"STRING[4]" { i8 4, i8 4, [5 x i8] c"true\00" }
@"$cStr.33" = internal global %"STRING[5]" { i8 5, i8 5, [6 x i8] c"false\00" }
@"$cStr.34" = internal global %"STRING[3]" { i8 3, i8 3, [4 x i8] c"\22: \00" }
@"$cStr.35" = internal global %"STRING[3]" { i8 3, i8 3, [4 x i8] c"\22: \00" }
@"$cStr.36" = internal global %"STRING[2]" { i8 2, i8 2, [3 x i8] c", \00" }
@"$cStr.37" = internal global %"STRING[3]" { i8 3, i8 3, [4 x i8] c"\22: \00" }
@"$cStr.38" = internal global %"STRING[2]" { i8 2, i8 2, [3 x i8] c", \00" }
@"$ax.throw_exception" = dso_local local_unnamed_addr global void (i8*)* @"?$ax.stderr@@YAXPEBD@Z", align 8
@"??_C@_03OFAPEBGM@?$CFs?6?$AA@" = linkonce_odr dso_local unnamed_addr constant [4 x i8] c"%s\0A\00", comdat, align 1
@"?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA" = linkonce_odr dso_local global i64 0, comdat, align 8
@"??_C@_0FE@HKMFAKJH@The?5dimension?5for?5lower_bound?5is@" = linkonce_odr dso_local unnamed_addr constant [84 x i8] c"The dimension for lower_bound is not between the dimension of this array* instance.\00", comdat, align 1
@"??_C@_0FE@MELOPMAH@The?5dimension?5for?5upper_bound?5is@" = linkonce_odr dso_local unnamed_addr constant [84 x i8] c"The dimension for upper_bound is not between the dimension of this array* instance.\00", comdat, align 1
@"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@" = linkonce_odr dso_local unnamed_addr constant [87 x i8] c"String operation failed: value's type info is corrupt: max cap: %d, used len: %d (%d)\0A\00", comdat, align 1
@"??_C@_03IGPHLJKL@NIL?$AA@" = linkonce_odr dso_local unnamed_addr constant [4 x i8] c"NIL\00", comdat, align 1
@"??_C@_0P@EALMCFKA@STRING_CORRUPT?$AA@" = linkonce_odr dso_local unnamed_addr constant [15 x i8] c"STRING_CORRUPT\00", comdat, align 1

declare %STRING.0 @"Simatic.Ax.Json.IJsonElement.ToString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement*)

declare i1 @"Simatic.Ax.Json.IJsonElement.Serialize$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)

declare i1 @"Simatic.Ax.Json.IJsonElementMuteable.HasNext$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable*)

declare %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.IJsonElementMuteable.GetNext$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable*)

declare void @"Simatic.Ax.Json.IJsonElementMuteable.AddElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)

define void @"UsingDeserializer.GetValue_BASIC_DATA_TYPES$I@R@UsingDeserializer@this"(%UsingDeserializer* %this) !dbg !97 {
Entry:
  %this.addr = alloca %UsingDeserializer*
  %stringValue = alloca %STRING.0
  %usintValue = alloca i8
  %intValue = alloca i16
  call void @llvm.dbg.declare(metadata %UsingDeserializer** %this.addr, metadata !101, metadata !DIExpression()), !dbg !102
  call void @llvm.dbg.declare(metadata %STRING.0* %stringValue, metadata !103, metadata !DIExpression()), !dbg !104
  call void @llvm.dbg.declare(metadata i8* %usintValue, metadata !105, metadata !DIExpression()), !dbg !106
  call void @llvm.dbg.declare(metadata i16* %intValue, metadata !107, metadata !DIExpression()), !dbg !108
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 999, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %3
  %4 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %4
  %5 = alloca [1 x i8]
  %6 = alloca [1 x i8]
  %7 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %7
  %8 = alloca %"$ax.ArrayWithBound"
  %9 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %9
  %10 = alloca %"$ax.ArrayWithBound"
  %11 = alloca i8
  store i8 0, i8* %11
  %12 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %12
  %13 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %13
  %14 = alloca [1 x i8]
  %15 = alloca [1 x i8]
  %16 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %16
  %17 = alloca %"$ax.ArrayWithBound"
  %18 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %18
  %19 = alloca %"$ax.ArrayWithBound"
  %20 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %20
  %21 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %21
  %22 = alloca [1 x i8]
  %23 = alloca [1 x i8]
  %24 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %24
  %25 = alloca %"$ax.ArrayWithBound"
  %26 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %26
  %27 = alloca %"$ax.ArrayWithBound"
  %28 = alloca i16
  store i16 0, i16* %28
  %29 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %29
  %30 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %30
  %31 = alloca [1 x i8]
  %32 = alloca [1 x i8]
  %33 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %33
  %34 = alloca %"$ax.ArrayWithBound"
  %35 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %35
  %36 = alloca %"$ax.ArrayWithBound"
  %37 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %37
  %38 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %38
  %39 = alloca [2 x i8]
  %40 = alloca [2 x i8]
  %41 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %41
  %42 = alloca %"$ax.ArrayWithBound"
  %43 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %43
  %44 = alloca %"$ax.ArrayWithBound"
  %45 = alloca i16
  store i16 0, i16* %45
  %46 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %46
  %47 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %47
  %48 = alloca [1 x i8]
  %49 = alloca [1 x i8]
  %50 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %50
  %51 = alloca %"$ax.ArrayWithBound"
  %52 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %52
  %53 = alloca %"$ax.ArrayWithBound"
  %54 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %54
  %55 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %55
  %56 = alloca [2 x i8]
  %57 = alloca [2 x i8]
  %58 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %58
  %59 = alloca %"$ax.ArrayWithBound"
  %60 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %60
  %61 = alloca %"$ax.ArrayWithBound"
  %62 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %62
  %63 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %63
  %64 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %64
  %65 = alloca [1 x i8]
  %66 = alloca [1 x i8]
  %67 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %67
  %68 = alloca %"$ax.ArrayWithBound"
  %69 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %69
  %70 = alloca %"$ax.ArrayWithBound"
  %71 = alloca i16
  store i16 0, i16* %71
  %72 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %72
  %73 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %73
  %74 = alloca [1 x i8]
  %75 = alloca [1 x i8]
  %76 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %76
  %77 = alloca %"$ax.ArrayWithBound"
  %78 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %78
  %79 = alloca %"$ax.ArrayWithBound"
  %80 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %80
  %81 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %81
  %82 = alloca [2 x i8]
  %83 = alloca [2 x i8]
  %84 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %84
  %85 = alloca %"$ax.ArrayWithBound"
  %86 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %86
  %87 = alloca %"$ax.ArrayWithBound"
  %88 = alloca i16
  store i16 0, i16* %88
  %89 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %89
  %90 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %90
  %91 = alloca [1 x i8]
  %92 = alloca [1 x i8]
  %93 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %93
  %94 = alloca %"$ax.ArrayWithBound"
  %95 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %95
  %96 = alloca %"$ax.ArrayWithBound"
  %97 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %97
  %98 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %98
  %99 = alloca [2 x i8]
  %100 = alloca [2 x i8]
  %101 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %101
  %102 = alloca %"$ax.ArrayWithBound"
  %103 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %103
  %104 = alloca %"$ax.ArrayWithBound"
  store %UsingDeserializer* %this, %UsingDeserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %stringValue
  store i8 0, i8* %usintValue
  store i16 0, i16* %intValue
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !109
  %JSON_Entry = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr, i32 0, i32 3, !dbg !109
  %105 = bitcast %STRING.0* %JSON_Entry to i8*, !dbg !109
  call void @"$ax.AssignST_String"(i8* %105, i8* getelementptr inbounds (%"STRING[66]", %"STRING[66]"* @"$cStr.4", i32 0, i32 0)), !dbg !109
  %auto_deref_this.addr1 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !110
  %JSON_Entry2 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr1, i32 0, i32 3, !dbg !110
  %auto_deref_this.addr3 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !110
  %buffer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr3, i32 0, i32 2, !dbg !110
  %106 = bitcast %STRING.0* %JSON_Entry2 to i8*, !dbg !110
  %107 = bitcast [1000 x i8]* %buffer to i8*, !dbg !110
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1, !dbg !110
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0, !dbg !110
  store i8* %107, i8** %"$array_ptr", !dbg !110
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2, !dbg !110
  %108 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*, !dbg !110
  store %"$ax.ArrayBounds"* %108, %"$ax.ArrayBounds"** %"$bounds", !dbg !110
  %109 = call i32 @"Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr"(i8* %106, %"$ax.ArrayWithBound"* %1), !dbg !110
  %auto_deref_this.addr4 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !110
  %len = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr4, i32 0, i32 5, !dbg !110
  store i32 %109, i32* %len, !dbg !110
  %auto_deref_this.addr5 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !111
  %deserializer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr5, i32 0, i32 1, !dbg !111
  %auto_deref_this.addr6 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !111
  %buffer7 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr6, i32 0, i32 2, !dbg !111
  %110 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer, i32 0, i32 0, !dbg !111
  %111 = load i8*, i8** %110, !dbg !111
  %112 = bitcast i8* %111 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !111
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %112, i32 0, i32 4, !dbg !111
  %113 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable", i32 0, i32 0, !dbg !111
  %114 = load i8*, i8** %113, !dbg !111
  %115 = bitcast i8* %114 to void (%Simatic.Ax.Json.Deserializer*, [1000 x i8]*)*, !dbg !111
  call void %115(%Simatic.Ax.Json.Deserializer* %deserializer, [1000 x i8]* %buffer7), !dbg !111
  %auto_deref_this.addr8 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !112
  %key = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr8, i32 0, i32 4, !dbg !112
  %116 = bitcast %STRING.0* %key to i8*, !dbg !112
  call void @"$ax.AssignST_String"(i8* %116, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.5", i32 0, i32 0)), !dbg !112
  %auto_deref_this.addr9 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !113
  %deserializer10 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr9, i32 0, i32 1, !dbg !113
  %auto_deref_this.addr11 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !113
  %key12 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr11, i32 0, i32 4, !dbg !113
  %117 = bitcast %STRING.0* %2 to i8*, !dbg !113
  %118 = bitcast %STRING.0* %stringValue to i8*, !dbg !113
  call void @"$ax.AssignST_String"(i8* %117, i8* %118), !dbg !113
  %119 = bitcast %STRING.0* %key12 to i8*, !dbg !113
  %120 = bitcast %STRING.0* %2 to i8*, !dbg !113
  %121 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer10, i32 0, i32 0, !dbg !113
  %122 = load i8*, i8** %121, !dbg !113
  %123 = bitcast i8* %122 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !113
  %"$vTable13" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %123, i32 0, i32 4, !dbg !113
  %124 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable13", i32 0, i32 5, !dbg !113
  %125 = load i8*, i8** %124, !dbg !113
  %126 = bitcast i8* %125 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)*, !dbg !113
  %127 = call i1 %126(%Simatic.Ax.Json.Deserializer* %deserializer10, i8* %119, i8* %120), !dbg !113
  %128 = bitcast %STRING.0* %stringValue to i8*, !dbg !113
  %129 = bitcast %STRING.0* %2 to i8*, !dbg !113
  call void @"$ax.AssignST_String"(i8* %128, i8* %129), !dbg !113
  %auto_deref_this.addr14 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !113
  %keyFound = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr14, i32 0, i32 6, !dbg !113
  store i1 %127, i1* %keyFound, !dbg !113
  %auto_deref_this.addr15 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !114
  %keyFound16 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr15, i32 0, i32 6, !dbg !114
  %130 = load i1, i1* %keyFound16, !dbg !114
  %131 = icmp eq i1 %130, true, !dbg !114
  %132 = load i1, i1* @GlobalAssertValue, !dbg !114
  %133 = and i1 %131, %132, !dbg !114
  store i1 %133, i1* @GlobalAssertValue, !dbg !114
  %134 = load i1, i1* %keyFound16, !dbg !114
  %135 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %134), !dbg !114
  store [1 x i8] %135, [1 x i8]* %5, !dbg !114
  %136 = load [1 x i8], [1 x i8]* %5, !dbg !114
  store [1 x i8] %136, [1 x i8]* %3, !dbg !114
  %137 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !114
  store [1 x i8] %137, [1 x i8]* %6, !dbg !114
  %138 = load [1 x i8], [1 x i8]* %6, !dbg !114
  store [1 x i8] %138, [1 x i8]* %4, !dbg !114
  %139 = bitcast [1 x i8]* %3 to i8*, !dbg !114
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %8, !dbg !114
  %"$array_ptr17" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 0, !dbg !114
  store i8* %139, i8** %"$array_ptr17", !dbg !114
  %"$bounds18" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 2, !dbg !114
  %140 = bitcast [1 x %"$ax.ArrayBounds"]* %7 to %"$ax.ArrayBounds"*, !dbg !114
  store %"$ax.ArrayBounds"* %140, %"$ax.ArrayBounds"** %"$bounds18", !dbg !114
  %141 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, !dbg !114
  %142 = bitcast [1 x i8]* %4 to i8*, !dbg !114
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %10, !dbg !114
  %"$array_ptr19" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 0, !dbg !114
  store i8* %142, i8** %"$array_ptr19", !dbg !114
  %"$bounds20" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 2, !dbg !114
  %143 = bitcast [1 x %"$ax.ArrayBounds"]* %9 to %"$ax.ArrayBounds"*, !dbg !114
  store %"$ax.ArrayBounds"* %143, %"$ax.ArrayBounds"** %"$bounds20", !dbg !114
  %144 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, !dbg !114
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %131, i16 0, i8 1, i8 1, %"$ax.ArrayWithBound" %141, %"$ax.ArrayWithBound" %144, i16 1), !dbg !114
  %145 = bitcast %STRING.0* %stringValue to i8*, !dbg !115
  %146 = call i32 @"$ax.CmpST_String"(i8* %145, i8* getelementptr inbounds (%"STRING[11]", %"STRING[11]"* @"$cStr.6", i32 0, i32 0)), !dbg !115
  %147 = icmp eq i32 %146, 0, !dbg !115
  %148 = load i1, i1* @GlobalAssertValue, !dbg !115
  %149 = and i1 %147, %148, !dbg !115
  store i1 %149, i1* @GlobalAssertValue, !dbg !115
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %147, i16 1, i8 1, i8 0), !dbg !115
  %auto_deref_this.addr21 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !116
  %key22 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr21, i32 0, i32 4, !dbg !116
  %150 = bitcast %STRING.0* %key22 to i8*, !dbg !116
  call void @"$ax.AssignST_String"(i8* %150, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.7", i32 0, i32 0)), !dbg !116
  %auto_deref_this.addr23 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !117
  %deserializer24 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr23, i32 0, i32 1, !dbg !117
  %auto_deref_this.addr25 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !117
  %key26 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr25, i32 0, i32 4, !dbg !117
  %151 = load i8, i8* %usintValue, !dbg !117
  store i8 %151, i8* %11, !dbg !117
  %152 = bitcast %STRING.0* %key26 to i8*, !dbg !117
  %153 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer24, i32 0, i32 0, !dbg !117
  %154 = load i8*, i8** %153, !dbg !117
  %155 = bitcast i8* %154 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !117
  %"$vTable27" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %155, i32 0, i32 4, !dbg !117
  %156 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable27", i32 0, i32 9, !dbg !117
  %157 = load i8*, i8** %156, !dbg !117
  %158 = bitcast i8* %157 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)*, !dbg !117
  %159 = call i1 %158(%Simatic.Ax.Json.Deserializer* %deserializer24, i8* %152, i8* %11), !dbg !117
  %160 = load i8, i8* %11, !dbg !117
  store i8 %160, i8* %usintValue, !dbg !117
  %auto_deref_this.addr28 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !117
  %keyFound29 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr28, i32 0, i32 6, !dbg !117
  store i1 %159, i1* %keyFound29, !dbg !117
  %auto_deref_this.addr30 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !118
  %keyFound31 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr30, i32 0, i32 6, !dbg !118
  %161 = load i1, i1* %keyFound31, !dbg !118
  %162 = icmp eq i1 %161, true, !dbg !118
  %163 = load i1, i1* @GlobalAssertValue, !dbg !118
  %164 = and i1 %162, %163, !dbg !118
  store i1 %164, i1* @GlobalAssertValue, !dbg !118
  %165 = load i1, i1* %keyFound31, !dbg !118
  %166 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %165), !dbg !118
  store [1 x i8] %166, [1 x i8]* %14, !dbg !118
  %167 = load [1 x i8], [1 x i8]* %14, !dbg !118
  store [1 x i8] %167, [1 x i8]* %12, !dbg !118
  %168 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !118
  store [1 x i8] %168, [1 x i8]* %15, !dbg !118
  %169 = load [1 x i8], [1 x i8]* %15, !dbg !118
  store [1 x i8] %169, [1 x i8]* %13, !dbg !118
  %170 = bitcast [1 x i8]* %12 to i8*, !dbg !118
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %17, !dbg !118
  %"$array_ptr32" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %17, i32 0, i32 0, !dbg !118
  store i8* %170, i8** %"$array_ptr32", !dbg !118
  %"$bounds33" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %17, i32 0, i32 2, !dbg !118
  %171 = bitcast [1 x %"$ax.ArrayBounds"]* %16 to %"$ax.ArrayBounds"*, !dbg !118
  store %"$ax.ArrayBounds"* %171, %"$ax.ArrayBounds"** %"$bounds33", !dbg !118
  %172 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %17, !dbg !118
  %173 = bitcast [1 x i8]* %13 to i8*, !dbg !118
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %19, !dbg !118
  %"$array_ptr34" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 0, !dbg !118
  store i8* %173, i8** %"$array_ptr34", !dbg !118
  %"$bounds35" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 2, !dbg !118
  %174 = bitcast [1 x %"$ax.ArrayBounds"]* %18 to %"$ax.ArrayBounds"*, !dbg !118
  store %"$ax.ArrayBounds"* %174, %"$ax.ArrayBounds"** %"$bounds35", !dbg !118
  %175 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, !dbg !118
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %162, i16 2, i8 1, i8 1, %"$ax.ArrayWithBound" %172, %"$ax.ArrayWithBound" %175, i16 1), !dbg !118
  %176 = load i8, i8* %usintValue, !dbg !119
  %177 = icmp eq i8 %176, 10, !dbg !119
  %178 = load i1, i1* @GlobalAssertValue, !dbg !119
  %179 = and i1 %177, %178, !dbg !119
  store i1 %179, i1* @GlobalAssertValue, !dbg !119
  %180 = load i8, i8* %usintValue, !dbg !119
  %181 = call [1 x i8] @"AxUnit.ToByteArray$I@V@UInt8@value"(i8 %180), !dbg !119
  store [1 x i8] %181, [1 x i8]* %22, !dbg !119
  %182 = load [1 x i8], [1 x i8]* %22, !dbg !119
  store [1 x i8] %182, [1 x i8]* %20, !dbg !119
  %183 = call [1 x i8] @"AxUnit.ToByteArray$I@V@UInt8@value"(i8 10), !dbg !119
  store [1 x i8] %183, [1 x i8]* %23, !dbg !119
  %184 = load [1 x i8], [1 x i8]* %23, !dbg !119
  store [1 x i8] %184, [1 x i8]* %21, !dbg !119
  %185 = bitcast [1 x i8]* %20 to i8*, !dbg !119
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %25, !dbg !119
  %"$array_ptr36" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %25, i32 0, i32 0, !dbg !119
  store i8* %185, i8** %"$array_ptr36", !dbg !119
  %"$bounds37" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %25, i32 0, i32 2, !dbg !119
  %186 = bitcast [1 x %"$ax.ArrayBounds"]* %24 to %"$ax.ArrayBounds"*, !dbg !119
  store %"$ax.ArrayBounds"* %186, %"$ax.ArrayBounds"** %"$bounds37", !dbg !119
  %187 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %25, !dbg !119
  %188 = bitcast [1 x i8]* %21 to i8*, !dbg !119
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %27, !dbg !119
  %"$array_ptr38" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %27, i32 0, i32 0, !dbg !119
  store i8* %188, i8** %"$array_ptr38", !dbg !119
  %"$bounds39" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %27, i32 0, i32 2, !dbg !119
  %189 = bitcast [1 x %"$ax.ArrayBounds"]* %26 to %"$ax.ArrayBounds"*, !dbg !119
  store %"$ax.ArrayBounds"* %189, %"$ax.ArrayBounds"** %"$bounds39", !dbg !119
  %190 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %27, !dbg !119
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %177, i16 3, i8 1, i8 6, %"$ax.ArrayWithBound" %187, %"$ax.ArrayWithBound" %190, i16 1), !dbg !119
  %auto_deref_this.addr40 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !120
  %key41 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr40, i32 0, i32 4, !dbg !120
  %191 = bitcast %STRING.0* %key41 to i8*, !dbg !120
  call void @"$ax.AssignST_String"(i8* %191, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.8", i32 0, i32 0)), !dbg !120
  %auto_deref_this.addr42 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !121
  %deserializer43 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr42, i32 0, i32 1, !dbg !121
  %auto_deref_this.addr44 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !121
  %key45 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr44, i32 0, i32 4, !dbg !121
  %192 = load i16, i16* %intValue, !dbg !121
  store i16 %192, i16* %28, !dbg !121
  %193 = bitcast %STRING.0* %key45 to i8*, !dbg !121
  %194 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer43, i32 0, i32 0, !dbg !121
  %195 = load i8*, i8** %194, !dbg !121
  %196 = bitcast i8* %195 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !121
  %"$vTable46" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %196, i32 0, i32 4, !dbg !121
  %197 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable46", i32 0, i32 2, !dbg !121
  %198 = load i8*, i8** %197, !dbg !121
  %199 = bitcast i8* %198 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)*, !dbg !121
  %200 = call i1 %199(%Simatic.Ax.Json.Deserializer* %deserializer43, i8* %193, i16* %28), !dbg !121
  %201 = load i16, i16* %28, !dbg !121
  store i16 %201, i16* %intValue, !dbg !121
  %auto_deref_this.addr47 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !121
  %keyFound48 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr47, i32 0, i32 6, !dbg !121
  store i1 %200, i1* %keyFound48, !dbg !121
  %auto_deref_this.addr49 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !122
  %keyFound50 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr49, i32 0, i32 6, !dbg !122
  %202 = load i1, i1* %keyFound50, !dbg !122
  %203 = icmp eq i1 %202, true, !dbg !122
  %204 = load i1, i1* @GlobalAssertValue, !dbg !122
  %205 = and i1 %203, %204, !dbg !122
  store i1 %205, i1* @GlobalAssertValue, !dbg !122
  %206 = load i1, i1* %keyFound50, !dbg !122
  %207 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %206), !dbg !122
  store [1 x i8] %207, [1 x i8]* %31, !dbg !122
  %208 = load [1 x i8], [1 x i8]* %31, !dbg !122
  store [1 x i8] %208, [1 x i8]* %29, !dbg !122
  %209 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !122
  store [1 x i8] %209, [1 x i8]* %32, !dbg !122
  %210 = load [1 x i8], [1 x i8]* %32, !dbg !122
  store [1 x i8] %210, [1 x i8]* %30, !dbg !122
  %211 = bitcast [1 x i8]* %29 to i8*, !dbg !122
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %34, !dbg !122
  %"$array_ptr51" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %34, i32 0, i32 0, !dbg !122
  store i8* %211, i8** %"$array_ptr51", !dbg !122
  %"$bounds52" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %34, i32 0, i32 2, !dbg !122
  %212 = bitcast [1 x %"$ax.ArrayBounds"]* %33 to %"$ax.ArrayBounds"*, !dbg !122
  store %"$ax.ArrayBounds"* %212, %"$ax.ArrayBounds"** %"$bounds52", !dbg !122
  %213 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %34, !dbg !122
  %214 = bitcast [1 x i8]* %30 to i8*, !dbg !122
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %36, !dbg !122
  %"$array_ptr53" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %36, i32 0, i32 0, !dbg !122
  store i8* %214, i8** %"$array_ptr53", !dbg !122
  %"$bounds54" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %36, i32 0, i32 2, !dbg !122
  %215 = bitcast [1 x %"$ax.ArrayBounds"]* %35 to %"$ax.ArrayBounds"*, !dbg !122
  store %"$ax.ArrayBounds"* %215, %"$ax.ArrayBounds"** %"$bounds54", !dbg !122
  %216 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %36, !dbg !122
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %203, i16 4, i8 1, i8 1, %"$ax.ArrayWithBound" %213, %"$ax.ArrayWithBound" %216, i16 1), !dbg !122
  %217 = load i16, i16* %intValue, !dbg !123
  %218 = icmp eq i16 %217, 1234, !dbg !123
  %219 = load i1, i1* @GlobalAssertValue, !dbg !123
  %220 = and i1 %218, %219, !dbg !123
  store i1 %220, i1* @GlobalAssertValue, !dbg !123
  %221 = load i16, i16* %intValue, !dbg !123
  %222 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %221), !dbg !123
  store [2 x i8] %222, [2 x i8]* %39, !dbg !123
  %223 = load [2 x i8], [2 x i8]* %39, !dbg !123
  store [2 x i8] %223, [2 x i8]* %37, !dbg !123
  %224 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 1234), !dbg !123
  store [2 x i8] %224, [2 x i8]* %40, !dbg !123
  %225 = load [2 x i8], [2 x i8]* %40, !dbg !123
  store [2 x i8] %225, [2 x i8]* %38, !dbg !123
  %226 = bitcast [2 x i8]* %37 to i8*, !dbg !123
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %42, !dbg !123
  %"$array_ptr55" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %42, i32 0, i32 0, !dbg !123
  store i8* %226, i8** %"$array_ptr55", !dbg !123
  %"$bounds56" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %42, i32 0, i32 2, !dbg !123
  %227 = bitcast [1 x %"$ax.ArrayBounds"]* %41 to %"$ax.ArrayBounds"*, !dbg !123
  store %"$ax.ArrayBounds"* %227, %"$ax.ArrayBounds"** %"$bounds56", !dbg !123
  %228 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %42, !dbg !123
  %229 = bitcast [2 x i8]* %38 to i8*, !dbg !123
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %44, !dbg !123
  %"$array_ptr57" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %44, i32 0, i32 0, !dbg !123
  store i8* %229, i8** %"$array_ptr57", !dbg !123
  %"$bounds58" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %44, i32 0, i32 2, !dbg !123
  %230 = bitcast [1 x %"$ax.ArrayBounds"]* %43 to %"$ax.ArrayBounds"*, !dbg !123
  store %"$ax.ArrayBounds"* %230, %"$ax.ArrayBounds"** %"$bounds58", !dbg !123
  %231 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %44, !dbg !123
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %218, i16 5, i8 1, i8 3, %"$ax.ArrayWithBound" %228, %"$ax.ArrayWithBound" %231, i16 2), !dbg !123
  %auto_deref_this.addr59 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !124
  %key60 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr59, i32 0, i32 4, !dbg !124
  %232 = bitcast %STRING.0* %key60 to i8*, !dbg !124
  call void @"$ax.AssignST_String"(i8* %232, i8* getelementptr inbounds (%"STRING[9]", %"STRING[9]"* @"$cStr.9", i32 0, i32 0)), !dbg !124
  %auto_deref_this.addr61 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !125
  %deserializer62 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr61, i32 0, i32 1, !dbg !125
  %auto_deref_this.addr63 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !125
  %key64 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr63, i32 0, i32 4, !dbg !125
  %233 = load i16, i16* %intValue, !dbg !125
  store i16 %233, i16* %45, !dbg !125
  %234 = bitcast %STRING.0* %key64 to i8*, !dbg !125
  %235 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer62, i32 0, i32 0, !dbg !125
  %236 = load i8*, i8** %235, !dbg !125
  %237 = bitcast i8* %236 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !125
  %"$vTable65" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %237, i32 0, i32 4, !dbg !125
  %238 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable65", i32 0, i32 2, !dbg !125
  %239 = load i8*, i8** %238, !dbg !125
  %240 = bitcast i8* %239 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)*, !dbg !125
  %241 = call i1 %240(%Simatic.Ax.Json.Deserializer* %deserializer62, i8* %234, i16* %45), !dbg !125
  %242 = load i16, i16* %45, !dbg !125
  store i16 %242, i16* %intValue, !dbg !125
  %auto_deref_this.addr66 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !125
  %keyFound67 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr66, i32 0, i32 6, !dbg !125
  store i1 %241, i1* %keyFound67, !dbg !125
  %auto_deref_this.addr68 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !126
  %keyFound69 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr68, i32 0, i32 6, !dbg !126
  %243 = load i1, i1* %keyFound69, !dbg !126
  %244 = icmp eq i1 %243, false, !dbg !126
  %245 = load i1, i1* @GlobalAssertValue, !dbg !126
  %246 = and i1 %244, %245, !dbg !126
  store i1 %246, i1* @GlobalAssertValue, !dbg !126
  %247 = load i1, i1* %keyFound69, !dbg !126
  %248 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %247), !dbg !126
  store [1 x i8] %248, [1 x i8]* %48, !dbg !126
  %249 = load [1 x i8], [1 x i8]* %48, !dbg !126
  store [1 x i8] %249, [1 x i8]* %46, !dbg !126
  %250 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 false), !dbg !126
  store [1 x i8] %250, [1 x i8]* %49, !dbg !126
  %251 = load [1 x i8], [1 x i8]* %49, !dbg !126
  store [1 x i8] %251, [1 x i8]* %47, !dbg !126
  %252 = bitcast [1 x i8]* %46 to i8*, !dbg !126
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %51, !dbg !126
  %"$array_ptr70" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %51, i32 0, i32 0, !dbg !126
  store i8* %252, i8** %"$array_ptr70", !dbg !126
  %"$bounds71" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %51, i32 0, i32 2, !dbg !126
  %253 = bitcast [1 x %"$ax.ArrayBounds"]* %50 to %"$ax.ArrayBounds"*, !dbg !126
  store %"$ax.ArrayBounds"* %253, %"$ax.ArrayBounds"** %"$bounds71", !dbg !126
  %254 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %51, !dbg !126
  %255 = bitcast [1 x i8]* %47 to i8*, !dbg !126
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %53, !dbg !126
  %"$array_ptr72" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %53, i32 0, i32 0, !dbg !126
  store i8* %255, i8** %"$array_ptr72", !dbg !126
  %"$bounds73" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %53, i32 0, i32 2, !dbg !126
  %256 = bitcast [1 x %"$ax.ArrayBounds"]* %52 to %"$ax.ArrayBounds"*, !dbg !126
  store %"$ax.ArrayBounds"* %256, %"$ax.ArrayBounds"** %"$bounds73", !dbg !126
  %257 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %53, !dbg !126
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %244, i16 6, i8 1, i8 1, %"$ax.ArrayWithBound" %254, %"$ax.ArrayWithBound" %257, i16 1), !dbg !126
  %258 = load i16, i16* %intValue, !dbg !127
  %259 = icmp eq i16 %258, 0, !dbg !127
  %260 = load i1, i1* @GlobalAssertValue, !dbg !127
  %261 = and i1 %259, %260, !dbg !127
  store i1 %261, i1* @GlobalAssertValue, !dbg !127
  %262 = load i16, i16* %intValue, !dbg !127
  %263 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %262), !dbg !127
  store [2 x i8] %263, [2 x i8]* %56, !dbg !127
  %264 = load [2 x i8], [2 x i8]* %56, !dbg !127
  store [2 x i8] %264, [2 x i8]* %54, !dbg !127
  %265 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 0), !dbg !127
  store [2 x i8] %265, [2 x i8]* %57, !dbg !127
  %266 = load [2 x i8], [2 x i8]* %57, !dbg !127
  store [2 x i8] %266, [2 x i8]* %55, !dbg !127
  %267 = bitcast [2 x i8]* %54 to i8*, !dbg !127
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %59, !dbg !127
  %"$array_ptr74" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %59, i32 0, i32 0, !dbg !127
  store i8* %267, i8** %"$array_ptr74", !dbg !127
  %"$bounds75" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %59, i32 0, i32 2, !dbg !127
  %268 = bitcast [1 x %"$ax.ArrayBounds"]* %58 to %"$ax.ArrayBounds"*, !dbg !127
  store %"$ax.ArrayBounds"* %268, %"$ax.ArrayBounds"** %"$bounds75", !dbg !127
  %269 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %59, !dbg !127
  %270 = bitcast [2 x i8]* %55 to i8*, !dbg !127
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %61, !dbg !127
  %"$array_ptr76" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %61, i32 0, i32 0, !dbg !127
  store i8* %270, i8** %"$array_ptr76", !dbg !127
  %"$bounds77" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %61, i32 0, i32 2, !dbg !127
  %271 = bitcast [1 x %"$ax.ArrayBounds"]* %60 to %"$ax.ArrayBounds"*, !dbg !127
  store %"$ax.ArrayBounds"* %271, %"$ax.ArrayBounds"** %"$bounds77", !dbg !127
  %272 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %61, !dbg !127
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %259, i16 7, i8 1, i8 3, %"$ax.ArrayWithBound" %269, %"$ax.ArrayWithBound" %272, i16 2), !dbg !127
  %auto_deref_this.addr78 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !128
  %key79 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr78, i32 0, i32 4, !dbg !128
  %273 = bitcast %STRING.0* %key79 to i8*, !dbg !128
  call void @"$ax.AssignST_String"(i8* %273, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.10", i32 0, i32 0)), !dbg !128
  %auto_deref_this.addr80 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !129
  %deserializer81 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr80, i32 0, i32 1, !dbg !129
  %auto_deref_this.addr82 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !129
  %key83 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr82, i32 0, i32 4, !dbg !129
  %274 = bitcast %STRING.0* %62 to i8*, !dbg !129
  %275 = bitcast %STRING.0* %stringValue to i8*, !dbg !129
  call void @"$ax.AssignST_String"(i8* %274, i8* %275), !dbg !129
  %276 = bitcast %STRING.0* %key83 to i8*, !dbg !129
  %277 = bitcast %STRING.0* %62 to i8*, !dbg !129
  %278 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer81, i32 0, i32 0, !dbg !129
  %279 = load i8*, i8** %278, !dbg !129
  %280 = bitcast i8* %279 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !129
  %"$vTable84" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %280, i32 0, i32 4, !dbg !129
  %281 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable84", i32 0, i32 5, !dbg !129
  %282 = load i8*, i8** %281, !dbg !129
  %283 = bitcast i8* %282 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)*, !dbg !129
  %284 = call i1 %283(%Simatic.Ax.Json.Deserializer* %deserializer81, i8* %276, i8* %277), !dbg !129
  %285 = bitcast %STRING.0* %stringValue to i8*, !dbg !129
  %286 = bitcast %STRING.0* %62 to i8*, !dbg !129
  call void @"$ax.AssignST_String"(i8* %285, i8* %286), !dbg !129
  %auto_deref_this.addr85 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !129
  %keyFound86 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr85, i32 0, i32 6, !dbg !129
  store i1 %284, i1* %keyFound86, !dbg !129
  %auto_deref_this.addr87 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !130
  %keyFound88 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr87, i32 0, i32 6, !dbg !130
  %287 = load i1, i1* %keyFound88, !dbg !130
  %288 = icmp eq i1 %287, true, !dbg !130
  %289 = load i1, i1* @GlobalAssertValue, !dbg !130
  %290 = and i1 %288, %289, !dbg !130
  store i1 %290, i1* @GlobalAssertValue, !dbg !130
  %291 = load i1, i1* %keyFound88, !dbg !130
  %292 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %291), !dbg !130
  store [1 x i8] %292, [1 x i8]* %65, !dbg !130
  %293 = load [1 x i8], [1 x i8]* %65, !dbg !130
  store [1 x i8] %293, [1 x i8]* %63, !dbg !130
  %294 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !130
  store [1 x i8] %294, [1 x i8]* %66, !dbg !130
  %295 = load [1 x i8], [1 x i8]* %66, !dbg !130
  store [1 x i8] %295, [1 x i8]* %64, !dbg !130
  %296 = bitcast [1 x i8]* %63 to i8*, !dbg !130
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %68, !dbg !130
  %"$array_ptr89" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %68, i32 0, i32 0, !dbg !130
  store i8* %296, i8** %"$array_ptr89", !dbg !130
  %"$bounds90" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %68, i32 0, i32 2, !dbg !130
  %297 = bitcast [1 x %"$ax.ArrayBounds"]* %67 to %"$ax.ArrayBounds"*, !dbg !130
  store %"$ax.ArrayBounds"* %297, %"$ax.ArrayBounds"** %"$bounds90", !dbg !130
  %298 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %68, !dbg !130
  %299 = bitcast [1 x i8]* %64 to i8*, !dbg !130
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %70, !dbg !130
  %"$array_ptr91" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %70, i32 0, i32 0, !dbg !130
  store i8* %299, i8** %"$array_ptr91", !dbg !130
  %"$bounds92" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %70, i32 0, i32 2, !dbg !130
  %300 = bitcast [1 x %"$ax.ArrayBounds"]* %69 to %"$ax.ArrayBounds"*, !dbg !130
  store %"$ax.ArrayBounds"* %300, %"$ax.ArrayBounds"** %"$bounds92", !dbg !130
  %301 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %70, !dbg !130
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %288, i16 8, i8 1, i8 1, %"$ax.ArrayWithBound" %298, %"$ax.ArrayWithBound" %301, i16 1), !dbg !130
  %302 = bitcast %STRING.0* %stringValue to i8*, !dbg !131
  %303 = call i32 @"$ax.CmpST_String"(i8* %302, i8* getelementptr inbounds (%"STRING[2]", %"STRING[2]"* @"$cStr.11", i32 0, i32 0)), !dbg !131
  %304 = icmp eq i32 %303, 0, !dbg !131
  %305 = load i1, i1* @GlobalAssertValue, !dbg !131
  %306 = and i1 %304, %305, !dbg !131
  store i1 %306, i1* @GlobalAssertValue, !dbg !131
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %304, i16 9, i8 1, i8 0), !dbg !131
  %auto_deref_this.addr93 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !132
  %key94 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr93, i32 0, i32 4, !dbg !132
  %307 = bitcast %STRING.0* %key94 to i8*, !dbg !132
  call void @"$ax.AssignST_String"(i8* %307, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.12", i32 0, i32 0)), !dbg !132
  %auto_deref_this.addr95 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !133
  %deserializer96 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr95, i32 0, i32 1, !dbg !133
  %auto_deref_this.addr97 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !133
  %key98 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr97, i32 0, i32 4, !dbg !133
  %308 = load i16, i16* %intValue, !dbg !133
  store i16 %308, i16* %71, !dbg !133
  %309 = bitcast %STRING.0* %key98 to i8*, !dbg !133
  %310 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer96, i32 0, i32 0, !dbg !133
  %311 = load i8*, i8** %310, !dbg !133
  %312 = bitcast i8* %311 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !133
  %"$vTable99" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %312, i32 0, i32 4, !dbg !133
  %313 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable99", i32 0, i32 2, !dbg !133
  %314 = load i8*, i8** %313, !dbg !133
  %315 = bitcast i8* %314 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)*, !dbg !133
  %316 = call i1 %315(%Simatic.Ax.Json.Deserializer* %deserializer96, i8* %309, i16* %71), !dbg !133
  %317 = load i16, i16* %71, !dbg !133
  store i16 %317, i16* %intValue, !dbg !133
  %auto_deref_this.addr100 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !133
  %keyFound101 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr100, i32 0, i32 6, !dbg !133
  store i1 %316, i1* %keyFound101, !dbg !133
  %auto_deref_this.addr102 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !134
  %keyFound103 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr102, i32 0, i32 6, !dbg !134
  %318 = load i1, i1* %keyFound103, !dbg !134
  %319 = icmp eq i1 %318, true, !dbg !134
  %320 = load i1, i1* @GlobalAssertValue, !dbg !134
  %321 = and i1 %319, %320, !dbg !134
  store i1 %321, i1* @GlobalAssertValue, !dbg !134
  %322 = load i1, i1* %keyFound103, !dbg !134
  %323 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %322), !dbg !134
  store [1 x i8] %323, [1 x i8]* %74, !dbg !134
  %324 = load [1 x i8], [1 x i8]* %74, !dbg !134
  store [1 x i8] %324, [1 x i8]* %72, !dbg !134
  %325 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !134
  store [1 x i8] %325, [1 x i8]* %75, !dbg !134
  %326 = load [1 x i8], [1 x i8]* %75, !dbg !134
  store [1 x i8] %326, [1 x i8]* %73, !dbg !134
  %327 = bitcast [1 x i8]* %72 to i8*, !dbg !134
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %77, !dbg !134
  %"$array_ptr104" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %77, i32 0, i32 0, !dbg !134
  store i8* %327, i8** %"$array_ptr104", !dbg !134
  %"$bounds105" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %77, i32 0, i32 2, !dbg !134
  %328 = bitcast [1 x %"$ax.ArrayBounds"]* %76 to %"$ax.ArrayBounds"*, !dbg !134
  store %"$ax.ArrayBounds"* %328, %"$ax.ArrayBounds"** %"$bounds105", !dbg !134
  %329 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %77, !dbg !134
  %330 = bitcast [1 x i8]* %73 to i8*, !dbg !134
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %79, !dbg !134
  %"$array_ptr106" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %79, i32 0, i32 0, !dbg !134
  store i8* %330, i8** %"$array_ptr106", !dbg !134
  %"$bounds107" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %79, i32 0, i32 2, !dbg !134
  %331 = bitcast [1 x %"$ax.ArrayBounds"]* %78 to %"$ax.ArrayBounds"*, !dbg !134
  store %"$ax.ArrayBounds"* %331, %"$ax.ArrayBounds"** %"$bounds107", !dbg !134
  %332 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %79, !dbg !134
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %319, i16 10, i8 1, i8 1, %"$ax.ArrayWithBound" %329, %"$ax.ArrayWithBound" %332, i16 1), !dbg !134
  %333 = load i16, i16* %intValue, !dbg !135
  %334 = icmp eq i16 %333, 1234, !dbg !135
  %335 = load i1, i1* @GlobalAssertValue, !dbg !135
  %336 = and i1 %334, %335, !dbg !135
  store i1 %336, i1* @GlobalAssertValue, !dbg !135
  %337 = load i16, i16* %intValue, !dbg !135
  %338 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %337), !dbg !135
  store [2 x i8] %338, [2 x i8]* %82, !dbg !135
  %339 = load [2 x i8], [2 x i8]* %82, !dbg !135
  store [2 x i8] %339, [2 x i8]* %80, !dbg !135
  %340 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 1234), !dbg !135
  store [2 x i8] %340, [2 x i8]* %83, !dbg !135
  %341 = load [2 x i8], [2 x i8]* %83, !dbg !135
  store [2 x i8] %341, [2 x i8]* %81, !dbg !135
  %342 = bitcast [2 x i8]* %80 to i8*, !dbg !135
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %85, !dbg !135
  %"$array_ptr108" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %85, i32 0, i32 0, !dbg !135
  store i8* %342, i8** %"$array_ptr108", !dbg !135
  %"$bounds109" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %85, i32 0, i32 2, !dbg !135
  %343 = bitcast [1 x %"$ax.ArrayBounds"]* %84 to %"$ax.ArrayBounds"*, !dbg !135
  store %"$ax.ArrayBounds"* %343, %"$ax.ArrayBounds"** %"$bounds109", !dbg !135
  %344 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %85, !dbg !135
  %345 = bitcast [2 x i8]* %81 to i8*, !dbg !135
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %87, !dbg !135
  %"$array_ptr110" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %87, i32 0, i32 0, !dbg !135
  store i8* %345, i8** %"$array_ptr110", !dbg !135
  %"$bounds111" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %87, i32 0, i32 2, !dbg !135
  %346 = bitcast [1 x %"$ax.ArrayBounds"]* %86 to %"$ax.ArrayBounds"*, !dbg !135
  store %"$ax.ArrayBounds"* %346, %"$ax.ArrayBounds"** %"$bounds111", !dbg !135
  %347 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %87, !dbg !135
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %334, i16 11, i8 1, i8 3, %"$ax.ArrayWithBound" %344, %"$ax.ArrayWithBound" %347, i16 2), !dbg !135
  %auto_deref_this.addr112 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !136
  %key113 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr112, i32 0, i32 4, !dbg !136
  %348 = bitcast %STRING.0* %key113 to i8*, !dbg !136
  call void @"$ax.AssignST_String"(i8* %348, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.13", i32 0, i32 0)), !dbg !136
  %auto_deref_this.addr114 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !137
  %deserializer115 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr114, i32 0, i32 1, !dbg !137
  %auto_deref_this.addr116 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !137
  %key117 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr116, i32 0, i32 4, !dbg !137
  %349 = load i16, i16* %intValue, !dbg !137
  store i16 %349, i16* %88, !dbg !137
  %350 = bitcast %STRING.0* %key117 to i8*, !dbg !137
  %351 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer115, i32 0, i32 0, !dbg !137
  %352 = load i8*, i8** %351, !dbg !137
  %353 = bitcast i8* %352 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !137
  %"$vTable118" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %353, i32 0, i32 4, !dbg !137
  %354 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable118", i32 0, i32 2, !dbg !137
  %355 = load i8*, i8** %354, !dbg !137
  %356 = bitcast i8* %355 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i16*)*, !dbg !137
  %357 = call i1 %356(%Simatic.Ax.Json.Deserializer* %deserializer115, i8* %350, i16* %88), !dbg !137
  %358 = load i16, i16* %88, !dbg !137
  store i16 %358, i16* %intValue, !dbg !137
  %auto_deref_this.addr119 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !137
  %keyFound120 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr119, i32 0, i32 6, !dbg !137
  store i1 %357, i1* %keyFound120, !dbg !137
  %auto_deref_this.addr121 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !138
  %keyFound122 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr121, i32 0, i32 6, !dbg !138
  %359 = load i1, i1* %keyFound122, !dbg !138
  %360 = icmp eq i1 %359, false, !dbg !138
  %361 = load i1, i1* @GlobalAssertValue, !dbg !138
  %362 = and i1 %360, %361, !dbg !138
  store i1 %362, i1* @GlobalAssertValue, !dbg !138
  %363 = load i1, i1* %keyFound122, !dbg !138
  %364 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %363), !dbg !138
  store [1 x i8] %364, [1 x i8]* %91, !dbg !138
  %365 = load [1 x i8], [1 x i8]* %91, !dbg !138
  store [1 x i8] %365, [1 x i8]* %89, !dbg !138
  %366 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 false), !dbg !138
  store [1 x i8] %366, [1 x i8]* %92, !dbg !138
  %367 = load [1 x i8], [1 x i8]* %92, !dbg !138
  store [1 x i8] %367, [1 x i8]* %90, !dbg !138
  %368 = bitcast [1 x i8]* %89 to i8*, !dbg !138
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %94, !dbg !138
  %"$array_ptr123" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %94, i32 0, i32 0, !dbg !138
  store i8* %368, i8** %"$array_ptr123", !dbg !138
  %"$bounds124" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %94, i32 0, i32 2, !dbg !138
  %369 = bitcast [1 x %"$ax.ArrayBounds"]* %93 to %"$ax.ArrayBounds"*, !dbg !138
  store %"$ax.ArrayBounds"* %369, %"$ax.ArrayBounds"** %"$bounds124", !dbg !138
  %370 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %94, !dbg !138
  %371 = bitcast [1 x i8]* %90 to i8*, !dbg !138
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %96, !dbg !138
  %"$array_ptr125" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %96, i32 0, i32 0, !dbg !138
  store i8* %371, i8** %"$array_ptr125", !dbg !138
  %"$bounds126" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %96, i32 0, i32 2, !dbg !138
  %372 = bitcast [1 x %"$ax.ArrayBounds"]* %95 to %"$ax.ArrayBounds"*, !dbg !138
  store %"$ax.ArrayBounds"* %372, %"$ax.ArrayBounds"** %"$bounds126", !dbg !138
  %373 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %96, !dbg !138
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %360, i16 12, i8 1, i8 1, %"$ax.ArrayWithBound" %370, %"$ax.ArrayWithBound" %373, i16 1), !dbg !138
  %374 = load i16, i16* %intValue, !dbg !139
  %375 = icmp eq i16 %374, 0, !dbg !139
  %376 = load i1, i1* @GlobalAssertValue, !dbg !139
  %377 = and i1 %375, %376, !dbg !139
  store i1 %377, i1* @GlobalAssertValue, !dbg !139
  %378 = load i16, i16* %intValue, !dbg !139
  %379 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %378), !dbg !139
  store [2 x i8] %379, [2 x i8]* %99, !dbg !139
  %380 = load [2 x i8], [2 x i8]* %99, !dbg !139
  store [2 x i8] %380, [2 x i8]* %97, !dbg !139
  %381 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 0), !dbg !139
  store [2 x i8] %381, [2 x i8]* %100, !dbg !139
  %382 = load [2 x i8], [2 x i8]* %100, !dbg !139
  store [2 x i8] %382, [2 x i8]* %98, !dbg !139
  %383 = bitcast [2 x i8]* %97 to i8*, !dbg !139
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %102, !dbg !139
  %"$array_ptr127" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %102, i32 0, i32 0, !dbg !139
  store i8* %383, i8** %"$array_ptr127", !dbg !139
  %"$bounds128" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %102, i32 0, i32 2, !dbg !139
  %384 = bitcast [1 x %"$ax.ArrayBounds"]* %101 to %"$ax.ArrayBounds"*, !dbg !139
  store %"$ax.ArrayBounds"* %384, %"$ax.ArrayBounds"** %"$bounds128", !dbg !139
  %385 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %102, !dbg !139
  %386 = bitcast [2 x i8]* %98 to i8*, !dbg !139
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %104, !dbg !139
  %"$array_ptr129" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %104, i32 0, i32 0, !dbg !139
  store i8* %386, i8** %"$array_ptr129", !dbg !139
  %"$bounds130" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %104, i32 0, i32 2, !dbg !139
  %387 = bitcast [1 x %"$ax.ArrayBounds"]* %103 to %"$ax.ArrayBounds"*, !dbg !139
  store %"$ax.ArrayBounds"* %387, %"$ax.ArrayBounds"** %"$bounds130", !dbg !139
  %388 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %104, !dbg !139
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %375, i16 13, i8 1, i8 3, %"$ax.ArrayWithBound" %385, %"$ax.ArrayWithBound" %388, i16 2), !dbg !139
  ret void, !dbg !140
}

define void @"UsingDeserializer.GetValue_ARRAY$I@R@UsingDeserializer@this"(%UsingDeserializer* %this) !dbg !141 {
Entry:
  %this.addr = alloca %UsingDeserializer*
  %stringValue = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %UsingDeserializer** %this.addr, metadata !142, metadata !DIExpression()), !dbg !143
  call void @llvm.dbg.declare(metadata %STRING.0* %stringValue, metadata !144, metadata !DIExpression()), !dbg !145
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 999, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %3
  %4 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %4
  %5 = alloca [1 x i8]
  %6 = alloca [1 x i8]
  %7 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %7
  %8 = alloca %"$ax.ArrayWithBound"
  %9 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %9
  %10 = alloca %"$ax.ArrayWithBound"
  store %UsingDeserializer* %this, %UsingDeserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %stringValue
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !146
  %JSON_Entry = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr, i32 0, i32 3, !dbg !146
  %11 = bitcast %STRING.0* %JSON_Entry to i8*, !dbg !146
  call void @"$ax.AssignST_String"(i8* %11, i8* getelementptr inbounds (%"STRING[27]", %"STRING[27]"* @"$cStr.14", i32 0, i32 0)), !dbg !146
  %auto_deref_this.addr1 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !147
  %JSON_Entry2 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr1, i32 0, i32 3, !dbg !147
  %auto_deref_this.addr3 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !147
  %buffer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr3, i32 0, i32 2, !dbg !147
  %12 = bitcast %STRING.0* %JSON_Entry2 to i8*, !dbg !147
  %13 = bitcast [1000 x i8]* %buffer to i8*, !dbg !147
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1, !dbg !147
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0, !dbg !147
  store i8* %13, i8** %"$array_ptr", !dbg !147
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2, !dbg !147
  %14 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*, !dbg !147
  store %"$ax.ArrayBounds"* %14, %"$ax.ArrayBounds"** %"$bounds", !dbg !147
  %15 = call i32 @"Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr"(i8* %12, %"$ax.ArrayWithBound"* %1), !dbg !147
  %auto_deref_this.addr4 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !147
  %len = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr4, i32 0, i32 5, !dbg !147
  store i32 %15, i32* %len, !dbg !147
  %auto_deref_this.addr5 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !148
  %deserializer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr5, i32 0, i32 1, !dbg !148
  %auto_deref_this.addr6 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !148
  %buffer7 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr6, i32 0, i32 2, !dbg !148
  %16 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer, i32 0, i32 0, !dbg !148
  %17 = load i8*, i8** %16, !dbg !148
  %18 = bitcast i8* %17 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !148
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %18, i32 0, i32 4, !dbg !148
  %19 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable", i32 0, i32 0, !dbg !148
  %20 = load i8*, i8** %19, !dbg !148
  %21 = bitcast i8* %20 to void (%Simatic.Ax.Json.Deserializer*, [1000 x i8]*)*, !dbg !148
  call void %21(%Simatic.Ax.Json.Deserializer* %deserializer, [1000 x i8]* %buffer7), !dbg !148
  %auto_deref_this.addr8 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !149
  %key = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr8, i32 0, i32 4, !dbg !149
  %22 = bitcast %STRING.0* %key to i8*, !dbg !149
  call void @"$ax.AssignST_String"(i8* %22, i8* getelementptr inbounds (%"STRING[8]", %"STRING[8]"* @"$cStr.15", i32 0, i32 0)), !dbg !149
  %auto_deref_this.addr9 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !150
  %deserializer10 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr9, i32 0, i32 1, !dbg !150
  %auto_deref_this.addr11 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !150
  %key12 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr11, i32 0, i32 4, !dbg !150
  %23 = bitcast %STRING.0* %2 to i8*, !dbg !150
  %24 = bitcast %STRING.0* %stringValue to i8*, !dbg !150
  call void @"$ax.AssignST_String"(i8* %23, i8* %24), !dbg !150
  %25 = bitcast %STRING.0* %key12 to i8*, !dbg !150
  %26 = bitcast %STRING.0* %2 to i8*, !dbg !150
  %27 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer10, i32 0, i32 0, !dbg !150
  %28 = load i8*, i8** %27, !dbg !150
  %29 = bitcast i8* %28 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !150
  %"$vTable13" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %29, i32 0, i32 4, !dbg !150
  %30 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable13", i32 0, i32 5, !dbg !150
  %31 = load i8*, i8** %30, !dbg !150
  %32 = bitcast i8* %31 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)*, !dbg !150
  %33 = call i1 %32(%Simatic.Ax.Json.Deserializer* %deserializer10, i8* %25, i8* %26), !dbg !150
  %34 = bitcast %STRING.0* %stringValue to i8*, !dbg !150
  %35 = bitcast %STRING.0* %2 to i8*, !dbg !150
  call void @"$ax.AssignST_String"(i8* %34, i8* %35), !dbg !150
  %auto_deref_this.addr14 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !150
  %keyFound = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr14, i32 0, i32 6, !dbg !150
  store i1 %33, i1* %keyFound, !dbg !150
  %auto_deref_this.addr15 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !151
  %keyFound16 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr15, i32 0, i32 6, !dbg !151
  %36 = load i1, i1* %keyFound16, !dbg !151
  %37 = icmp eq i1 %36, true, !dbg !151
  %38 = load i1, i1* @GlobalAssertValue, !dbg !151
  %39 = and i1 %37, %38, !dbg !151
  store i1 %39, i1* @GlobalAssertValue, !dbg !151
  %40 = load i1, i1* %keyFound16, !dbg !151
  %41 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %40), !dbg !151
  store [1 x i8] %41, [1 x i8]* %5, !dbg !151
  %42 = load [1 x i8], [1 x i8]* %5, !dbg !151
  store [1 x i8] %42, [1 x i8]* %3, !dbg !151
  %43 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !151
  store [1 x i8] %43, [1 x i8]* %6, !dbg !151
  %44 = load [1 x i8], [1 x i8]* %6, !dbg !151
  store [1 x i8] %44, [1 x i8]* %4, !dbg !151
  %45 = bitcast [1 x i8]* %3 to i8*, !dbg !151
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %8, !dbg !151
  %"$array_ptr17" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 0, !dbg !151
  store i8* %45, i8** %"$array_ptr17", !dbg !151
  %"$bounds18" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 2, !dbg !151
  %46 = bitcast [1 x %"$ax.ArrayBounds"]* %7 to %"$ax.ArrayBounds"*, !dbg !151
  store %"$ax.ArrayBounds"* %46, %"$ax.ArrayBounds"** %"$bounds18", !dbg !151
  %47 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, !dbg !151
  %48 = bitcast [1 x i8]* %4 to i8*, !dbg !151
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %10, !dbg !151
  %"$array_ptr19" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 0, !dbg !151
  store i8* %48, i8** %"$array_ptr19", !dbg !151
  %"$bounds20" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 2, !dbg !151
  %49 = bitcast [1 x %"$ax.ArrayBounds"]* %9 to %"$ax.ArrayBounds"*, !dbg !151
  store %"$ax.ArrayBounds"* %49, %"$ax.ArrayBounds"** %"$bounds20", !dbg !151
  %50 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, !dbg !151
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %37, i16 14, i8 1, i8 1, %"$ax.ArrayWithBound" %47, %"$ax.ArrayWithBound" %50, i16 1), !dbg !151
  %51 = bitcast %STRING.0* %stringValue to i8*, !dbg !152
  %52 = call i32 @"$ax.CmpST_String"(i8* %51, i8* getelementptr inbounds (%"STRING[12]", %"STRING[12]"* @"$cStr.16", i32 0, i32 0)), !dbg !152
  %53 = icmp eq i32 %52, 0, !dbg !152
  %54 = load i1, i1* @GlobalAssertValue, !dbg !152
  %55 = and i1 %53, %54, !dbg !152
  store i1 %55, i1* @GlobalAssertValue, !dbg !152
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %53, i16 15, i8 1, i8 0), !dbg !152
  ret void, !dbg !153
}

define void @"UsingDeserializer.GetValue_Nested$I@R@UsingDeserializer@this"(%UsingDeserializer* %this) !dbg !154 {
Entry:
  %this.addr = alloca %UsingDeserializer*
  %stringValue = alloca %STRING.0
  %keyArray = alloca [2 x %STRING.0]
  call void @llvm.dbg.declare(metadata %UsingDeserializer** %this.addr, metadata !155, metadata !DIExpression()), !dbg !156
  call void @llvm.dbg.declare(metadata %STRING.0* %stringValue, metadata !157, metadata !DIExpression()), !dbg !158
  call void @llvm.dbg.declare(metadata [2 x %STRING.0]* %keyArray, metadata !159, metadata !DIExpression()), !dbg !164
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 999, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %3
  %4 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %4
  %5 = alloca [1 x i8]
  %6 = alloca [1 x i8]
  %7 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %7
  %8 = alloca %"$ax.ArrayWithBound"
  %9 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %9
  %10 = alloca %"$ax.ArrayWithBound"
  %11 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %11
  %12 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %12
  %13 = alloca %"$ax.ArrayWithBound"
  %14 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %14
  %15 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %15
  %16 = alloca [1 x i8]
  %17 = alloca [1 x i8]
  %18 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %18
  %19 = alloca %"$ax.ArrayWithBound"
  %20 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %20
  %21 = alloca %"$ax.ArrayWithBound"
  store %UsingDeserializer* %this, %UsingDeserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %stringValue
  store [2 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [2 x %STRING.0]* %keyArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !165
  %JSON_Entry = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr, i32 0, i32 3, !dbg !165
  %22 = bitcast %STRING.0* %JSON_Entry to i8*, !dbg !165
  call void @"$ax.AssignST_String"(i8* %22, i8* getelementptr inbounds (%"STRING[60]", %"STRING[60]"* @"$cStr.17", i32 0, i32 0)), !dbg !165
  %auto_deref_this.addr1 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !166
  %JSON_Entry2 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr1, i32 0, i32 3, !dbg !166
  %auto_deref_this.addr3 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !166
  %buffer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr3, i32 0, i32 2, !dbg !166
  %23 = bitcast %STRING.0* %JSON_Entry2 to i8*, !dbg !166
  %24 = bitcast [1000 x i8]* %buffer to i8*, !dbg !166
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1, !dbg !166
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0, !dbg !166
  store i8* %24, i8** %"$array_ptr", !dbg !166
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2, !dbg !166
  %25 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*, !dbg !166
  store %"$ax.ArrayBounds"* %25, %"$ax.ArrayBounds"** %"$bounds", !dbg !166
  %26 = call i32 @"Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr"(i8* %23, %"$ax.ArrayWithBound"* %1), !dbg !166
  %auto_deref_this.addr4 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !166
  %len = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr4, i32 0, i32 5, !dbg !166
  store i32 %26, i32* %len, !dbg !166
  %auto_deref_this.addr5 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !167
  %deserializer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr5, i32 0, i32 1, !dbg !167
  %auto_deref_this.addr6 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !167
  %buffer7 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr6, i32 0, i32 2, !dbg !167
  %27 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer, i32 0, i32 0, !dbg !167
  %28 = load i8*, i8** %27, !dbg !167
  %29 = bitcast i8* %28 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !167
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %29, i32 0, i32 4, !dbg !167
  %30 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable", i32 0, i32 0, !dbg !167
  %31 = load i8*, i8** %30, !dbg !167
  %32 = bitcast i8* %31 to void (%Simatic.Ax.Json.Deserializer*, [1000 x i8]*)*, !dbg !167
  call void %32(%Simatic.Ax.Json.Deserializer* %deserializer, [1000 x i8]* %buffer7), !dbg !167
  %auto_deref_this.addr8 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !168
  %key = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr8, i32 0, i32 4, !dbg !168
  %33 = bitcast %STRING.0* %key to i8*, !dbg !168
  call void @"$ax.AssignST_String"(i8* %33, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.18", i32 0, i32 0)), !dbg !168
  %auto_deref_this.addr9 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !169
  %deserializer10 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr9, i32 0, i32 1, !dbg !169
  %auto_deref_this.addr11 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !169
  %key12 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr11, i32 0, i32 4, !dbg !169
  %34 = bitcast %STRING.0* %2 to i8*, !dbg !169
  %35 = bitcast %STRING.0* %stringValue to i8*, !dbg !169
  call void @"$ax.AssignST_String"(i8* %34, i8* %35), !dbg !169
  %36 = bitcast %STRING.0* %key12 to i8*, !dbg !169
  %37 = bitcast %STRING.0* %2 to i8*, !dbg !169
  %38 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer10, i32 0, i32 0, !dbg !169
  %39 = load i8*, i8** %38, !dbg !169
  %40 = bitcast i8* %39 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !169
  %"$vTable13" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %40, i32 0, i32 4, !dbg !169
  %41 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable13", i32 0, i32 5, !dbg !169
  %42 = load i8*, i8** %41, !dbg !169
  %43 = bitcast i8* %42 to i1 (%Simatic.Ax.Json.Deserializer*, i8*, i8*)*, !dbg !169
  %44 = call i1 %43(%Simatic.Ax.Json.Deserializer* %deserializer10, i8* %36, i8* %37), !dbg !169
  %45 = bitcast %STRING.0* %stringValue to i8*, !dbg !169
  %46 = bitcast %STRING.0* %2 to i8*, !dbg !169
  call void @"$ax.AssignST_String"(i8* %45, i8* %46), !dbg !169
  %auto_deref_this.addr14 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !169
  %keyFound = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr14, i32 0, i32 6, !dbg !169
  store i1 %44, i1* %keyFound, !dbg !169
  %auto_deref_this.addr15 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !170
  %keyFound16 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr15, i32 0, i32 6, !dbg !170
  %47 = load i1, i1* %keyFound16, !dbg !170
  %48 = icmp eq i1 %47, true, !dbg !170
  %49 = load i1, i1* @GlobalAssertValue, !dbg !170
  %50 = and i1 %48, %49, !dbg !170
  store i1 %50, i1* @GlobalAssertValue, !dbg !170
  %51 = load i1, i1* %keyFound16, !dbg !170
  %52 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %51), !dbg !170
  store [1 x i8] %52, [1 x i8]* %5, !dbg !170
  %53 = load [1 x i8], [1 x i8]* %5, !dbg !170
  store [1 x i8] %53, [1 x i8]* %3, !dbg !170
  %54 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !170
  store [1 x i8] %54, [1 x i8]* %6, !dbg !170
  %55 = load [1 x i8], [1 x i8]* %6, !dbg !170
  store [1 x i8] %55, [1 x i8]* %4, !dbg !170
  %56 = bitcast [1 x i8]* %3 to i8*, !dbg !170
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %8, !dbg !170
  %"$array_ptr17" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 0, !dbg !170
  store i8* %56, i8** %"$array_ptr17", !dbg !170
  %"$bounds18" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, i32 0, i32 2, !dbg !170
  %57 = bitcast [1 x %"$ax.ArrayBounds"]* %7 to %"$ax.ArrayBounds"*, !dbg !170
  store %"$ax.ArrayBounds"* %57, %"$ax.ArrayBounds"** %"$bounds18", !dbg !170
  %58 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %8, !dbg !170
  %59 = bitcast [1 x i8]* %4 to i8*, !dbg !170
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %10, !dbg !170
  %"$array_ptr19" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 0, !dbg !170
  store i8* %59, i8** %"$array_ptr19", !dbg !170
  %"$bounds20" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 2, !dbg !170
  %60 = bitcast [1 x %"$ax.ArrayBounds"]* %9 to %"$ax.ArrayBounds"*, !dbg !170
  store %"$ax.ArrayBounds"* %60, %"$ax.ArrayBounds"** %"$bounds20", !dbg !170
  %61 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, !dbg !170
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %48, i16 16, i8 1, i8 1, %"$ax.ArrayWithBound" %58, %"$ax.ArrayWithBound" %61, i16 1), !dbg !170
  %62 = bitcast %STRING.0* %stringValue to i8*, !dbg !171
  %63 = call i32 @"$ax.CmpST_String"(i8* %62, i8* getelementptr inbounds (%"STRING[49]", %"STRING[49]"* @"$cStr.19", i32 0, i32 0)), !dbg !171
  %64 = icmp eq i32 %63, 0, !dbg !171
  %65 = load i1, i1* @GlobalAssertValue, !dbg !171
  %66 = and i1 %64, %65, !dbg !171
  store i1 %66, i1* @GlobalAssertValue, !dbg !171
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %64, i16 17, i8 1, i8 0), !dbg !171
  %67 = getelementptr inbounds [2 x %STRING.0], [2 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !172
  %68 = bitcast %STRING.0* %67 to i8*, !dbg !172
  call void @"$ax.AssignST_String"(i8* %68, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.20", i32 0, i32 0)), !dbg !172
  %69 = getelementptr inbounds [2 x %STRING.0], [2 x %STRING.0]* %keyArray, i32 0, i32 1, !dbg !173
  %70 = bitcast %STRING.0* %69 to i8*, !dbg !173
  call void @"$ax.AssignST_String"(i8* %70, i8* getelementptr inbounds (%"STRING[10]", %"STRING[10]"* @"$cStr.21", i32 0, i32 0)), !dbg !173
  %auto_deref_this.addr21 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !174
  %deserializer22 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr21, i32 0, i32 1, !dbg !174
  %71 = bitcast %STRING.0* %11 to i8*, !dbg !174
  %72 = bitcast %STRING.0* %stringValue to i8*, !dbg !174
  call void @"$ax.AssignST_String"(i8* %71, i8* %72), !dbg !174
  %73 = bitcast [2 x %STRING.0]* %keyArray to i8*, !dbg !174
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %13, !dbg !174
  %"$array_ptr23" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %13, i32 0, i32 0, !dbg !174
  store i8* %73, i8** %"$array_ptr23", !dbg !174
  %"$bounds24" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %13, i32 0, i32 2, !dbg !174
  %74 = bitcast [1 x %"$ax.ArrayBounds"]* %12 to %"$ax.ArrayBounds"*, !dbg !174
  store %"$ax.ArrayBounds"* %74, %"$ax.ArrayBounds"** %"$bounds24", !dbg !174
  %75 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %13, !dbg !174
  %76 = bitcast %STRING.0* %11 to i8*, !dbg !174
  %77 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer22, i32 0, i32 0, !dbg !174
  %78 = load i8*, i8** %77, !dbg !174
  %79 = bitcast i8* %78 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !174
  %"$vTable25" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %79, i32 0, i32 4, !dbg !174
  %80 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable25", i32 0, i32 14, !dbg !174
  %81 = load i8*, i8** %80, !dbg !174
  %82 = bitcast i8* %81 to i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i8*)*, !dbg !174
  %83 = call i1 %82(%Simatic.Ax.Json.Deserializer* %deserializer22, %"$ax.ArrayWithBound" %75, i8* %76), !dbg !174
  %84 = bitcast %STRING.0* %stringValue to i8*, !dbg !174
  %85 = bitcast %STRING.0* %11 to i8*, !dbg !174
  call void @"$ax.AssignST_String"(i8* %84, i8* %85), !dbg !174
  %auto_deref_this.addr26 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !174
  %keyFound27 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr26, i32 0, i32 6, !dbg !174
  store i1 %83, i1* %keyFound27, !dbg !174
  %auto_deref_this.addr28 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !175
  %keyFound29 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr28, i32 0, i32 6, !dbg !175
  %86 = load i1, i1* %keyFound29, !dbg !175
  %87 = icmp eq i1 %86, true, !dbg !175
  %88 = load i1, i1* @GlobalAssertValue, !dbg !175
  %89 = and i1 %87, %88, !dbg !175
  store i1 %89, i1* @GlobalAssertValue, !dbg !175
  %90 = load i1, i1* %keyFound29, !dbg !175
  %91 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %90), !dbg !175
  store [1 x i8] %91, [1 x i8]* %16, !dbg !175
  %92 = load [1 x i8], [1 x i8]* %16, !dbg !175
  store [1 x i8] %92, [1 x i8]* %14, !dbg !175
  %93 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !175
  store [1 x i8] %93, [1 x i8]* %17, !dbg !175
  %94 = load [1 x i8], [1 x i8]* %17, !dbg !175
  store [1 x i8] %94, [1 x i8]* %15, !dbg !175
  %95 = bitcast [1 x i8]* %14 to i8*, !dbg !175
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %19, !dbg !175
  %"$array_ptr30" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 0, !dbg !175
  store i8* %95, i8** %"$array_ptr30", !dbg !175
  %"$bounds31" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 2, !dbg !175
  %96 = bitcast [1 x %"$ax.ArrayBounds"]* %18 to %"$ax.ArrayBounds"*, !dbg !175
  store %"$ax.ArrayBounds"* %96, %"$ax.ArrayBounds"** %"$bounds31", !dbg !175
  %97 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, !dbg !175
  %98 = bitcast [1 x i8]* %15 to i8*, !dbg !175
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %21, !dbg !175
  %"$array_ptr32" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %21, i32 0, i32 0, !dbg !175
  store i8* %98, i8** %"$array_ptr32", !dbg !175
  %"$bounds33" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %21, i32 0, i32 2, !dbg !175
  %99 = bitcast [1 x %"$ax.ArrayBounds"]* %20 to %"$ax.ArrayBounds"*, !dbg !175
  store %"$ax.ArrayBounds"* %99, %"$ax.ArrayBounds"** %"$bounds33", !dbg !175
  %100 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %21, !dbg !175
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %87, i16 18, i8 1, i8 1, %"$ax.ArrayWithBound" %97, %"$ax.ArrayWithBound" %100, i16 1), !dbg !175
  %101 = bitcast %STRING.0* %stringValue to i8*, !dbg !176
  %102 = call i32 @"$ax.CmpST_String"(i8* %101, i8* getelementptr inbounds (%"STRING[12]", %"STRING[12]"* @"$cStr.22", i32 0, i32 0)), !dbg !176
  %103 = icmp eq i32 %102, 0, !dbg !176
  %104 = load i1, i1* @GlobalAssertValue, !dbg !176
  %105 = and i1 %103, %104, !dbg !176
  store i1 %105, i1* @GlobalAssertValue, !dbg !176
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %103, i16 19, i8 1, i8 0), !dbg !176
  ret void, !dbg !177
}

define void @"UsingDeserializer.GetValue_Nested_in_Nested$I@R@UsingDeserializer@this"(%UsingDeserializer* %this) !dbg !178 {
Entry:
  %this.addr = alloca %UsingDeserializer*
  %stringValue = alloca %STRING.0
  %keyArray = alloca [3 x %STRING.0]
  %intValue = alloca i16
  call void @llvm.dbg.declare(metadata %UsingDeserializer** %this.addr, metadata !179, metadata !DIExpression()), !dbg !180
  call void @llvm.dbg.declare(metadata %STRING.0* %stringValue, metadata !181, metadata !DIExpression()), !dbg !182
  call void @llvm.dbg.declare(metadata [3 x %STRING.0]* %keyArray, metadata !183, metadata !DIExpression()), !dbg !188
  call void @llvm.dbg.declare(metadata i16* %intValue, metadata !189, metadata !DIExpression()), !dbg !190
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 999, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca i16
  store i16 0, i16* %2
  %3 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 2, i32 1 }], [1 x %"$ax.ArrayBounds"]* %3
  %4 = alloca %"$ax.ArrayWithBound"
  %5 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %5
  %6 = alloca [1 x i8]
  store [1 x i8] zeroinitializer, [1 x i8]* %6
  %7 = alloca [1 x i8]
  %8 = alloca [1 x i8]
  %9 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %9
  %10 = alloca %"$ax.ArrayWithBound"
  %11 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %11
  %12 = alloca %"$ax.ArrayWithBound"
  %13 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %13
  %14 = alloca [2 x i8]
  store [2 x i8] zeroinitializer, [2 x i8]* %14
  %15 = alloca [2 x i8]
  %16 = alloca [2 x i8]
  %17 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %17
  %18 = alloca %"$ax.ArrayWithBound"
  %19 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %19
  %20 = alloca %"$ax.ArrayWithBound"
  store %UsingDeserializer* %this, %UsingDeserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %stringValue
  store [3 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [3 x %STRING.0]* %keyArray
  store i16 0, i16* %intValue
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !191
  %JSON_Entry = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr, i32 0, i32 3, !dbg !191
  %21 = bitcast %STRING.0* %JSON_Entry to i8*, !dbg !191
  call void @"$ax.AssignST_String"(i8* %21, i8* getelementptr inbounds (%"STRING[85]", %"STRING[85]"* @"$cStr.23", i32 0, i32 0)), !dbg !191
  %auto_deref_this.addr1 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !192
  %JSON_Entry2 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr1, i32 0, i32 3, !dbg !192
  %auto_deref_this.addr3 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !192
  %buffer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr3, i32 0, i32 2, !dbg !192
  %22 = bitcast %STRING.0* %JSON_Entry2 to i8*, !dbg !192
  %23 = bitcast [1000 x i8]* %buffer to i8*, !dbg !192
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1, !dbg !192
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0, !dbg !192
  store i8* %23, i8** %"$array_ptr", !dbg !192
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2, !dbg !192
  %24 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*, !dbg !192
  store %"$ax.ArrayBounds"* %24, %"$ax.ArrayBounds"** %"$bounds", !dbg !192
  %25 = call i32 @"Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr"(i8* %22, %"$ax.ArrayWithBound"* %1), !dbg !192
  %auto_deref_this.addr4 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !192
  %len = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr4, i32 0, i32 5, !dbg !192
  store i32 %25, i32* %len, !dbg !192
  %auto_deref_this.addr5 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !193
  %deserializer = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr5, i32 0, i32 1, !dbg !193
  %auto_deref_this.addr6 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !193
  %buffer7 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr6, i32 0, i32 2, !dbg !193
  %26 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer, i32 0, i32 0, !dbg !193
  %27 = load i8*, i8** %26, !dbg !193
  %28 = bitcast i8* %27 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !193
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %28, i32 0, i32 4, !dbg !193
  %29 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable", i32 0, i32 0, !dbg !193
  %30 = load i8*, i8** %29, !dbg !193
  %31 = bitcast i8* %30 to void (%Simatic.Ax.Json.Deserializer*, [1000 x i8]*)*, !dbg !193
  call void %31(%Simatic.Ax.Json.Deserializer* %deserializer, [1000 x i8]* %buffer7), !dbg !193
  %32 = getelementptr inbounds [3 x %STRING.0], [3 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !194
  %33 = bitcast %STRING.0* %32 to i8*, !dbg !194
  call void @"$ax.AssignST_String"(i8* %33, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.24", i32 0, i32 0)), !dbg !194
  %34 = getelementptr inbounds [3 x %STRING.0], [3 x %STRING.0]* %keyArray, i32 0, i32 1, !dbg !195
  %35 = bitcast %STRING.0* %34 to i8*, !dbg !195
  call void @"$ax.AssignST_String"(i8* %35, i8* getelementptr inbounds (%"STRING[10]", %"STRING[10]"* @"$cStr.25", i32 0, i32 0)), !dbg !195
  %36 = getelementptr inbounds [3 x %STRING.0], [3 x %STRING.0]* %keyArray, i32 0, i32 2, !dbg !196
  %37 = bitcast %STRING.0* %36 to i8*, !dbg !196
  call void @"$ax.AssignST_String"(i8* %37, i8* getelementptr inbounds (%"STRING[17]", %"STRING[17]"* @"$cStr.26", i32 0, i32 0)), !dbg !196
  %auto_deref_this.addr8 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !197
  %deserializer9 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr8, i32 0, i32 1, !dbg !197
  %38 = load i16, i16* %intValue, !dbg !197
  store i16 %38, i16* %2, !dbg !197
  %39 = bitcast [3 x %STRING.0]* %keyArray to i8*, !dbg !197
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %4, !dbg !197
  %"$array_ptr10" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, i32 0, i32 0, !dbg !197
  store i8* %39, i8** %"$array_ptr10", !dbg !197
  %"$bounds11" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, i32 0, i32 2, !dbg !197
  %40 = bitcast [1 x %"$ax.ArrayBounds"]* %3 to %"$ax.ArrayBounds"*, !dbg !197
  store %"$ax.ArrayBounds"* %40, %"$ax.ArrayBounds"** %"$bounds11", !dbg !197
  %41 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, !dbg !197
  %42 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %deserializer9, i32 0, i32 0, !dbg !197
  %43 = load i8*, i8** %42, !dbg !197
  %44 = bitcast i8* %43 to %"$CD_Simatic.Ax.Json.Deserializer"*, !dbg !197
  %"$vTable12" = getelementptr inbounds %"$CD_Simatic.Ax.Json.Deserializer", %"$CD_Simatic.Ax.Json.Deserializer"* %44, i32 0, i32 4, !dbg !197
  %45 = getelementptr inbounds [19 x i8*], [19 x i8*]* %"$vTable12", i32 0, i32 11, !dbg !197
  %46 = load i8*, i8** %45, !dbg !197
  %47 = bitcast i8* %46 to i1 (%Simatic.Ax.Json.Deserializer*, %"$ax.ArrayWithBound", i16*)*, !dbg !197
  %48 = call i1 %47(%Simatic.Ax.Json.Deserializer* %deserializer9, %"$ax.ArrayWithBound" %41, i16* %2), !dbg !197
  %49 = load i16, i16* %2, !dbg !197
  store i16 %49, i16* %intValue, !dbg !197
  %auto_deref_this.addr13 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !197
  %keyFound = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr13, i32 0, i32 6, !dbg !197
  store i1 %48, i1* %keyFound, !dbg !197
  %auto_deref_this.addr14 = load %UsingDeserializer*, %UsingDeserializer** %this.addr, !dbg !198
  %keyFound15 = getelementptr inbounds %UsingDeserializer, %UsingDeserializer* %auto_deref_this.addr14, i32 0, i32 6, !dbg !198
  %50 = load i1, i1* %keyFound15, !dbg !198
  %51 = icmp eq i1 %50, true, !dbg !198
  %52 = load i1, i1* @GlobalAssertValue, !dbg !198
  %53 = and i1 %51, %52, !dbg !198
  store i1 %53, i1* @GlobalAssertValue, !dbg !198
  %54 = load i1, i1* %keyFound15, !dbg !198
  %55 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %54), !dbg !198
  store [1 x i8] %55, [1 x i8]* %7, !dbg !198
  %56 = load [1 x i8], [1 x i8]* %7, !dbg !198
  store [1 x i8] %56, [1 x i8]* %5, !dbg !198
  %57 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 true), !dbg !198
  store [1 x i8] %57, [1 x i8]* %8, !dbg !198
  %58 = load [1 x i8], [1 x i8]* %8, !dbg !198
  store [1 x i8] %58, [1 x i8]* %6, !dbg !198
  %59 = bitcast [1 x i8]* %5 to i8*, !dbg !198
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %10, !dbg !198
  %"$array_ptr16" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 0, !dbg !198
  store i8* %59, i8** %"$array_ptr16", !dbg !198
  %"$bounds17" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, i32 0, i32 2, !dbg !198
  %60 = bitcast [1 x %"$ax.ArrayBounds"]* %9 to %"$ax.ArrayBounds"*, !dbg !198
  store %"$ax.ArrayBounds"* %60, %"$ax.ArrayBounds"** %"$bounds17", !dbg !198
  %61 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %10, !dbg !198
  %62 = bitcast [1 x i8]* %6 to i8*, !dbg !198
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %12, !dbg !198
  %"$array_ptr18" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %12, i32 0, i32 0, !dbg !198
  store i8* %62, i8** %"$array_ptr18", !dbg !198
  %"$bounds19" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %12, i32 0, i32 2, !dbg !198
  %63 = bitcast [1 x %"$ax.ArrayBounds"]* %11 to %"$ax.ArrayBounds"*, !dbg !198
  store %"$ax.ArrayBounds"* %63, %"$ax.ArrayBounds"** %"$bounds19", !dbg !198
  %64 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %12, !dbg !198
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %51, i16 20, i8 1, i8 1, %"$ax.ArrayWithBound" %61, %"$ax.ArrayWithBound" %64, i16 1), !dbg !198
  %65 = load i16, i16* %intValue, !dbg !199
  %66 = icmp eq i16 %65, 1234, !dbg !199
  %67 = load i1, i1* @GlobalAssertValue, !dbg !199
  %68 = and i1 %66, %67, !dbg !199
  store i1 %68, i1* @GlobalAssertValue, !dbg !199
  %69 = load i16, i16* %intValue, !dbg !199
  %70 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %69), !dbg !199
  store [2 x i8] %70, [2 x i8]* %15, !dbg !199
  %71 = load [2 x i8], [2 x i8]* %15, !dbg !199
  store [2 x i8] %71, [2 x i8]* %13, !dbg !199
  %72 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 1234), !dbg !199
  store [2 x i8] %72, [2 x i8]* %16, !dbg !199
  %73 = load [2 x i8], [2 x i8]* %16, !dbg !199
  store [2 x i8] %73, [2 x i8]* %14, !dbg !199
  %74 = bitcast [2 x i8]* %13 to i8*, !dbg !199
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %18, !dbg !199
  %"$array_ptr20" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %18, i32 0, i32 0, !dbg !199
  store i8* %74, i8** %"$array_ptr20", !dbg !199
  %"$bounds21" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %18, i32 0, i32 2, !dbg !199
  %75 = bitcast [1 x %"$ax.ArrayBounds"]* %17 to %"$ax.ArrayBounds"*, !dbg !199
  store %"$ax.ArrayBounds"* %75, %"$ax.ArrayBounds"** %"$bounds21", !dbg !199
  %76 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %18, !dbg !199
  %77 = bitcast [2 x i8]* %14 to i8*, !dbg !199
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %20, !dbg !199
  %"$array_ptr22" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %20, i32 0, i32 0, !dbg !199
  store i8* %77, i8** %"$array_ptr22", !dbg !199
  %"$bounds23" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %20, i32 0, i32 2, !dbg !199
  %78 = bitcast [1 x %"$ax.ArrayBounds"]* %19 to %"$ax.ArrayBounds"*, !dbg !199
  store %"$ax.ArrayBounds"* %78, %"$ax.ArrayBounds"** %"$bounds23", !dbg !199
  %79 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %20, !dbg !199
  call void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %66, i16 21, i8 1, i8 3, %"$ax.ArrayWithBound" %76, %"$ax.ArrayWithBound" %79, i16 2), !dbg !199
  ret void, !dbg !200
}

define void @"Simatic.Ax.Json.Deserializer.SetBuffer$I@R@Simatic.Ax.Json.Deserializer@this?I@V@REF_TO ARRAY [0..999] OF CHAR@_buffer"(%Simatic.Ax.Json.Deserializer* %this, [1000 x i8]* %_buffer) !dbg !201 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %_buffer.addr = alloca [1000 x i8]*
  call void @llvm.dbg.declare(metadata [1000 x i8]** %_buffer.addr, metadata !205, metadata !DIExpression()), !dbg !206
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !207, metadata !DIExpression()), !dbg !208
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store [1000 x i8]* %_buffer, [1000 x i8]** %_buffer.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !209
  %buffer = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, i32 0, i32 1, !dbg !209
  %0 = load [1000 x i8]*, [1000 x i8]** %_buffer.addr, !dbg !209
  store [1000 x i8]* %0, [1000 x i8]** %buffer, !dbg !209
  ret void, !dbg !210
}

define i1 @"Simatic.Ax.Json.Deserializer.KeyIsInIndexSpan$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i16 %startIndex, i16 %endIndex) !dbg !211 {
Entry:
  %KeyIsInIndexSpan.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %startIndex.addr = alloca i16
  %endIndex.addr = alloca i16
  %keyIndex = alloca i16
  %loopIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !215, metadata !DIExpression()), !dbg !216
  call void @llvm.dbg.declare(metadata i16* %startIndex.addr, metadata !217, metadata !DIExpression()), !dbg !218
  call void @llvm.dbg.declare(metadata i16* %endIndex.addr, metadata !219, metadata !DIExpression()), !dbg !220
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !221, metadata !DIExpression()), !dbg !222
  call void @llvm.dbg.declare(metadata i16* %keyIndex, metadata !223, metadata !DIExpression()), !dbg !224
  call void @llvm.dbg.declare(metadata i16* %loopIndex, metadata !225, metadata !DIExpression()), !dbg !226
  call void @llvm.dbg.declare(metadata i1* %KeyIsInIndexSpan.ret, metadata !227, metadata !DIExpression()), !dbg !222
  %0 = alloca i16
  store i16 0, i16* %0
  store i1 false, i1* %KeyIsInIndexSpan.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %1 = bitcast %STRING.0* %key.addr to i8*, !dbg !222
  call void @"$ax.AssignST_String"(i8* %1, i8* %key), !dbg !222
  store i16 %startIndex, i16* %startIndex.addr
  store i16 %endIndex, i16* %endIndex.addr
  store i16 1, i16* %keyIndex
  store i16 0, i16* %loopIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i16, i16* %endIndex.addr, !dbg !228
  store i16 %2, i16* %0, !dbg !228
  %3 = load i16, i16* %startIndex.addr, !dbg !229
  store i16 %3, i16* %loopIndex, !dbg !229
  br label %bb4, !dbg !230

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !231

bb3:                                              ; preds = %bb2
  store i1 true, i1* %KeyIsInIndexSpan.ret, !dbg !232
  %4 = load i1, i1* %KeyIsInIndexSpan.ret, !dbg !233
  ret i1 %4, !dbg !233

bb4:                                              ; preds = %bb5, %bb1
  %5 = load i16, i16* %loopIndex, !dbg !230
  %6 = load i16, i16* %0, !dbg !230
  %7 = icmp sgt i16 %5, %6, !dbg !230
  br i1 %7, label %bb2, label %bb6, !dbg !230

bb5:                                              ; preds = %bb8
  %8 = load i16, i16* %loopIndex, !dbg !230
  %9 = add i16 %8, 1, !dbg !230
  store i16 %9, i16* %loopIndex, !dbg !230
  br label %bb4, !dbg !230

bb6:                                              ; preds = %bb4
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !234
  %buffer = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, i32 0, i32 1, !dbg !234
  %10 = load [1000 x i8]*, [1000 x i8]** %buffer, !dbg !234
  %11 = load i16, i16* %loopIndex, !dbg !234
  %12 = sext i16 %11 to i32, !dbg !234
  %13 = sub i32 %12, 0, !dbg !234
  %14 = getelementptr inbounds [1000 x i8], [1000 x i8]* %10, i32 0, i32 %13, !dbg !234
  %15 = load i16, i16* %keyIndex, !dbg !234
  %16 = trunc i16 %15 to i8, !dbg !234
  %17 = bitcast %STRING.0* %key.addr to i8*, !dbg !234
  %18 = call i8 @"$ax.GetAtST_String"(i8* %17, i8 %16), !dbg !234
  %19 = load i8, i8* %14, !dbg !234
  %20 = icmp eq i8 %19, %18, !dbg !234
  %21 = xor i1 %20, true, !dbg !234
  br i1 %21, label %bb9, label %bb7, !dbg !234

bb7:                                              ; preds = %bb10, %bb6
  br label %bb8, !dbg !235

bb8:                                              ; preds = %bb7
  %22 = load i16, i16* %keyIndex, !dbg !236
  %23 = add i16 %22, 1, !dbg !236
  store i16 %23, i16* %keyIndex, !dbg !236
  br label %bb5, !dbg !230

bb9:                                              ; preds = %bb6
  store i1 false, i1* %KeyIsInIndexSpan.ret, !dbg !237
  %24 = load i1, i1* %KeyIsInIndexSpan.ret, !dbg !238
  ret i1 %24, !dbg !238

bb10:                                             ; No predecessors!
  br label %bb7, !dbg !238
}

define %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %this, i16 %startIndex, i16 %endIndex) !dbg !239 {
Entry:
  %GetValueFromIndex.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %startIndex.addr = alloca i16
  %endIndex.addr = alloca i16
  %index = alloca i16
  %realStartIndex = alloca i16
  %realEndIndex = alloca i16
  %incrementBackwards = alloca i16
  call void @llvm.dbg.declare(metadata i16* %startIndex.addr, metadata !242, metadata !DIExpression()), !dbg !243
  call void @llvm.dbg.declare(metadata i16* %endIndex.addr, metadata !244, metadata !DIExpression()), !dbg !245
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !246, metadata !DIExpression()), !dbg !247
  call void @llvm.dbg.declare(metadata i16* %index, metadata !248, metadata !DIExpression()), !dbg !249
  call void @llvm.dbg.declare(metadata i16* %realStartIndex, metadata !250, metadata !DIExpression()), !dbg !251
  call void @llvm.dbg.declare(metadata i16* %realEndIndex, metadata !252, metadata !DIExpression()), !dbg !253
  call void @llvm.dbg.declare(metadata i16* %incrementBackwards, metadata !254, metadata !DIExpression()), !dbg !255
  call void @llvm.dbg.declare(metadata %STRING.0* %GetValueFromIndex.ret, metadata !256, metadata !DIExpression()), !dbg !247
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca i16
  store i16 0, i16* %2
  %3 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 999, i32 1 }], [1 x %"$ax.ArrayBounds"]* %3
  %4 = alloca %"$ax.ArrayWithBound"
  %5 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %GetValueFromIndex.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store i16 %startIndex, i16* %startIndex.addr
  store i16 %endIndex, i16* %endIndex.addr
  store i16 0, i16* %index
  store i16 0, i16* %realStartIndex
  store i16 0, i16* %realEndIndex
  store i16 -1, i16* %incrementBackwards
  br label %bb1

bb1:                                              ; preds = %Entry
  %6 = load i16, i16* %endIndex.addr, !dbg !257
  store i16 %6, i16* %0, !dbg !257
  %7 = load i16, i16* %startIndex.addr, !dbg !258
  store i16 %7, i16* %index, !dbg !258
  br label %bb4, !dbg !259

bb2:                                              ; preds = %bb9, %bb4
  br label %bb3, !dbg !260

bb3:                                              ; preds = %bb2
  %8 = load i16, i16* %incrementBackwards, !dbg !261
  store i16 %8, i16* %1, !dbg !261
  %9 = load i16, i16* %realStartIndex, !dbg !262
  store i16 %9, i16* %2, !dbg !262
  %10 = load i16, i16* %endIndex.addr, !dbg !263
  store i16 %10, i16* %index, !dbg !263
  %11 = load i16, i16* %1, !dbg !263
  %12 = icmp slt i16 %11, 0, !dbg !263
  br i1 %12, label %bb14, label %bb13, !dbg !263

bb4:                                              ; preds = %bb5, %bb1
  %13 = load i16, i16* %index, !dbg !259
  %14 = load i16, i16* %0, !dbg !259
  %15 = icmp sgt i16 %13, %14, !dbg !259
  br i1 %15, label %bb2, label %bb6, !dbg !259

bb5:                                              ; preds = %bb8
  %16 = load i16, i16* %index, !dbg !259
  %17 = add i16 %16, 1, !dbg !259
  store i16 %17, i16* %index, !dbg !259
  br label %bb4, !dbg !259

bb6:                                              ; preds = %bb4
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !264
  %buffer = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, i32 0, i32 1, !dbg !264
  %18 = load [1000 x i8]*, [1000 x i8]** %buffer, !dbg !264
  %19 = load i16, i16* %index, !dbg !264
  %20 = sext i16 %19 to i32, !dbg !264
  %21 = sub i32 %20, 0, !dbg !264
  %22 = getelementptr inbounds [1000 x i8], [1000 x i8]* %18, i32 0, i32 %21, !dbg !264
  %23 = load i8, i8* %22, !dbg !264
  %24 = icmp eq i8 %23, 32, !dbg !264
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !264
  %buffer2 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i32 0, i32 1, !dbg !264
  %25 = load [1000 x i8]*, [1000 x i8]** %buffer2, !dbg !264
  %26 = load i16, i16* %index, !dbg !264
  %27 = sext i16 %26 to i32, !dbg !264
  %28 = sub i32 %27, 0, !dbg !264
  %29 = getelementptr inbounds [1000 x i8], [1000 x i8]* %25, i32 0, i32 %28, !dbg !264
  %30 = load i8, i8* %29, !dbg !264
  %31 = icmp eq i8 %30, 34, !dbg !264
  %32 = or i1 %24, %31, !dbg !264
  %33 = xor i1 %32, true, !dbg !264
  br i1 %33, label %bb9, label %bb7, !dbg !264

bb7:                                              ; preds = %bb10, %bb6
  br label %bb8, !dbg !265

bb8:                                              ; preds = %bb7
  br label %bb5, !dbg !259

bb9:                                              ; preds = %bb6
  %34 = load i16, i16* %index, !dbg !266
  store i16 %34, i16* %realStartIndex, !dbg !266
  br label %bb2, !dbg !267

bb10:                                             ; No predecessors!
  br label %bb7, !dbg !267

bb11:                                             ; preds = %bb25, %bb14, %bb19, %bb13
  br label %bb12, !dbg !268

bb12:                                             ; preds = %bb11
  %auto_deref_this.addr11 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !269
  %buffer12 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr11, i32 0, i32 1, !dbg !269
  %35 = load [1000 x i8]*, [1000 x i8]** %buffer12, !dbg !269
  %36 = bitcast [1000 x i8]* %35 to i8*, !dbg !269
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %4, !dbg !269
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, i32 0, i32 0, !dbg !269
  store i8* %36, i8** %"$array_ptr", !dbg !269
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, i32 0, i32 2, !dbg !269
  %37 = bitcast [1 x %"$ax.ArrayBounds"]* %3 to %"$ax.ArrayBounds"*, !dbg !269
  store %"$ax.ArrayBounds"* %37, %"$ax.ArrayBounds"** %"$bounds", !dbg !269
  %38 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %4, !dbg !269
  %39 = load i16, i16* %realStartIndex, !dbg !269
  %40 = load i16, i16* %realEndIndex, !dbg !269
  %41 = call %STRING.0 @"Simatic.Ax.Conversion.Arrays.ToString$I@V@ARRAY [*] OF CHAR@arr?I@V@Int16@startIdx?I@V@Int16@endIdx"(%"$ax.ArrayWithBound" %38, i16 %39, i16 %40), !dbg !269
  store %STRING.0 %41, %STRING.0* %5, !dbg !269
  %42 = bitcast %STRING.0* %GetValueFromIndex.ret to i8*, !dbg !269
  %43 = bitcast %STRING.0* %5 to i8*, !dbg !269
  call void @"$ax.AssignST_String"(i8* %42, i8* %43), !dbg !269
  %44 = load %STRING.0, %STRING.0* %GetValueFromIndex.ret, !dbg !270
  ret %STRING.0 %44, !dbg !270

bb13:                                             ; preds = %bb15, %bb3
  %45 = load i16, i16* %index, !dbg !271
  %46 = load i16, i16* %2, !dbg !271
  %47 = icmp sgt i16 %45, %46, !dbg !271
  br i1 %47, label %bb11, label %bb16, !dbg !271

bb14:                                             ; preds = %bb21, %bb3
  %48 = load i16, i16* %index, !dbg !271
  %49 = load i16, i16* %2, !dbg !271
  %50 = icmp slt i16 %48, %49, !dbg !271
  br i1 %50, label %bb11, label %bb22, !dbg !271

bb15:                                             ; preds = %bb18
  %51 = load i16, i16* %index, !dbg !271
  %52 = load i16, i16* %1, !dbg !271
  %53 = add i16 %51, %52, !dbg !271
  store i16 %53, i16* %index, !dbg !271
  br label %bb13, !dbg !271

bb16:                                             ; preds = %bb13
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !272
  %buffer4 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr3, i32 0, i32 1, !dbg !272
  %54 = load [1000 x i8]*, [1000 x i8]** %buffer4, !dbg !272
  %55 = load i16, i16* %index, !dbg !272
  %56 = sext i16 %55 to i32, !dbg !272
  %57 = sub i32 %56, 0, !dbg !272
  %58 = getelementptr inbounds [1000 x i8], [1000 x i8]* %54, i32 0, i32 %57, !dbg !272
  %59 = load i8, i8* %58, !dbg !272
  %60 = icmp eq i8 %59, 32, !dbg !272
  %auto_deref_this.addr5 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !272
  %buffer6 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr5, i32 0, i32 1, !dbg !272
  %61 = load [1000 x i8]*, [1000 x i8]** %buffer6, !dbg !272
  %62 = load i16, i16* %index, !dbg !272
  %63 = sext i16 %62 to i32, !dbg !272
  %64 = sub i32 %63, 0, !dbg !272
  %65 = getelementptr inbounds [1000 x i8], [1000 x i8]* %61, i32 0, i32 %64, !dbg !272
  %66 = load i8, i8* %65, !dbg !272
  %67 = icmp eq i8 %66, 34, !dbg !272
  %68 = or i1 %60, %67, !dbg !272
  %69 = xor i1 %68, true, !dbg !272
  br i1 %69, label %bb19, label %bb17, !dbg !272

bb17:                                             ; preds = %bb20, %bb16
  br label %bb18, !dbg !273

bb18:                                             ; preds = %bb17
  br label %bb15, !dbg !271

bb19:                                             ; preds = %bb16
  %70 = load i16, i16* %index, !dbg !274
  store i16 %70, i16* %realEndIndex, !dbg !274
  br label %bb11, !dbg !275

bb20:                                             ; No predecessors!
  br label %bb17, !dbg !275

bb21:                                             ; preds = %bb24
  %71 = load i16, i16* %index, !dbg !271
  %72 = load i16, i16* %1, !dbg !271
  %73 = add i16 %71, %72, !dbg !271
  store i16 %73, i16* %index, !dbg !271
  br label %bb14, !dbg !271

bb22:                                             ; preds = %bb14
  %auto_deref_this.addr7 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !272
  %buffer8 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr7, i32 0, i32 1, !dbg !272
  %74 = load [1000 x i8]*, [1000 x i8]** %buffer8, !dbg !272
  %75 = load i16, i16* %index, !dbg !272
  %76 = sext i16 %75 to i32, !dbg !272
  %77 = sub i32 %76, 0, !dbg !272
  %78 = getelementptr inbounds [1000 x i8], [1000 x i8]* %74, i32 0, i32 %77, !dbg !272
  %79 = load i8, i8* %78, !dbg !272
  %80 = icmp eq i8 %79, 32, !dbg !272
  %auto_deref_this.addr9 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !272
  %buffer10 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr9, i32 0, i32 1, !dbg !272
  %81 = load [1000 x i8]*, [1000 x i8]** %buffer10, !dbg !272
  %82 = load i16, i16* %index, !dbg !272
  %83 = sext i16 %82 to i32, !dbg !272
  %84 = sub i32 %83, 0, !dbg !272
  %85 = getelementptr inbounds [1000 x i8], [1000 x i8]* %81, i32 0, i32 %84, !dbg !272
  %86 = load i8, i8* %85, !dbg !272
  %87 = icmp eq i8 %86, 34, !dbg !272
  %88 = or i1 %80, %87, !dbg !272
  %89 = xor i1 %88, true, !dbg !272
  br i1 %89, label %bb25, label %bb23, !dbg !272

bb23:                                             ; preds = %bb26, %bb22
  br label %bb24, !dbg !273

bb24:                                             ; preds = %bb23
  br label %bb21, !dbg !271

bb25:                                             ; preds = %bb22
  %90 = load i16, i16* %index, !dbg !274
  store i16 %90, i16* %realEndIndex, !dbg !274
  br label %bb11, !dbg !275

bb26:                                             ; No predecessors!
  br label %bb23, !dbg !275
}

define void @"Simatic.Ax.Json.Deserializer.GetBufferIndizes$I@R@Simatic.Ax.Json.Deserializer@this?O@V@Int16@bufferStart?O@V@Int16@bufferEnd"(%Simatic.Ax.Json.Deserializer* %this, i16* %bufferStart, i16* %bufferEnd) !dbg !276 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %bufferStart.addr = alloca i16*
  %bufferEnd.addr = alloca i16*
  %index = alloca i16
  %incrementBackwards = alloca i16
  call void @llvm.dbg.declare(metadata i16** %bufferStart.addr, metadata !280, metadata !DIExpression()), !dbg !281
  call void @llvm.dbg.declare(metadata i16** %bufferEnd.addr, metadata !282, metadata !DIExpression()), !dbg !283
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !284, metadata !DIExpression()), !dbg !285
  call void @llvm.dbg.declare(metadata i16* %index, metadata !286, metadata !DIExpression()), !dbg !287
  call void @llvm.dbg.declare(metadata i16* %incrementBackwards, metadata !288, metadata !DIExpression()), !dbg !289
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca i16
  store i16 0, i16* %2
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store i16* %bufferStart, i16** %bufferStart.addr
  store i16* %bufferEnd, i16** %bufferEnd.addr
  store i16 0, i16* %index
  store i16 -1, i16* %incrementBackwards
  br label %bb1

bb1:                                              ; preds = %Entry
  store i16 999, i16* %0, !dbg !290
  store i16 0, i16* %index, !dbg !291
  br label %bb4, !dbg !292

bb2:                                              ; preds = %bb9, %bb4
  br label %bb3, !dbg !293

bb3:                                              ; preds = %bb2
  %3 = load i16, i16* %incrementBackwards, !dbg !294
  store i16 %3, i16* %1, !dbg !294
  store i16 0, i16* %2, !dbg !295
  store i16 999, i16* %index, !dbg !296
  %4 = load i16, i16* %1, !dbg !296
  %5 = icmp slt i16 %4, 0, !dbg !296
  br i1 %5, label %bb14, label %bb13, !dbg !296

bb4:                                              ; preds = %bb5, %bb1
  %6 = load i16, i16* %index, !dbg !292
  %7 = load i16, i16* %0, !dbg !292
  %8 = icmp sgt i16 %6, %7, !dbg !292
  br i1 %8, label %bb2, label %bb6, !dbg !292

bb5:                                              ; preds = %bb8
  %9 = load i16, i16* %index, !dbg !292
  %10 = add i16 %9, 1, !dbg !292
  store i16 %10, i16* %index, !dbg !292
  br label %bb4, !dbg !292

bb6:                                              ; preds = %bb4
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !297
  %buffer = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, i32 0, i32 1, !dbg !297
  %11 = load [1000 x i8]*, [1000 x i8]** %buffer, !dbg !297
  %12 = load i16, i16* %index, !dbg !297
  %13 = sext i16 %12 to i32, !dbg !297
  %14 = sub i32 %13, 0, !dbg !297
  %15 = getelementptr inbounds [1000 x i8], [1000 x i8]* %11, i32 0, i32 %14, !dbg !297
  %16 = load i8, i8* %15, !dbg !297
  %17 = icmp eq i8 %16, 123, !dbg !297
  br i1 %17, label %bb9, label %bb7, !dbg !297

bb7:                                              ; preds = %bb10, %bb6
  br label %bb8, !dbg !298

bb8:                                              ; preds = %bb7
  br label %bb5, !dbg !292

bb9:                                              ; preds = %bb6
  %18 = load i16, i16* %index, !dbg !299
  %auto_deref_bufferStart.addr = load i16*, i16** %bufferStart.addr, !dbg !299
  store i16 %18, i16* %auto_deref_bufferStart.addr, !dbg !299
  br label %bb2, !dbg !300

bb10:                                             ; No predecessors!
  br label %bb7, !dbg !300

bb11:                                             ; preds = %bb25, %bb14, %bb19, %bb13
  br label %bb12, !dbg !301

bb12:                                             ; preds = %bb11
  ret void, !dbg !302

bb13:                                             ; preds = %bb15, %bb3
  %19 = load i16, i16* %index, !dbg !303
  %20 = load i16, i16* %2, !dbg !303
  %21 = icmp sgt i16 %19, %20, !dbg !303
  br i1 %21, label %bb11, label %bb16, !dbg !303

bb14:                                             ; preds = %bb21, %bb3
  %22 = load i16, i16* %index, !dbg !303
  %23 = load i16, i16* %2, !dbg !303
  %24 = icmp slt i16 %22, %23, !dbg !303
  br i1 %24, label %bb11, label %bb22, !dbg !303

bb15:                                             ; preds = %bb18
  %25 = load i16, i16* %index, !dbg !303
  %26 = load i16, i16* %1, !dbg !303
  %27 = add i16 %25, %26, !dbg !303
  store i16 %27, i16* %index, !dbg !303
  br label %bb13, !dbg !303

bb16:                                             ; preds = %bb13
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !304
  %buffer2 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i32 0, i32 1, !dbg !304
  %28 = load [1000 x i8]*, [1000 x i8]** %buffer2, !dbg !304
  %29 = load i16, i16* %index, !dbg !304
  %30 = sext i16 %29 to i32, !dbg !304
  %31 = sub i32 %30, 0, !dbg !304
  %32 = getelementptr inbounds [1000 x i8], [1000 x i8]* %28, i32 0, i32 %31, !dbg !304
  %33 = load i8, i8* %32, !dbg !304
  %34 = icmp eq i8 %33, 125, !dbg !304
  br i1 %34, label %bb19, label %bb17, !dbg !304

bb17:                                             ; preds = %bb20, %bb16
  br label %bb18, !dbg !305

bb18:                                             ; preds = %bb17
  br label %bb15, !dbg !303

bb19:                                             ; preds = %bb16
  %35 = load i16, i16* %index, !dbg !306
  %auto_deref_bufferEnd.addr = load i16*, i16** %bufferEnd.addr, !dbg !306
  store i16 %35, i16* %auto_deref_bufferEnd.addr, !dbg !306
  br label %bb11, !dbg !307

bb20:                                             ; No predecessors!
  br label %bb17, !dbg !307

bb21:                                             ; preds = %bb24
  %36 = load i16, i16* %index, !dbg !303
  %37 = load i16, i16* %1, !dbg !303
  %38 = add i16 %36, %37, !dbg !303
  store i16 %38, i16* %index, !dbg !303
  br label %bb14, !dbg !303

bb22:                                             ; preds = %bb14
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !304
  %buffer4 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr3, i32 0, i32 1, !dbg !304
  %39 = load [1000 x i8]*, [1000 x i8]** %buffer4, !dbg !304
  %40 = load i16, i16* %index, !dbg !304
  %41 = sext i16 %40 to i32, !dbg !304
  %42 = sub i32 %41, 0, !dbg !304
  %43 = getelementptr inbounds [1000 x i8], [1000 x i8]* %39, i32 0, i32 %42, !dbg !304
  %44 = load i8, i8* %43, !dbg !304
  %45 = icmp eq i8 %44, 125, !dbg !304
  br i1 %45, label %bb25, label %bb23, !dbg !304

bb23:                                             ; preds = %bb26, %bb22
  br label %bb24, !dbg !305

bb24:                                             ; preds = %bb23
  br label %bb21, !dbg !303

bb25:                                             ; preds = %bb22
  %46 = load i16, i16* %index, !dbg !306
  %auto_deref_bufferEnd.addr5 = load i16*, i16** %bufferEnd.addr, !dbg !306
  store i16 %46, i16* %auto_deref_bufferEnd.addr5, !dbg !306
  br label %bb11, !dbg !307

bb26:                                             ; No predecessors!
  br label %bb23, !dbg !307
}

define i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i16* %areaStartIndex, i16* %areaEndIndex) !dbg !308 {
Entry:
  %GetValue_WithKeyArray.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %areaStartIndex.addr = alloca i16*
  %areaEndIndex.addr = alloca i16*
  %key = alloca %STRING.0
  %keyFound = alloca i1
  %valueFound = alloca i1
  %keyIndex = alloca i32
  %index = alloca i16
  %quotationMarkCount = alloca i16
  %bracesCount = alloca i16
  %squareBrakedCount = alloca i16
  %inKeyArea = alloca i1
  %inValueArea = alloca i1
  %inArrayArea = alloca i1
  %inNestedArea = alloca i1
  %documentStartIndex = alloca i16
  %documentEndIndex = alloca i16
  %keyArrayLower = alloca i32
  %keyArrayUpper = alloca i32
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !312, metadata !DIExpression()), !dbg !313
  call void @llvm.dbg.declare(metadata i16** %areaStartIndex.addr, metadata !314, metadata !DIExpression()), !dbg !315
  call void @llvm.dbg.declare(metadata i16** %areaEndIndex.addr, metadata !316, metadata !DIExpression()), !dbg !317
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !318, metadata !DIExpression()), !dbg !319
  call void @llvm.dbg.declare(metadata %STRING.0* %key, metadata !320, metadata !DIExpression()), !dbg !321
  call void @llvm.dbg.declare(metadata i1* %keyFound, metadata !322, metadata !DIExpression()), !dbg !323
  call void @llvm.dbg.declare(metadata i1* %valueFound, metadata !324, metadata !DIExpression()), !dbg !325
  call void @llvm.dbg.declare(metadata i32* %keyIndex, metadata !326, metadata !DIExpression()), !dbg !327
  call void @llvm.dbg.declare(metadata i16* %index, metadata !328, metadata !DIExpression()), !dbg !329
  call void @llvm.dbg.declare(metadata i16* %quotationMarkCount, metadata !330, metadata !DIExpression()), !dbg !331
  call void @llvm.dbg.declare(metadata i16* %bracesCount, metadata !332, metadata !DIExpression()), !dbg !333
  call void @llvm.dbg.declare(metadata i16* %squareBrakedCount, metadata !334, metadata !DIExpression()), !dbg !335
  call void @llvm.dbg.declare(metadata i1* %inKeyArea, metadata !336, metadata !DIExpression()), !dbg !337
  call void @llvm.dbg.declare(metadata i1* %inValueArea, metadata !338, metadata !DIExpression()), !dbg !339
  call void @llvm.dbg.declare(metadata i1* %inArrayArea, metadata !340, metadata !DIExpression()), !dbg !341
  call void @llvm.dbg.declare(metadata i1* %inNestedArea, metadata !342, metadata !DIExpression()), !dbg !343
  call void @llvm.dbg.declare(metadata i16* %documentStartIndex, metadata !344, metadata !DIExpression()), !dbg !345
  call void @llvm.dbg.declare(metadata i16* %documentEndIndex, metadata !346, metadata !DIExpression()), !dbg !347
  call void @llvm.dbg.declare(metadata i32* %keyArrayLower, metadata !348, metadata !DIExpression()), !dbg !349
  call void @llvm.dbg.declare(metadata i32* %keyArrayUpper, metadata !350, metadata !DIExpression()), !dbg !351
  call void @llvm.dbg.declare(metadata i1* %GetValue_WithKeyArray.ret, metadata !352, metadata !DIExpression()), !dbg !319
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca i32
  store i32 0, i32* %2
  %3 = alloca i16
  store i16 0, i16* %3
  store i1 false, i1* %GetValue_WithKeyArray.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i16* %areaStartIndex, i16** %areaStartIndex.addr
  store i16* %areaEndIndex, i16** %areaEndIndex.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key
  store i1 false, i1* %keyFound
  store i1 false, i1* %valueFound
  store i32 0, i32* %keyIndex
  store i16 0, i16* %index
  store i16 0, i16* %quotationMarkCount
  store i16 0, i16* %bracesCount
  store i16 0, i16* %squareBrakedCount
  store i1 true, i1* %inKeyArea
  store i1 false, i1* %inValueArea
  store i1 false, i1* %inArrayArea
  store i1 false, i1* %inNestedArea
  store i16 0, i16* %documentStartIndex
  store i16 0, i16* %documentEndIndex
  store i32 0, i32* %keyArrayLower
  store i32 0, i32* %keyArrayUpper
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %documentStartIndex, !dbg !353
  store i16 %4, i16* %0, !dbg !353
  %5 = load i16, i16* %documentEndIndex, !dbg !353
  store i16 %5, i16* %1, !dbg !353
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !353
  call void @"Simatic.Ax.Json.Deserializer.GetBufferIndizes$I@R@Simatic.Ax.Json.Deserializer@this?O@V@Int16@bufferStart?O@V@Int16@bufferEnd"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, i16* %0, i16* %1), !dbg !353
  %6 = load i16, i16* %0, !dbg !353
  store i16 %6, i16* %documentStartIndex, !dbg !353
  %7 = load i16, i16* %1, !dbg !353
  store i16 %7, i16* %documentEndIndex, !dbg !353
  %8 = call i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* %keyArray.addr, i32 1), !dbg !354
  store i32 %8, i32* %keyArrayLower, !dbg !354
  %9 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %keyArray.addr, i32 1), !dbg !355
  store i32 %9, i32* %keyArrayUpper, !dbg !355
  %10 = load i32, i32* %keyArrayUpper, !dbg !356
  store i32 %10, i32* %2, !dbg !356
  %11 = load i32, i32* %keyArrayLower, !dbg !357
  store i32 %11, i32* %keyIndex, !dbg !357
  br label %bb4, !dbg !358

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !359

bb3:                                              ; preds = %bb2
  %12 = load i1, i1* %GetValue_WithKeyArray.ret, !dbg !360
  ret i1 %12, !dbg !360

bb4:                                              ; preds = %bb5, %bb1
  %13 = load i32, i32* %keyIndex, !dbg !358
  %14 = load i32, i32* %2, !dbg !358
  %15 = icmp sgt i32 %13, %14, !dbg !358
  br i1 %15, label %bb2, label %bb6, !dbg !358

bb5:                                              ; preds = %bb76
  %16 = load i32, i32* %keyIndex, !dbg !358
  %17 = add i32 %16, 1, !dbg !358
  store i32 %17, i32* %keyIndex, !dbg !358
  br label %bb4, !dbg !358

bb6:                                              ; preds = %bb4
  %18 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, i32 0, i32 0, !dbg !361
  %"$elementPtr" = load i8*, i8** %18, !dbg !361
  %19 = bitcast i8* %"$elementPtr" to %STRING.0*, !dbg !361
  %"$allBounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, i32 0, i32 2, !dbg !361
  %20 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds", !dbg !361
  %"$bounds0" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %20, i32 0, !dbg !361
  %21 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 0, !dbg !361
  %"$lowerBound0" = load i32, i32* %21, !dbg !361
  %22 = load i32, i32* %keyIndex, !dbg !361
  %23 = sub i32 %22, %"$lowerBound0", !dbg !361
  %24 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 2, !dbg !361
  %"$countNextDims0" = load i32, i32* %24, !dbg !361
  %25 = mul i32 %23, %"$countNextDims0", !dbg !361
  %"$gepIndex0" = add i32 0, %25, !dbg !361
  %26 = getelementptr %STRING.0, %STRING.0* %19, i32 %"$gepIndex0", !dbg !361
  %27 = bitcast %STRING.0* %key to i8*, !dbg !361
  %28 = bitcast %STRING.0* %26 to i8*, !dbg !361
  call void @"$ax.AssignST_String"(i8* %27, i8* %28), !dbg !361
  %29 = load i16, i16* %documentEndIndex, !dbg !362
  store i16 %29, i16* %3, !dbg !362
  %30 = load i16, i16* %documentStartIndex, !dbg !363
  store i16 %30, i16* %index, !dbg !363
  br label %bb9, !dbg !364

bb7:                                              ; preds = %bb72, %bb9
  br label %bb8, !dbg !365

bb8:                                              ; preds = %bb7
  %31 = load i1, i1* %keyFound, !dbg !366
  %32 = icmp eq i1 %31, true, !dbg !366
  %33 = load i1, i1* %valueFound, !dbg !366
  %34 = icmp eq i1 %33, true, !dbg !366
  %35 = and i1 %32, %34, !dbg !366
  br i1 %35, label %bb77, label %bb74, !dbg !366

bb9:                                              ; preds = %bb10, %bb6
  %36 = load i16, i16* %index, !dbg !364
  %37 = load i16, i16* %3, !dbg !364
  %38 = icmp sgt i16 %36, %37, !dbg !364
  br i1 %38, label %bb7, label %bb11, !dbg !364

bb10:                                             ; preds = %bb71, %bb65, %bb51, %bb35, %bb22
  %39 = load i16, i16* %index, !dbg !364
  %40 = add i16 %39, 1, !dbg !364
  store i16 %40, i16* %index, !dbg !364
  br label %bb9, !dbg !364

bb11:                                             ; preds = %bb9
  %41 = load i1, i1* %inNestedArea, !dbg !367
  %42 = xor i1 %41, true, !dbg !367
  %43 = load i1, i1* %inKeyArea, !dbg !367
  %44 = and i1 %43, %42, !dbg !367
  %45 = load i1, i1* %inValueArea, !dbg !367
  %46 = xor i1 %45, true, !dbg !367
  %47 = and i1 %44, %46, !dbg !367
  %48 = load i1, i1* %inArrayArea, !dbg !367
  %49 = xor i1 %48, true, !dbg !367
  %50 = and i1 %47, %49, !dbg !367
  br i1 %50, label %bb14, label %bb12, !dbg !367

bb12:                                             ; preds = %bb16, %bb11
  br label %bb13, !dbg !368

bb13:                                             ; preds = %bb12
  %51 = load i1, i1* %inKeyArea, !dbg !369
  %52 = xor i1 %51, true, !dbg !369
  %53 = load i1, i1* %inNestedArea, !dbg !369
  %54 = xor i1 %53, true, !dbg !369
  %55 = and i1 %52, %54, !dbg !369
  br i1 %55, label %bb30, label %bb28, !dbg !369

bb14:                                             ; preds = %bb11
  %56 = load i1, i1* %keyFound, !dbg !370
  %57 = icmp eq i1 %56, false, !dbg !370
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !370
  %buffer = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i32 0, i32 1, !dbg !370
  %58 = load [1000 x i8]*, [1000 x i8]** %buffer, !dbg !370
  %59 = load i16, i16* %index, !dbg !370
  %60 = sext i16 %59 to i32, !dbg !370
  %61 = sub i32 %60, 0, !dbg !370
  %62 = getelementptr inbounds [1000 x i8], [1000 x i8]* %58, i32 0, i32 %61, !dbg !370
  %63 = load i8, i8* %62, !dbg !370
  %64 = icmp eq i8 %63, 34, !dbg !370
  %65 = and i1 %57, %64, !dbg !370
  br i1 %65, label %bb17, label %bb15, !dbg !370

bb15:                                             ; preds = %bb27, %bb14
  br label %bb16, !dbg !371

bb16:                                             ; preds = %bb15
  br label %bb12, !dbg !371

bb17:                                             ; preds = %bb14
  %66 = load i16, i16* %quotationMarkCount, !dbg !372
  %67 = add i16 %66, 1, !dbg !372
  store i16 %67, i16* %quotationMarkCount, !dbg !372
  %68 = load i16, i16* %quotationMarkCount, !dbg !373
  %69 = icmp eq i16 %68, 1, !dbg !373
  br i1 %69, label %bb20, label %bb18, !dbg !373

bb18:                                             ; preds = %bb20, %bb17
  br label %bb19, !dbg !374

bb19:                                             ; preds = %bb18
  %70 = load i16, i16* %quotationMarkCount, !dbg !375
  %71 = icmp eq i16 %70, 2, !dbg !375
  br i1 %71, label %bb23, label %bb21, !dbg !375

bb20:                                             ; preds = %bb17
  %72 = load i16, i16* %index, !dbg !376
  %73 = add i16 %72, 1, !dbg !376
  %auto_deref_areaStartIndex.addr = load i16*, i16** %areaStartIndex.addr, !dbg !376
  store i16 %73, i16* %auto_deref_areaStartIndex.addr, !dbg !376
  br label %bb18, !dbg !376

bb21:                                             ; preds = %bb25, %bb19
  br label %bb22, !dbg !377

bb22:                                             ; preds = %bb21
  br label %bb10, !dbg !378

bb23:                                             ; preds = %bb19
  store i1 false, i1* %inKeyArea, !dbg !379
  %74 = load i16, i16* %index, !dbg !380
  %75 = sub i16 %74, 1, !dbg !380
  %auto_deref_areaEndIndex.addr = load i16*, i16** %areaEndIndex.addr, !dbg !380
  store i16 %75, i16* %auto_deref_areaEndIndex.addr, !dbg !380
  store i16 0, i16* %quotationMarkCount, !dbg !381
  %76 = bitcast %STRING.0* %key to i8*, !dbg !382
  %77 = call i16 @ax_LenST_String(i8* %76), !dbg !382
  %auto_deref_areaEndIndex.addr2 = load i16*, i16** %areaEndIndex.addr, !dbg !382
  %78 = load i16, i16* %auto_deref_areaEndIndex.addr2, !dbg !382
  %auto_deref_areaStartIndex.addr3 = load i16*, i16** %areaStartIndex.addr, !dbg !382
  %79 = load i16, i16* %auto_deref_areaStartIndex.addr3, !dbg !382
  %80 = sub i16 %78, %79, !dbg !382
  %81 = add i16 %80, 1, !dbg !382
  %82 = icmp eq i16 %77, %81, !dbg !382
  br i1 %82, label %bb26, label %bb24, !dbg !382

bb24:                                             ; preds = %bb26, %bb23
  br label %bb25, !dbg !383

bb25:                                             ; preds = %bb24
  br label %bb21, !dbg !383

bb26:                                             ; preds = %bb23
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !384
  %83 = bitcast %STRING.0* %key to i8*, !dbg !384
  %auto_deref_areaStartIndex.addr5 = load i16*, i16** %areaStartIndex.addr, !dbg !384
  %84 = load i16, i16* %auto_deref_areaStartIndex.addr5, !dbg !384
  %auto_deref_areaEndIndex.addr6 = load i16*, i16** %areaEndIndex.addr, !dbg !384
  %85 = load i16, i16* %auto_deref_areaEndIndex.addr6, !dbg !384
  %86 = call i1 @"Simatic.Ax.Json.Deserializer.KeyIsInIndexSpan$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr4, i8* %83, i16 %84, i16 %85), !dbg !384
  store i1 %86, i1* %keyFound, !dbg !384
  br label %bb24, !dbg !384

bb27:                                             ; No predecessors!
  br label %bb15, !dbg !378

bb28:                                             ; preds = %bb39, %bb13
  br label %bb29, !dbg !385

bb29:                                             ; preds = %bb28
  %87 = load i1, i1* %inKeyArea, !dbg !386
  %88 = xor i1 %87, true, !dbg !386
  %89 = load i1, i1* %inArrayArea, !dbg !386
  %90 = xor i1 %89, true, !dbg !386
  %91 = and i1 %88, %90, !dbg !386
  br i1 %91, label %bb46, label %bb44, !dbg !386

bb30:                                             ; preds = %bb13
  %auto_deref_this.addr7 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !387
  %buffer8 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr7, i32 0, i32 1, !dbg !387
  %92 = load [1000 x i8]*, [1000 x i8]** %buffer8, !dbg !387
  %93 = load i16, i16* %index, !dbg !387
  %94 = sext i16 %93 to i32, !dbg !387
  %95 = sub i32 %94, 0, !dbg !387
  %96 = getelementptr inbounds [1000 x i8], [1000 x i8]* %92, i32 0, i32 %95, !dbg !387
  %97 = load i8, i8* %96, !dbg !387
  %98 = icmp eq i8 %97, 91, !dbg !387
  br i1 %98, label %bb33, label %bb31, !dbg !387

bb31:                                             ; preds = %bb37, %bb30
  br label %bb32, !dbg !388

bb32:                                             ; preds = %bb31
  %auto_deref_this.addr10 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !389
  %buffer11 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr10, i32 0, i32 1, !dbg !389
  %99 = load [1000 x i8]*, [1000 x i8]** %buffer11, !dbg !389
  %100 = load i16, i16* %index, !dbg !389
  %101 = sext i16 %100 to i32, !dbg !389
  %102 = sub i32 %101, 0, !dbg !389
  %103 = getelementptr inbounds [1000 x i8], [1000 x i8]* %99, i32 0, i32 %102, !dbg !389
  %104 = load i8, i8* %103, !dbg !389
  %105 = icmp eq i8 %104, 93, !dbg !389
  %106 = load i1, i1* %inValueArea, !dbg !389
  %107 = xor i1 %106, true, !dbg !389
  %108 = and i1 %105, %107, !dbg !389
  br i1 %108, label %bb40, label %bb38, !dbg !389

bb33:                                             ; preds = %bb30
  %109 = load i16, i16* %squareBrakedCount, !dbg !390
  %110 = add i16 %109, 1, !dbg !390
  store i16 %110, i16* %squareBrakedCount, !dbg !390
  %111 = load i16, i16* %squareBrakedCount, !dbg !391
  %112 = icmp eq i16 %111, 1, !dbg !391
  br i1 %112, label %bb36, label %bb34, !dbg !391

bb34:                                             ; preds = %bb36, %bb33
  br label %bb35, !dbg !392

bb35:                                             ; preds = %bb34
  br label %bb10, !dbg !393

bb36:                                             ; preds = %bb33
  store i1 true, i1* %inArrayArea, !dbg !394
  store i1 false, i1* %inNestedArea, !dbg !395
  store i1 false, i1* %inKeyArea, !dbg !396
  store i1 false, i1* %inValueArea, !dbg !397
  %113 = load i16, i16* %index, !dbg !398
  %auto_deref_areaStartIndex.addr9 = load i16*, i16** %areaStartIndex.addr, !dbg !398
  store i16 %113, i16* %auto_deref_areaStartIndex.addr9, !dbg !398
  br label %bb34, !dbg !398

bb37:                                             ; No predecessors!
  br label %bb31, !dbg !393

bb38:                                             ; preds = %bb42, %bb32
  br label %bb39, !dbg !399

bb39:                                             ; preds = %bb38
  br label %bb28, !dbg !399

bb40:                                             ; preds = %bb32
  %114 = load i16, i16* %squareBrakedCount, !dbg !400
  %115 = sub i16 %114, 1, !dbg !400
  store i16 %115, i16* %squareBrakedCount, !dbg !400
  %116 = load i16, i16* %squareBrakedCount, !dbg !401
  %117 = icmp eq i16 %116, 0, !dbg !401
  br i1 %117, label %bb43, label %bb41, !dbg !401

bb41:                                             ; preds = %bb43, %bb40
  br label %bb42, !dbg !402

bb42:                                             ; preds = %bb41
  br label %bb38, !dbg !402

bb43:                                             ; preds = %bb40
  store i1 true, i1* %inKeyArea, !dbg !403
  store i1 false, i1* %inNestedArea, !dbg !404
  store i1 false, i1* %inValueArea, !dbg !405
  store i1 false, i1* %inArrayArea, !dbg !406
  %118 = load i16, i16* %index, !dbg !407
  %auto_deref_areaEndIndex.addr12 = load i16*, i16** %areaEndIndex.addr, !dbg !407
  store i16 %118, i16* %auto_deref_areaEndIndex.addr12, !dbg !407
  store i1 true, i1* %valueFound, !dbg !408
  br label %bb41, !dbg !408

bb44:                                             ; preds = %bb55, %bb29
  br label %bb45, !dbg !409

bb45:                                             ; preds = %bb44
  %119 = load i1, i1* %inKeyArea, !dbg !410
  %120 = xor i1 %119, true, !dbg !410
  %121 = load i1, i1* %inNestedArea, !dbg !410
  %122 = xor i1 %121, true, !dbg !410
  %123 = and i1 %120, %122, !dbg !410
  %124 = load i1, i1* %inArrayArea, !dbg !410
  %125 = xor i1 %124, true, !dbg !410
  %126 = and i1 %123, %125, !dbg !410
  br i1 %126, label %bb62, label %bb60, !dbg !410

bb46:                                             ; preds = %bb29
  %auto_deref_this.addr13 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !411
  %buffer14 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr13, i32 0, i32 1, !dbg !411
  %127 = load [1000 x i8]*, [1000 x i8]** %buffer14, !dbg !411
  %128 = load i16, i16* %index, !dbg !411
  %129 = sext i16 %128 to i32, !dbg !411
  %130 = sub i32 %129, 0, !dbg !411
  %131 = getelementptr inbounds [1000 x i8], [1000 x i8]* %127, i32 0, i32 %130, !dbg !411
  %132 = load i8, i8* %131, !dbg !411
  %133 = icmp eq i8 %132, 123, !dbg !411
  br i1 %133, label %bb49, label %bb47, !dbg !411

bb47:                                             ; preds = %bb53, %bb46
  br label %bb48, !dbg !412

bb48:                                             ; preds = %bb47
  %auto_deref_this.addr16 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !413
  %buffer17 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr16, i32 0, i32 1, !dbg !413
  %134 = load [1000 x i8]*, [1000 x i8]** %buffer17, !dbg !413
  %135 = load i16, i16* %index, !dbg !413
  %136 = sext i16 %135 to i32, !dbg !413
  %137 = sub i32 %136, 0, !dbg !413
  %138 = getelementptr inbounds [1000 x i8], [1000 x i8]* %134, i32 0, i32 %137, !dbg !413
  %139 = load i8, i8* %138, !dbg !413
  %140 = icmp eq i8 %139, 125, !dbg !413
  %141 = load i1, i1* %inValueArea, !dbg !413
  %142 = xor i1 %141, true, !dbg !413
  %143 = and i1 %140, %142, !dbg !413
  br i1 %143, label %bb56, label %bb54, !dbg !413

bb49:                                             ; preds = %bb46
  %144 = load i16, i16* %bracesCount, !dbg !414
  %145 = add i16 %144, 1, !dbg !414
  store i16 %145, i16* %bracesCount, !dbg !414
  %146 = load i16, i16* %bracesCount, !dbg !415
  %147 = icmp eq i16 %146, 1, !dbg !415
  br i1 %147, label %bb52, label %bb50, !dbg !415

bb50:                                             ; preds = %bb52, %bb49
  br label %bb51, !dbg !416

bb51:                                             ; preds = %bb50
  br label %bb10, !dbg !417

bb52:                                             ; preds = %bb49
  store i1 true, i1* %inNestedArea, !dbg !418
  store i1 false, i1* %inKeyArea, !dbg !419
  store i1 false, i1* %inValueArea, !dbg !420
  store i1 false, i1* %inArrayArea, !dbg !421
  %148 = load i16, i16* %index, !dbg !422
  %auto_deref_areaStartIndex.addr15 = load i16*, i16** %areaStartIndex.addr, !dbg !422
  store i16 %148, i16* %auto_deref_areaStartIndex.addr15, !dbg !422
  br label %bb50, !dbg !422

bb53:                                             ; No predecessors!
  br label %bb47, !dbg !417

bb54:                                             ; preds = %bb58, %bb48
  br label %bb55, !dbg !423

bb55:                                             ; preds = %bb54
  br label %bb44, !dbg !423

bb56:                                             ; preds = %bb48
  %149 = load i16, i16* %bracesCount, !dbg !424
  %150 = sub i16 %149, 1, !dbg !424
  store i16 %150, i16* %bracesCount, !dbg !424
  %151 = load i16, i16* %bracesCount, !dbg !425
  %152 = icmp eq i16 %151, 0, !dbg !425
  br i1 %152, label %bb59, label %bb57, !dbg !425

bb57:                                             ; preds = %bb59, %bb56
  br label %bb58, !dbg !426

bb58:                                             ; preds = %bb57
  br label %bb54, !dbg !426

bb59:                                             ; preds = %bb56
  store i1 true, i1* %inKeyArea, !dbg !427
  store i1 false, i1* %inNestedArea, !dbg !428
  store i1 false, i1* %inValueArea, !dbg !429
  store i1 false, i1* %inArrayArea, !dbg !430
  %153 = load i16, i16* %index, !dbg !431
  %auto_deref_areaEndIndex.addr18 = load i16*, i16** %areaEndIndex.addr, !dbg !431
  store i16 %153, i16* %auto_deref_areaEndIndex.addr18, !dbg !431
  store i1 true, i1* %valueFound, !dbg !432
  br label %bb57, !dbg !432

bb60:                                             ; preds = %bb68, %bb45
  br label %bb61, !dbg !433

bb61:                                             ; preds = %bb60
  %154 = load i1, i1* %keyFound, !dbg !434
  %155 = icmp eq i1 %154, true, !dbg !434
  %156 = load i1, i1* %valueFound, !dbg !434
  %157 = icmp eq i1 %156, true, !dbg !434
  %158 = and i1 %155, %157, !dbg !434
  br i1 %158, label %bb72, label %bb70, !dbg !434

bb62:                                             ; preds = %bb45
  %auto_deref_this.addr19 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !435
  %buffer20 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr19, i32 0, i32 1, !dbg !435
  %159 = load [1000 x i8]*, [1000 x i8]** %buffer20, !dbg !435
  %160 = load i16, i16* %index, !dbg !435
  %161 = sext i16 %160 to i32, !dbg !435
  %162 = sub i32 %161, 0, !dbg !435
  %163 = getelementptr inbounds [1000 x i8], [1000 x i8]* %159, i32 0, i32 %162, !dbg !435
  %164 = load i8, i8* %163, !dbg !435
  %165 = icmp eq i8 %164, 58, !dbg !435
  br i1 %165, label %bb65, label %bb63, !dbg !435

bb63:                                             ; preds = %bb66, %bb62
  br label %bb64, !dbg !436

bb64:                                             ; preds = %bb63
  %auto_deref_this.addr22 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !437
  %buffer23 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr22, i32 0, i32 1, !dbg !437
  %166 = load [1000 x i8]*, [1000 x i8]** %buffer23, !dbg !437
  %167 = load i16, i16* %index, !dbg !437
  %168 = sext i16 %167 to i32, !dbg !437
  %169 = sub i32 %168, 0, !dbg !437
  %170 = getelementptr inbounds [1000 x i8], [1000 x i8]* %166, i32 0, i32 %169, !dbg !437
  %171 = load i8, i8* %170, !dbg !437
  %172 = icmp eq i8 %171, 44, !dbg !437
  %auto_deref_this.addr24 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !437
  %buffer25 = getelementptr inbounds %Simatic.Ax.Json.Deserializer, %Simatic.Ax.Json.Deserializer* %auto_deref_this.addr24, i32 0, i32 1, !dbg !437
  %173 = load [1000 x i8]*, [1000 x i8]** %buffer25, !dbg !437
  %174 = load i16, i16* %index, !dbg !437
  %175 = sext i16 %174 to i32, !dbg !437
  %176 = sub i32 %175, 0, !dbg !437
  %177 = getelementptr inbounds [1000 x i8], [1000 x i8]* %173, i32 0, i32 %176, !dbg !437
  %178 = load i8, i8* %177, !dbg !437
  %179 = icmp eq i8 %178, 125, !dbg !437
  %180 = or i1 %172, %179, !dbg !437
  br i1 %180, label %bb69, label %bb67, !dbg !437

bb65:                                             ; preds = %bb62
  store i1 true, i1* %inValueArea, !dbg !438
  store i1 false, i1* %inNestedArea, !dbg !439
  store i1 false, i1* %inKeyArea, !dbg !440
  store i1 false, i1* %inArrayArea, !dbg !441
  %181 = load i16, i16* %index, !dbg !442
  %182 = add i16 %181, 1, !dbg !442
  %auto_deref_areaStartIndex.addr21 = load i16*, i16** %areaStartIndex.addr, !dbg !442
  store i16 %182, i16* %auto_deref_areaStartIndex.addr21, !dbg !442
  br label %bb10, !dbg !443

bb66:                                             ; No predecessors!
  br label %bb63, !dbg !443

bb67:                                             ; preds = %bb69, %bb64
  br label %bb68, !dbg !444

bb68:                                             ; preds = %bb67
  br label %bb60, !dbg !444

bb69:                                             ; preds = %bb64
  store i1 true, i1* %inKeyArea, !dbg !445
  store i1 false, i1* %inValueArea, !dbg !446
  store i1 false, i1* %inNestedArea, !dbg !447
  store i1 false, i1* %inArrayArea, !dbg !448
  %183 = load i16, i16* %index, !dbg !449
  %184 = sub i16 %183, 1, !dbg !449
  %auto_deref_areaEndIndex.addr26 = load i16*, i16** %areaEndIndex.addr, !dbg !449
  store i16 %184, i16* %auto_deref_areaEndIndex.addr26, !dbg !449
  store i1 true, i1* %valueFound, !dbg !450
  br label %bb67, !dbg !450

bb70:                                             ; preds = %bb73, %bb61
  br label %bb71, !dbg !451

bb71:                                             ; preds = %bb70
  store i1 false, i1* %valueFound, !dbg !452
  br label %bb10, !dbg !364

bb72:                                             ; preds = %bb61
  br label %bb7, !dbg !453

bb73:                                             ; No predecessors!
  br label %bb70, !dbg !453

bb74:                                             ; preds = %bb8
  %185 = load i1, i1* %keyFound, !dbg !454
  store i1 %185, i1* %GetValue_WithKeyArray.ret, !dbg !454
  %186 = load i1, i1* %GetValue_WithKeyArray.ret, !dbg !455
  ret i1 %186, !dbg !455

bb75:                                             ; preds = %bb78, %bb77
  br label %bb76, !dbg !456

bb76:                                             ; preds = %bb75
  br label %bb5, !dbg !358

bb77:                                             ; preds = %bb8
  %187 = load i1, i1* %keyFound, !dbg !457
  store i1 %187, i1* %GetValue_WithKeyArray.ret, !dbg !457
  %auto_deref_areaStartIndex.addr27 = load i16*, i16** %areaStartIndex.addr, !dbg !458
  %188 = load i16, i16* %auto_deref_areaStartIndex.addr27, !dbg !458
  store i16 %188, i16* %documentStartIndex, !dbg !458
  %auto_deref_areaEndIndex.addr28 = load i16*, i16** %areaEndIndex.addr, !dbg !459
  %189 = load i16, i16* %auto_deref_areaEndIndex.addr28, !dbg !459
  store i16 %189, i16* %documentEndIndex, !dbg !459
  store i1 false, i1* %valueFound, !dbg !460
  store i1 false, i1* %keyFound, !dbg !461
  br label %bb75, !dbg !461

bb78:                                             ; No predecessors!
  br label %bb75, !dbg !455
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@STRING@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i8* %value) !dbg !462 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca %STRING.0*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !465, metadata !DIExpression()), !dbg !466
  call void @llvm.dbg.declare(metadata %STRING.0** %value.addr, metadata !467, metadata !DIExpression()), !dbg !468
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !469, metadata !DIExpression()), !dbg !470
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !471, metadata !DIExpression()), !dbg !476
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !477, metadata !DIExpression()), !dbg !478
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !479, metadata !DIExpression()), !dbg !480
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !481, metadata !DIExpression()), !dbg !470
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %5 = bitcast %STRING.0* %key.addr to i8*, !dbg !470
  call void @"$ax.AssignST_String"(i8* %5, i8* %key), !dbg !470
  %6 = bitcast %STRING.0** %value.addr to i8**
  store i8* %value, i8** %6
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !482
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !482
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !482
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !482
  %10 = load i16, i16* %valueStartIndex, !dbg !483
  store i16 %10, i16* %0, !dbg !483
  %11 = load i16, i16* %valueEndIndex, !dbg !483
  store i16 %11, i16* %1, !dbg !483
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !483
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !483
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !483
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !483
  store i8* %12, i8** %"$array_ptr", !dbg !483
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !483
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !483
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !483
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !483
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !483
  %16 = load i16, i16* %0, !dbg !483
  store i16 %16, i16* %valueStartIndex, !dbg !483
  %17 = load i16, i16* %1, !dbg !483
  store i16 %17, i16* %valueEndIndex, !dbg !483
  store i1 %15, i1* %TryParse.ret, !dbg !483
  %18 = load i1, i1* %TryParse.ret, !dbg !484
  br i1 %18, label %bb5, label %bb2, !dbg !484

bb2:                                              ; preds = %bb1
  %auto_deref_value.addr2 = load %STRING.0*, %STRING.0** %value.addr, !dbg !485
  %19 = bitcast %STRING.0* %auto_deref_value.addr2 to i8*, !dbg !485
  call void @"$ax.AssignST_String"(i8* %19, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr.27", i32 0, i32 0)), !dbg !485
  br label %bb3, !dbg !485

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !486

bb4:                                              ; preds = %bb3
  %20 = load i1, i1* %TryParse.ret, !dbg !487
  ret i1 %20, !dbg !487

bb5:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !488
  %21 = load i16, i16* %valueStartIndex, !dbg !488
  %22 = load i16, i16* %valueEndIndex, !dbg !488
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !488
  store %STRING.0 %23, %STRING.0* %4, !dbg !488
  %auto_deref_value.addr = load %STRING.0*, %STRING.0** %value.addr, !dbg !488
  %24 = bitcast %STRING.0* %auto_deref_value.addr to i8*, !dbg !488
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !488
  call void @"$ax.AssignST_String"(i8* %24, i8* %25), !dbg !488
  br label %bb3, !dbg !488
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@STRING@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i8* %value) !dbg !489 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca %STRING.0*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !492, metadata !DIExpression()), !dbg !493
  call void @llvm.dbg.declare(metadata %STRING.0** %value.addr, metadata !494, metadata !DIExpression()), !dbg !495
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !496, metadata !DIExpression()), !dbg !497
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !498, metadata !DIExpression()), !dbg !499
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !500, metadata !DIExpression()), !dbg !501
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !502, metadata !DIExpression()), !dbg !497
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  %3 = bitcast %STRING.0** %value.addr to i8**
  store i8* %value, i8** %3
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !503
  store i16 %4, i16* %0, !dbg !503
  %5 = load i16, i16* %valueEndIndex, !dbg !503
  store i16 %5, i16* %1, !dbg !503
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !503
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !503
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !503
  %8 = load i16, i16* %0, !dbg !503
  store i16 %8, i16* %valueStartIndex, !dbg !503
  %9 = load i16, i16* %1, !dbg !503
  store i16 %9, i16* %valueEndIndex, !dbg !503
  store i1 %7, i1* %TryParse.ret, !dbg !503
  %10 = load i1, i1* %TryParse.ret, !dbg !504
  br i1 %10, label %bb5, label %bb2, !dbg !504

bb2:                                              ; preds = %bb1
  %auto_deref_value.addr2 = load %STRING.0*, %STRING.0** %value.addr, !dbg !505
  %11 = bitcast %STRING.0* %auto_deref_value.addr2 to i8*, !dbg !505
  call void @"$ax.AssignST_String"(i8* %11, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr.28", i32 0, i32 0)), !dbg !505
  br label %bb3, !dbg !505

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !506

bb4:                                              ; preds = %bb3
  %12 = load i1, i1* %TryParse.ret, !dbg !507
  ret i1 %12, !dbg !507

bb5:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !508
  %13 = load i16, i16* %valueStartIndex, !dbg !508
  %14 = load i16, i16* %valueEndIndex, !dbg !508
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !508
  store %STRING.0 %15, %STRING.0* %2, !dbg !508
  %auto_deref_value.addr = load %STRING.0*, %STRING.0** %value.addr, !dbg !508
  %16 = bitcast %STRING.0* %auto_deref_value.addr to i8*, !dbg !508
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !508
  call void @"$ax.AssignST_String"(i8* %16, i8* %17), !dbg !508
  br label %bb3, !dbg !508
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int8@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i8* %value) !dbg !509 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i8*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !515, metadata !DIExpression()), !dbg !516
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !517, metadata !DIExpression()), !dbg !518
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !519, metadata !DIExpression()), !dbg !520
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !521, metadata !DIExpression()), !dbg !522
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !523, metadata !DIExpression()), !dbg !524
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !525, metadata !DIExpression()), !dbg !526
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !527, metadata !DIExpression()), !dbg !520
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i8
  store i8 0, i8* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !520
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !520
  store i8* %value, i8** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !528
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !528
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !528
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !528
  %10 = load i16, i16* %valueStartIndex, !dbg !529
  store i16 %10, i16* %0, !dbg !529
  %11 = load i16, i16* %valueEndIndex, !dbg !529
  store i16 %11, i16* %1, !dbg !529
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !529
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !529
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !529
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !529
  store i8* %12, i8** %"$array_ptr", !dbg !529
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !529
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !529
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !529
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !529
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !529
  %16 = load i16, i16* %0, !dbg !529
  store i16 %16, i16* %valueStartIndex, !dbg !529
  %17 = load i16, i16* %1, !dbg !529
  store i16 %17, i16* %valueEndIndex, !dbg !529
  store i1 %15, i1* %TryParse.ret, !dbg !529
  %18 = load i1, i1* %TryParse.ret, !dbg !530
  br i1 %18, label %bb4, label %bb2, !dbg !530

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !531

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !532
  %20 = xor i1 %19, true, !dbg !532
  br i1 %20, label %bb7, label %bb5, !dbg !532

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !533
  %21 = load i16, i16* %valueStartIndex, !dbg !533
  %22 = load i16, i16* %valueEndIndex, !dbg !533
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !533
  store %STRING.0 %23, %STRING.0* %4, !dbg !533
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !533
  %24 = load i8, i8* %auto_deref_value.addr, !dbg !533
  store i8 %24, i8* %5, !dbg !533
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !533
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int8@value"(i8* %25, i8* %5), !dbg !533
  %27 = load i8, i8* %5, !dbg !533
  %auto_deref_value.addr2 = load i8*, i8** %value.addr, !dbg !533
  store i8 %27, i8* %auto_deref_value.addr2, !dbg !533
  store i1 %26, i1* %TryParse.ret, !dbg !533
  br label %bb2, !dbg !533

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !534

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !535
  ret i1 %28, !dbg !535

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i8*, i8** %value.addr, !dbg !536
  store i8 0, i8* %auto_deref_value.addr3, !dbg !536
  br label %bb5, !dbg !536
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int8@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i8* %value) !dbg !537 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i8*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !540, metadata !DIExpression()), !dbg !541
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !542, metadata !DIExpression()), !dbg !543
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !544, metadata !DIExpression()), !dbg !545
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !546, metadata !DIExpression()), !dbg !547
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !548, metadata !DIExpression()), !dbg !549
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !550, metadata !DIExpression()), !dbg !545
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i8
  store i8 0, i8* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i8* %value, i8** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !551
  store i16 %4, i16* %0, !dbg !551
  %5 = load i16, i16* %valueEndIndex, !dbg !551
  store i16 %5, i16* %1, !dbg !551
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !551
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !551
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !551
  %8 = load i16, i16* %0, !dbg !551
  store i16 %8, i16* %valueStartIndex, !dbg !551
  %9 = load i16, i16* %1, !dbg !551
  store i16 %9, i16* %valueEndIndex, !dbg !551
  store i1 %7, i1* %TryParse.ret, !dbg !551
  %10 = load i1, i1* %TryParse.ret, !dbg !552
  br i1 %10, label %bb4, label %bb2, !dbg !552

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !553

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !554
  %12 = xor i1 %11, true, !dbg !554
  br i1 %12, label %bb7, label %bb5, !dbg !554

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !555
  %13 = load i16, i16* %valueStartIndex, !dbg !555
  %14 = load i16, i16* %valueEndIndex, !dbg !555
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !555
  store %STRING.0 %15, %STRING.0* %2, !dbg !555
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !555
  %16 = load i8, i8* %auto_deref_value.addr, !dbg !555
  store i8 %16, i8* %3, !dbg !555
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !555
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int8@value"(i8* %17, i8* %3), !dbg !555
  %19 = load i8, i8* %3, !dbg !555
  %auto_deref_value.addr2 = load i8*, i8** %value.addr, !dbg !555
  store i8 %19, i8* %auto_deref_value.addr2, !dbg !555
  store i1 %18, i1* %TryParse.ret, !dbg !555
  br label %bb2, !dbg !555

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !556

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !557
  ret i1 %20, !dbg !557

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i8*, i8** %value.addr, !dbg !558
  store i8 0, i8* %auto_deref_value.addr3, !dbg !558
  br label %bb5, !dbg !558
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int64@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i64* %value) !dbg !559 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !565, metadata !DIExpression()), !dbg !566
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !567, metadata !DIExpression()), !dbg !568
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !569, metadata !DIExpression()), !dbg !570
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !571, metadata !DIExpression()), !dbg !572
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !573, metadata !DIExpression()), !dbg !574
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !575, metadata !DIExpression()), !dbg !576
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !577, metadata !DIExpression()), !dbg !570
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i64
  store i64 0, i64* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !570
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !570
  store i64* %value, i64** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !578
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !578
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !578
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !578
  %10 = load i16, i16* %valueStartIndex, !dbg !579
  store i16 %10, i16* %0, !dbg !579
  %11 = load i16, i16* %valueEndIndex, !dbg !579
  store i16 %11, i16* %1, !dbg !579
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !579
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !579
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !579
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !579
  store i8* %12, i8** %"$array_ptr", !dbg !579
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !579
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !579
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !579
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !579
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !579
  %16 = load i16, i16* %0, !dbg !579
  store i16 %16, i16* %valueStartIndex, !dbg !579
  %17 = load i16, i16* %1, !dbg !579
  store i16 %17, i16* %valueEndIndex, !dbg !579
  store i1 %15, i1* %TryParse.ret, !dbg !579
  %18 = load i1, i1* %TryParse.ret, !dbg !580
  br i1 %18, label %bb4, label %bb2, !dbg !580

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !581

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !582
  %20 = xor i1 %19, true, !dbg !582
  br i1 %20, label %bb7, label %bb5, !dbg !582

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !583
  %21 = load i16, i16* %valueStartIndex, !dbg !583
  %22 = load i16, i16* %valueEndIndex, !dbg !583
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !583
  store %STRING.0 %23, %STRING.0* %4, !dbg !583
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !583
  %24 = load i64, i64* %auto_deref_value.addr, !dbg !583
  store i64 %24, i64* %5, !dbg !583
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !583
  %26 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %25, i64* %5), !dbg !583
  %27 = load i64, i64* %5, !dbg !583
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !583
  store i64 %27, i64* %auto_deref_value.addr2, !dbg !583
  store i1 %26, i1* %TryParse.ret, !dbg !583
  br label %bb2, !dbg !583

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !584

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !585
  ret i1 %28, !dbg !585

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !586
  store i64 0, i64* %auto_deref_value.addr3, !dbg !586
  br label %bb5, !dbg !586
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int64@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i64* %value) !dbg !587 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i64*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !590, metadata !DIExpression()), !dbg !591
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !592, metadata !DIExpression()), !dbg !593
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !594, metadata !DIExpression()), !dbg !595
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !596, metadata !DIExpression()), !dbg !597
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !598, metadata !DIExpression()), !dbg !599
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !600, metadata !DIExpression()), !dbg !595
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i64
  store i64 0, i64* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i64* %value, i64** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !601
  store i16 %4, i16* %0, !dbg !601
  %5 = load i16, i16* %valueEndIndex, !dbg !601
  store i16 %5, i16* %1, !dbg !601
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !601
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !601
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !601
  %8 = load i16, i16* %0, !dbg !601
  store i16 %8, i16* %valueStartIndex, !dbg !601
  %9 = load i16, i16* %1, !dbg !601
  store i16 %9, i16* %valueEndIndex, !dbg !601
  store i1 %7, i1* %TryParse.ret, !dbg !601
  %10 = load i1, i1* %TryParse.ret, !dbg !602
  br i1 %10, label %bb4, label %bb2, !dbg !602

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !603

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !604
  %12 = xor i1 %11, true, !dbg !604
  br i1 %12, label %bb7, label %bb5, !dbg !604

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !605
  %13 = load i16, i16* %valueStartIndex, !dbg !605
  %14 = load i16, i16* %valueEndIndex, !dbg !605
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !605
  store %STRING.0 %15, %STRING.0* %2, !dbg !605
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !605
  %16 = load i64, i64* %auto_deref_value.addr, !dbg !605
  store i64 %16, i64* %3, !dbg !605
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !605
  %18 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %17, i64* %3), !dbg !605
  %19 = load i64, i64* %3, !dbg !605
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !605
  store i64 %19, i64* %auto_deref_value.addr2, !dbg !605
  store i1 %18, i1* %TryParse.ret, !dbg !605
  br label %bb2, !dbg !605

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !606

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !607
  ret i1 %20, !dbg !607

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !608
  store i64 0, i64* %auto_deref_value.addr3, !dbg !608
  br label %bb5, !dbg !608
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int32@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i32* %value) !dbg !609 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i32*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !613, metadata !DIExpression()), !dbg !614
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !615, metadata !DIExpression()), !dbg !616
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !617, metadata !DIExpression()), !dbg !618
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !619, metadata !DIExpression()), !dbg !620
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !621, metadata !DIExpression()), !dbg !622
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !623, metadata !DIExpression()), !dbg !624
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !625, metadata !DIExpression()), !dbg !618
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i32
  store i32 0, i32* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !618
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !618
  store i32* %value, i32** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !626
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !626
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !626
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !626
  %10 = load i16, i16* %valueStartIndex, !dbg !627
  store i16 %10, i16* %0, !dbg !627
  %11 = load i16, i16* %valueEndIndex, !dbg !627
  store i16 %11, i16* %1, !dbg !627
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !627
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !627
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !627
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !627
  store i8* %12, i8** %"$array_ptr", !dbg !627
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !627
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !627
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !627
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !627
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !627
  %16 = load i16, i16* %0, !dbg !627
  store i16 %16, i16* %valueStartIndex, !dbg !627
  %17 = load i16, i16* %1, !dbg !627
  store i16 %17, i16* %valueEndIndex, !dbg !627
  store i1 %15, i1* %TryParse.ret, !dbg !627
  %18 = load i1, i1* %TryParse.ret, !dbg !628
  br i1 %18, label %bb4, label %bb2, !dbg !628

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !629

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !630
  %20 = xor i1 %19, true, !dbg !630
  br i1 %20, label %bb7, label %bb5, !dbg !630

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !631
  %21 = load i16, i16* %valueStartIndex, !dbg !631
  %22 = load i16, i16* %valueEndIndex, !dbg !631
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !631
  store %STRING.0 %23, %STRING.0* %4, !dbg !631
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !631
  %24 = load i32, i32* %auto_deref_value.addr, !dbg !631
  store i32 %24, i32* %5, !dbg !631
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !631
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int32@value"(i8* %25, i32* %5), !dbg !631
  %27 = load i32, i32* %5, !dbg !631
  %auto_deref_value.addr2 = load i32*, i32** %value.addr, !dbg !631
  store i32 %27, i32* %auto_deref_value.addr2, !dbg !631
  store i1 %26, i1* %TryParse.ret, !dbg !631
  br label %bb2, !dbg !631

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !632

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !633
  ret i1 %28, !dbg !633

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i32*, i32** %value.addr, !dbg !634
  store i32 0, i32* %auto_deref_value.addr3, !dbg !634
  br label %bb5, !dbg !634
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int32@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i32* %value) !dbg !635 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i32*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !638, metadata !DIExpression()), !dbg !639
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !640, metadata !DIExpression()), !dbg !641
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !642, metadata !DIExpression()), !dbg !643
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !644, metadata !DIExpression()), !dbg !645
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !646, metadata !DIExpression()), !dbg !647
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !648, metadata !DIExpression()), !dbg !643
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i32
  store i32 0, i32* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i32* %value, i32** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !649
  store i16 %4, i16* %0, !dbg !649
  %5 = load i16, i16* %valueEndIndex, !dbg !649
  store i16 %5, i16* %1, !dbg !649
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !649
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !649
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !649
  %8 = load i16, i16* %0, !dbg !649
  store i16 %8, i16* %valueStartIndex, !dbg !649
  %9 = load i16, i16* %1, !dbg !649
  store i16 %9, i16* %valueEndIndex, !dbg !649
  store i1 %7, i1* %TryParse.ret, !dbg !649
  %10 = load i1, i1* %TryParse.ret, !dbg !650
  br i1 %10, label %bb4, label %bb2, !dbg !650

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !651

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !652
  %12 = xor i1 %11, true, !dbg !652
  br i1 %12, label %bb7, label %bb5, !dbg !652

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !653
  %13 = load i16, i16* %valueStartIndex, !dbg !653
  %14 = load i16, i16* %valueEndIndex, !dbg !653
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !653
  store %STRING.0 %15, %STRING.0* %2, !dbg !653
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !653
  %16 = load i32, i32* %auto_deref_value.addr, !dbg !653
  store i32 %16, i32* %3, !dbg !653
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !653
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int32@value"(i8* %17, i32* %3), !dbg !653
  %19 = load i32, i32* %3, !dbg !653
  %auto_deref_value.addr2 = load i32*, i32** %value.addr, !dbg !653
  store i32 %19, i32* %auto_deref_value.addr2, !dbg !653
  store i1 %18, i1* %TryParse.ret, !dbg !653
  br label %bb2, !dbg !653

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !654

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !655
  ret i1 %20, !dbg !655

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i32*, i32** %value.addr, !dbg !656
  store i32 0, i32* %auto_deref_value.addr3, !dbg !656
  br label %bb5, !dbg !656
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int16@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i16* %value) !dbg !657 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i16*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !660, metadata !DIExpression()), !dbg !661
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !662, metadata !DIExpression()), !dbg !663
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !664, metadata !DIExpression()), !dbg !665
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !666, metadata !DIExpression()), !dbg !667
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !668, metadata !DIExpression()), !dbg !669
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !670, metadata !DIExpression()), !dbg !671
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !672, metadata !DIExpression()), !dbg !665
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i16
  store i16 0, i16* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !665
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !665
  store i16* %value, i16** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !673
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !673
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !673
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !673
  %10 = load i16, i16* %valueStartIndex, !dbg !674
  store i16 %10, i16* %0, !dbg !674
  %11 = load i16, i16* %valueEndIndex, !dbg !674
  store i16 %11, i16* %1, !dbg !674
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !674
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !674
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !674
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !674
  store i8* %12, i8** %"$array_ptr", !dbg !674
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !674
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !674
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !674
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !674
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !674
  %16 = load i16, i16* %0, !dbg !674
  store i16 %16, i16* %valueStartIndex, !dbg !674
  %17 = load i16, i16* %1, !dbg !674
  store i16 %17, i16* %valueEndIndex, !dbg !674
  store i1 %15, i1* %TryParse.ret, !dbg !674
  %18 = load i1, i1* %TryParse.ret, !dbg !675
  br i1 %18, label %bb4, label %bb2, !dbg !675

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !676

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !677
  %20 = xor i1 %19, true, !dbg !677
  br i1 %20, label %bb7, label %bb5, !dbg !677

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !678
  %21 = load i16, i16* %valueStartIndex, !dbg !678
  %22 = load i16, i16* %valueEndIndex, !dbg !678
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !678
  store %STRING.0 %23, %STRING.0* %4, !dbg !678
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !678
  %24 = load i16, i16* %auto_deref_value.addr, !dbg !678
  store i16 %24, i16* %5, !dbg !678
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !678
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int16@value"(i8* %25, i16* %5), !dbg !678
  %27 = load i16, i16* %5, !dbg !678
  %auto_deref_value.addr2 = load i16*, i16** %value.addr, !dbg !678
  store i16 %27, i16* %auto_deref_value.addr2, !dbg !678
  store i1 %26, i1* %TryParse.ret, !dbg !678
  br label %bb2, !dbg !678

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !679

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !680
  ret i1 %28, !dbg !680

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i16*, i16** %value.addr, !dbg !681
  store i16 0, i16* %auto_deref_value.addr3, !dbg !681
  br label %bb5, !dbg !681
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i16* %value) !dbg !682 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i16*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !685, metadata !DIExpression()), !dbg !686
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !687, metadata !DIExpression()), !dbg !688
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !689, metadata !DIExpression()), !dbg !690
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !691, metadata !DIExpression()), !dbg !692
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !693, metadata !DIExpression()), !dbg !694
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !695, metadata !DIExpression()), !dbg !690
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i16
  store i16 0, i16* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i16* %value, i16** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !696
  store i16 %4, i16* %0, !dbg !696
  %5 = load i16, i16* %valueEndIndex, !dbg !696
  store i16 %5, i16* %1, !dbg !696
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !696
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !696
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !696
  %8 = load i16, i16* %0, !dbg !696
  store i16 %8, i16* %valueStartIndex, !dbg !696
  %9 = load i16, i16* %1, !dbg !696
  store i16 %9, i16* %valueEndIndex, !dbg !696
  store i1 %7, i1* %TryParse.ret, !dbg !696
  %10 = load i1, i1* %TryParse.ret, !dbg !697
  br i1 %10, label %bb4, label %bb2, !dbg !697

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !698

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !699
  %12 = xor i1 %11, true, !dbg !699
  br i1 %12, label %bb7, label %bb5, !dbg !699

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !700
  %13 = load i16, i16* %valueStartIndex, !dbg !700
  %14 = load i16, i16* %valueEndIndex, !dbg !700
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !700
  store %STRING.0 %15, %STRING.0* %2, !dbg !700
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !700
  %16 = load i16, i16* %auto_deref_value.addr, !dbg !700
  store i16 %16, i16* %3, !dbg !700
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !700
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int16@value"(i8* %17, i16* %3), !dbg !700
  %19 = load i16, i16* %3, !dbg !700
  %auto_deref_value.addr2 = load i16*, i16** %value.addr, !dbg !700
  store i16 %19, i16* %auto_deref_value.addr2, !dbg !700
  store i1 %18, i1* %TryParse.ret, !dbg !700
  br label %bb2, !dbg !700

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !701

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !702
  ret i1 %20, !dbg !702

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i16*, i16** %value.addr, !dbg !703
  store i16 0, i16* %auto_deref_value.addr3, !dbg !703
  br label %bb5, !dbg !703
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt8@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i8* %value) !dbg !704 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i8*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !708, metadata !DIExpression()), !dbg !709
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !710, metadata !DIExpression()), !dbg !711
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !712, metadata !DIExpression()), !dbg !713
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !714, metadata !DIExpression()), !dbg !715
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !716, metadata !DIExpression()), !dbg !717
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !718, metadata !DIExpression()), !dbg !719
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !720, metadata !DIExpression()), !dbg !713
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i8
  store i8 0, i8* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !713
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !713
  store i8* %value, i8** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !721
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !721
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !721
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !721
  %10 = load i16, i16* %valueStartIndex, !dbg !722
  store i16 %10, i16* %0, !dbg !722
  %11 = load i16, i16* %valueEndIndex, !dbg !722
  store i16 %11, i16* %1, !dbg !722
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !722
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !722
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !722
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !722
  store i8* %12, i8** %"$array_ptr", !dbg !722
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !722
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !722
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !722
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !722
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !722
  %16 = load i16, i16* %0, !dbg !722
  store i16 %16, i16* %valueStartIndex, !dbg !722
  %17 = load i16, i16* %1, !dbg !722
  store i16 %17, i16* %valueEndIndex, !dbg !722
  store i1 %15, i1* %TryParse.ret, !dbg !722
  %18 = load i1, i1* %TryParse.ret, !dbg !723
  br i1 %18, label %bb4, label %bb2, !dbg !723

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !724

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !725
  %20 = xor i1 %19, true, !dbg !725
  br i1 %20, label %bb7, label %bb5, !dbg !725

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !726
  %21 = load i16, i16* %valueStartIndex, !dbg !726
  %22 = load i16, i16* %valueEndIndex, !dbg !726
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !726
  store %STRING.0 %23, %STRING.0* %4, !dbg !726
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !726
  %24 = load i8, i8* %auto_deref_value.addr, !dbg !726
  store i8 %24, i8* %5, !dbg !726
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !726
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt8@value"(i8* %25, i8* %5), !dbg !726
  %27 = load i8, i8* %5, !dbg !726
  %auto_deref_value.addr2 = load i8*, i8** %value.addr, !dbg !726
  store i8 %27, i8* %auto_deref_value.addr2, !dbg !726
  store i1 %26, i1* %TryParse.ret, !dbg !726
  br label %bb2, !dbg !726

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !727

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !728
  ret i1 %28, !dbg !728

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i8*, i8** %value.addr, !dbg !729
  store i8 0, i8* %auto_deref_value.addr3, !dbg !729
  br label %bb5, !dbg !729
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt8@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i8* %value) !dbg !730 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i8*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !733, metadata !DIExpression()), !dbg !734
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !735, metadata !DIExpression()), !dbg !736
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !737, metadata !DIExpression()), !dbg !738
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !739, metadata !DIExpression()), !dbg !740
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !741, metadata !DIExpression()), !dbg !742
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !743, metadata !DIExpression()), !dbg !738
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i8
  store i8 0, i8* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i8* %value, i8** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !744
  store i16 %4, i16* %0, !dbg !744
  %5 = load i16, i16* %valueEndIndex, !dbg !744
  store i16 %5, i16* %1, !dbg !744
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !744
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !744
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !744
  %8 = load i16, i16* %0, !dbg !744
  store i16 %8, i16* %valueStartIndex, !dbg !744
  %9 = load i16, i16* %1, !dbg !744
  store i16 %9, i16* %valueEndIndex, !dbg !744
  store i1 %7, i1* %TryParse.ret, !dbg !744
  %10 = load i1, i1* %TryParse.ret, !dbg !745
  br i1 %10, label %bb4, label %bb2, !dbg !745

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !746

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !747
  %12 = xor i1 %11, true, !dbg !747
  br i1 %12, label %bb7, label %bb5, !dbg !747

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !748
  %13 = load i16, i16* %valueStartIndex, !dbg !748
  %14 = load i16, i16* %valueEndIndex, !dbg !748
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !748
  store %STRING.0 %15, %STRING.0* %2, !dbg !748
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !748
  %16 = load i8, i8* %auto_deref_value.addr, !dbg !748
  store i8 %16, i8* %3, !dbg !748
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !748
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt8@value"(i8* %17, i8* %3), !dbg !748
  %19 = load i8, i8* %3, !dbg !748
  %auto_deref_value.addr2 = load i8*, i8** %value.addr, !dbg !748
  store i8 %19, i8* %auto_deref_value.addr2, !dbg !748
  store i1 %18, i1* %TryParse.ret, !dbg !748
  br label %bb2, !dbg !748

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !749

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !750
  ret i1 %20, !dbg !750

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i8*, i8** %value.addr, !dbg !751
  store i8 0, i8* %auto_deref_value.addr3, !dbg !751
  br label %bb5, !dbg !751
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt16@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i16* %value) !dbg !752 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i16*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !757, metadata !DIExpression()), !dbg !758
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !759, metadata !DIExpression()), !dbg !760
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !761, metadata !DIExpression()), !dbg !762
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !763, metadata !DIExpression()), !dbg !764
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !765, metadata !DIExpression()), !dbg !766
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !767, metadata !DIExpression()), !dbg !768
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !769, metadata !DIExpression()), !dbg !762
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i16
  store i16 0, i16* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !762
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !762
  store i16* %value, i16** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !770
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !770
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !770
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !770
  %10 = load i16, i16* %valueStartIndex, !dbg !771
  store i16 %10, i16* %0, !dbg !771
  %11 = load i16, i16* %valueEndIndex, !dbg !771
  store i16 %11, i16* %1, !dbg !771
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !771
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !771
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !771
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !771
  store i8* %12, i8** %"$array_ptr", !dbg !771
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !771
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !771
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !771
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !771
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !771
  %16 = load i16, i16* %0, !dbg !771
  store i16 %16, i16* %valueStartIndex, !dbg !771
  %17 = load i16, i16* %1, !dbg !771
  store i16 %17, i16* %valueEndIndex, !dbg !771
  store i1 %15, i1* %TryParse.ret, !dbg !771
  %18 = load i1, i1* %TryParse.ret, !dbg !772
  br i1 %18, label %bb4, label %bb2, !dbg !772

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !773

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !774
  %20 = xor i1 %19, true, !dbg !774
  br i1 %20, label %bb7, label %bb5, !dbg !774

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !775
  %21 = load i16, i16* %valueStartIndex, !dbg !775
  %22 = load i16, i16* %valueEndIndex, !dbg !775
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !775
  store %STRING.0 %23, %STRING.0* %4, !dbg !775
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !775
  %24 = load i16, i16* %auto_deref_value.addr, !dbg !775
  store i16 %24, i16* %5, !dbg !775
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !775
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt16@value"(i8* %25, i16* %5), !dbg !775
  %27 = load i16, i16* %5, !dbg !775
  %auto_deref_value.addr2 = load i16*, i16** %value.addr, !dbg !775
  store i16 %27, i16* %auto_deref_value.addr2, !dbg !775
  store i1 %26, i1* %TryParse.ret, !dbg !775
  br label %bb2, !dbg !775

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !776

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !777
  ret i1 %28, !dbg !777

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i16*, i16** %value.addr, !dbg !778
  store i16 0, i16* %auto_deref_value.addr3, !dbg !778
  br label %bb5, !dbg !778
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt16@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i16* %value) !dbg !779 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i16*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !782, metadata !DIExpression()), !dbg !783
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !784, metadata !DIExpression()), !dbg !785
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !786, metadata !DIExpression()), !dbg !787
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !788, metadata !DIExpression()), !dbg !789
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !790, metadata !DIExpression()), !dbg !791
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !792, metadata !DIExpression()), !dbg !787
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i16
  store i16 0, i16* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i16* %value, i16** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !793
  store i16 %4, i16* %0, !dbg !793
  %5 = load i16, i16* %valueEndIndex, !dbg !793
  store i16 %5, i16* %1, !dbg !793
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !793
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !793
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !793
  %8 = load i16, i16* %0, !dbg !793
  store i16 %8, i16* %valueStartIndex, !dbg !793
  %9 = load i16, i16* %1, !dbg !793
  store i16 %9, i16* %valueEndIndex, !dbg !793
  store i1 %7, i1* %TryParse.ret, !dbg !793
  %10 = load i1, i1* %TryParse.ret, !dbg !794
  br i1 %10, label %bb4, label %bb2, !dbg !794

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !795

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !796
  %12 = xor i1 %11, true, !dbg !796
  br i1 %12, label %bb7, label %bb5, !dbg !796

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !797
  %13 = load i16, i16* %valueStartIndex, !dbg !797
  %14 = load i16, i16* %valueEndIndex, !dbg !797
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !797
  store %STRING.0 %15, %STRING.0* %2, !dbg !797
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !797
  %16 = load i16, i16* %auto_deref_value.addr, !dbg !797
  store i16 %16, i16* %3, !dbg !797
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !797
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt16@value"(i8* %17, i16* %3), !dbg !797
  %19 = load i16, i16* %3, !dbg !797
  %auto_deref_value.addr2 = load i16*, i16** %value.addr, !dbg !797
  store i16 %19, i16* %auto_deref_value.addr2, !dbg !797
  store i1 %18, i1* %TryParse.ret, !dbg !797
  br label %bb2, !dbg !797

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !798

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !799
  ret i1 %20, !dbg !799

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i16*, i16** %value.addr, !dbg !800
  store i16 0, i16* %auto_deref_value.addr3, !dbg !800
  br label %bb5, !dbg !800
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt32@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i32* %value) !dbg !801 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i32*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !807, metadata !DIExpression()), !dbg !808
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !809, metadata !DIExpression()), !dbg !810
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !811, metadata !DIExpression()), !dbg !812
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !813, metadata !DIExpression()), !dbg !814
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !815, metadata !DIExpression()), !dbg !816
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !817, metadata !DIExpression()), !dbg !818
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !819, metadata !DIExpression()), !dbg !812
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i32
  store i32 0, i32* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !812
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !812
  store i32* %value, i32** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !820
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !820
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !820
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !820
  %10 = load i16, i16* %valueStartIndex, !dbg !821
  store i16 %10, i16* %0, !dbg !821
  %11 = load i16, i16* %valueEndIndex, !dbg !821
  store i16 %11, i16* %1, !dbg !821
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !821
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !821
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !821
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !821
  store i8* %12, i8** %"$array_ptr", !dbg !821
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !821
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !821
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !821
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !821
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !821
  %16 = load i16, i16* %0, !dbg !821
  store i16 %16, i16* %valueStartIndex, !dbg !821
  %17 = load i16, i16* %1, !dbg !821
  store i16 %17, i16* %valueEndIndex, !dbg !821
  store i1 %15, i1* %TryParse.ret, !dbg !821
  %18 = load i1, i1* %TryParse.ret, !dbg !822
  br i1 %18, label %bb4, label %bb2, !dbg !822

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !823

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !824
  %20 = xor i1 %19, true, !dbg !824
  br i1 %20, label %bb7, label %bb5, !dbg !824

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !825
  %21 = load i16, i16* %valueStartIndex, !dbg !825
  %22 = load i16, i16* %valueEndIndex, !dbg !825
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !825
  store %STRING.0 %23, %STRING.0* %4, !dbg !825
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !825
  %24 = load i32, i32* %auto_deref_value.addr, !dbg !825
  store i32 %24, i32* %5, !dbg !825
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !825
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt32@value"(i8* %25, i32* %5), !dbg !825
  %27 = load i32, i32* %5, !dbg !825
  %auto_deref_value.addr2 = load i32*, i32** %value.addr, !dbg !825
  store i32 %27, i32* %auto_deref_value.addr2, !dbg !825
  store i1 %26, i1* %TryParse.ret, !dbg !825
  br label %bb2, !dbg !825

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !826

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !827
  ret i1 %28, !dbg !827

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i32*, i32** %value.addr, !dbg !828
  store i32 0, i32* %auto_deref_value.addr3, !dbg !828
  br label %bb5, !dbg !828
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt32@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i32* %value) !dbg !829 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i32*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !832, metadata !DIExpression()), !dbg !833
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !834, metadata !DIExpression()), !dbg !835
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !836, metadata !DIExpression()), !dbg !837
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !838, metadata !DIExpression()), !dbg !839
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !840, metadata !DIExpression()), !dbg !841
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !842, metadata !DIExpression()), !dbg !837
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i32
  store i32 0, i32* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i32* %value, i32** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !843
  store i16 %4, i16* %0, !dbg !843
  %5 = load i16, i16* %valueEndIndex, !dbg !843
  store i16 %5, i16* %1, !dbg !843
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !843
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !843
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !843
  %8 = load i16, i16* %0, !dbg !843
  store i16 %8, i16* %valueStartIndex, !dbg !843
  %9 = load i16, i16* %1, !dbg !843
  store i16 %9, i16* %valueEndIndex, !dbg !843
  store i1 %7, i1* %TryParse.ret, !dbg !843
  %10 = load i1, i1* %TryParse.ret, !dbg !844
  br i1 %10, label %bb4, label %bb2, !dbg !844

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !845

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !846
  %12 = xor i1 %11, true, !dbg !846
  br i1 %12, label %bb7, label %bb5, !dbg !846

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !847
  %13 = load i16, i16* %valueStartIndex, !dbg !847
  %14 = load i16, i16* %valueEndIndex, !dbg !847
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !847
  store %STRING.0 %15, %STRING.0* %2, !dbg !847
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !847
  %16 = load i32, i32* %auto_deref_value.addr, !dbg !847
  store i32 %16, i32* %3, !dbg !847
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !847
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt32@value"(i8* %17, i32* %3), !dbg !847
  %19 = load i32, i32* %3, !dbg !847
  %auto_deref_value.addr2 = load i32*, i32** %value.addr, !dbg !847
  store i32 %19, i32* %auto_deref_value.addr2, !dbg !847
  store i1 %18, i1* %TryParse.ret, !dbg !847
  br label %bb2, !dbg !847

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !848

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !849
  ret i1 %20, !dbg !849

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i32*, i32** %value.addr, !dbg !850
  store i32 0, i32* %auto_deref_value.addr3, !dbg !850
  br label %bb5, !dbg !850
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt64@value"(%Simatic.Ax.Json.Deserializer* %this, i8* %key, i64* %value) !dbg !851 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %key.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %keyArray = alloca [1 x %STRING.0]
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %key.addr, metadata !857, metadata !DIExpression()), !dbg !858
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !859, metadata !DIExpression()), !dbg !860
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !861, metadata !DIExpression()), !dbg !862
  call void @llvm.dbg.declare(metadata [1 x %STRING.0]* %keyArray, metadata !863, metadata !DIExpression()), !dbg !864
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !865, metadata !DIExpression()), !dbg !866
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !867, metadata !DIExpression()), !dbg !868
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !869, metadata !DIExpression()), !dbg !862
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca %STRING.0
  %5 = alloca i64
  store i64 0, i64* %5
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %key.addr
  %6 = bitcast %STRING.0* %key.addr to i8*, !dbg !862
  call void @"$ax.AssignST_String"(i8* %6, i8* %key), !dbg !862
  store i64* %value, i64** %value.addr
  store [1 x %STRING.0] [%STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }], [1 x %STRING.0]* %keyArray
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds [1 x %STRING.0], [1 x %STRING.0]* %keyArray, i32 0, i32 0, !dbg !870
  %8 = bitcast %STRING.0* %7 to i8*, !dbg !870
  %9 = bitcast %STRING.0* %key.addr to i8*, !dbg !870
  call void @"$ax.AssignST_String"(i8* %8, i8* %9), !dbg !870
  %10 = load i16, i16* %valueStartIndex, !dbg !871
  store i16 %10, i16* %0, !dbg !871
  %11 = load i16, i16* %valueEndIndex, !dbg !871
  store i16 %11, i16* %1, !dbg !871
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !871
  %12 = bitcast [1 x %STRING.0]* %keyArray to i8*, !dbg !871
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3, !dbg !871
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0, !dbg !871
  store i8* %12, i8** %"$array_ptr", !dbg !871
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2, !dbg !871
  %13 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*, !dbg !871
  store %"$ax.ArrayBounds"* %13, %"$ax.ArrayBounds"** %"$bounds", !dbg !871
  %14 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, !dbg !871
  %15 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %14, i16* %0, i16* %1), !dbg !871
  %16 = load i16, i16* %0, !dbg !871
  store i16 %16, i16* %valueStartIndex, !dbg !871
  %17 = load i16, i16* %1, !dbg !871
  store i16 %17, i16* %valueEndIndex, !dbg !871
  store i1 %15, i1* %TryParse.ret, !dbg !871
  %18 = load i1, i1* %TryParse.ret, !dbg !872
  br i1 %18, label %bb4, label %bb2, !dbg !872

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !873

bb3:                                              ; preds = %bb2
  %19 = load i1, i1* %TryParse.ret, !dbg !874
  %20 = xor i1 %19, true, !dbg !874
  br i1 %20, label %bb7, label %bb5, !dbg !874

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !875
  %21 = load i16, i16* %valueStartIndex, !dbg !875
  %22 = load i16, i16* %valueEndIndex, !dbg !875
  %23 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %21, i16 %22), !dbg !875
  store %STRING.0 %23, %STRING.0* %4, !dbg !875
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !875
  %24 = load i64, i64* %auto_deref_value.addr, !dbg !875
  store i64 %24, i64* %5, !dbg !875
  %25 = bitcast %STRING.0* %4 to i8*, !dbg !875
  %26 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt64@value"(i8* %25, i64* %5), !dbg !875
  %27 = load i64, i64* %5, !dbg !875
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !875
  store i64 %27, i64* %auto_deref_value.addr2, !dbg !875
  store i1 %26, i1* %TryParse.ret, !dbg !875
  br label %bb2, !dbg !875

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !876

bb6:                                              ; preds = %bb5
  %28 = load i1, i1* %TryParse.ret, !dbg !877
  ret i1 %28, !dbg !877

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !878
  store i64 0, i64* %auto_deref_value.addr3, !dbg !878
  br label %bb5, !dbg !878
}

define i1 @"Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt64@value"(%Simatic.Ax.Json.Deserializer* %this, %"$ax.ArrayWithBound" %keyArray, i64* %value) !dbg !879 {
Entry:
  %TryParse.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.Deserializer*
  %keyArray.addr = alloca %"$ax.ArrayWithBound"
  %value.addr = alloca i64*
  %valueStartIndex = alloca i16
  %valueEndIndex = alloca i16
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %keyArray.addr, metadata !882, metadata !DIExpression()), !dbg !883
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !884, metadata !DIExpression()), !dbg !885
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.Deserializer** %this.addr, metadata !886, metadata !DIExpression()), !dbg !887
  call void @llvm.dbg.declare(metadata i16* %valueStartIndex, metadata !888, metadata !DIExpression()), !dbg !889
  call void @llvm.dbg.declare(metadata i16* %valueEndIndex, metadata !890, metadata !DIExpression()), !dbg !891
  call void @llvm.dbg.declare(metadata i1* %TryParse.ret, metadata !892, metadata !DIExpression()), !dbg !887
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca i16
  store i16 0, i16* %1
  %2 = alloca %STRING.0
  %3 = alloca i64
  store i64 0, i64* %3
  store i1 false, i1* %TryParse.ret
  store %Simatic.Ax.Json.Deserializer* %this, %Simatic.Ax.Json.Deserializer** %this.addr
  store %"$ax.ArrayWithBound" %keyArray, %"$ax.ArrayWithBound"* %keyArray.addr
  store i64* %value, i64** %value.addr
  store i16 0, i16* %valueStartIndex
  store i16 0, i16* %valueEndIndex
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i16, i16* %valueStartIndex, !dbg !893
  store i16 %4, i16* %0, !dbg !893
  %5 = load i16, i16* %valueEndIndex, !dbg !893
  store i16 %5, i16* %1, !dbg !893
  %auto_deref_this.addr = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !893
  %6 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %keyArray.addr, !dbg !893
  %7 = call i1 @"Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr, %"$ax.ArrayWithBound" %6, i16* %0, i16* %1), !dbg !893
  %8 = load i16, i16* %0, !dbg !893
  store i16 %8, i16* %valueStartIndex, !dbg !893
  %9 = load i16, i16* %1, !dbg !893
  store i16 %9, i16* %valueEndIndex, !dbg !893
  store i1 %7, i1* %TryParse.ret, !dbg !893
  %10 = load i1, i1* %TryParse.ret, !dbg !894
  br i1 %10, label %bb4, label %bb2, !dbg !894

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !895

bb3:                                              ; preds = %bb2
  %11 = load i1, i1* %TryParse.ret, !dbg !896
  %12 = xor i1 %11, true, !dbg !896
  br i1 %12, label %bb7, label %bb5, !dbg !896

bb4:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.Deserializer*, %Simatic.Ax.Json.Deserializer** %this.addr, !dbg !897
  %13 = load i16, i16* %valueStartIndex, !dbg !897
  %14 = load i16, i16* %valueEndIndex, !dbg !897
  %15 = call %STRING.0 @"Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex"(%Simatic.Ax.Json.Deserializer* %auto_deref_this.addr1, i16 %13, i16 %14), !dbg !897
  store %STRING.0 %15, %STRING.0* %2, !dbg !897
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !897
  %16 = load i64, i64* %auto_deref_value.addr, !dbg !897
  store i64 %16, i64* %3, !dbg !897
  %17 = bitcast %STRING.0* %2 to i8*, !dbg !897
  %18 = call i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt64@value"(i8* %17, i64* %3), !dbg !897
  %19 = load i64, i64* %3, !dbg !897
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !897
  store i64 %19, i64* %auto_deref_value.addr2, !dbg !897
  store i1 %18, i1* %TryParse.ret, !dbg !897
  br label %bb2, !dbg !897

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6, !dbg !898

bb6:                                              ; preds = %bb5
  %20 = load i1, i1* %TryParse.ret, !dbg !899
  ret i1 %20, !dbg !899

bb7:                                              ; preds = %bb3
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !900
  store i64 0, i64* %auto_deref_value.addr3, !dbg !900
  br label %bb5, !dbg !900
}

define %STRING.0 @"Simatic.Ax.Json.JsonDocument.ToString$I@R@Simatic.Ax.Json.JsonDocument@this"(%Simatic.Ax.Json.JsonDocument* %this) !dbg !901 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %_str = alloca %STRING.0
  %_to = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %_elem = alloca %Simatic.Ax.Json.IJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !919, metadata !DIExpression()), !dbg !920
  call void @llvm.dbg.declare(metadata %STRING.0* %_str, metadata !921, metadata !DIExpression()), !dbg !922
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_to, metadata !923, metadata !DIExpression()), !dbg !924
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %_elem, metadata !925, metadata !DIExpression()), !dbg !926
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !927, metadata !DIExpression()), !dbg !920
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %0
  %1 = alloca %STRING.0
  %2 = alloca %STRING.0
  %3 = alloca %STRING.0
  %4 = alloca %STRING.0
  %5 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %5
  %6 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_str
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_to
  store %Simatic.Ax.Json.IJsonElement* null, %Simatic.Ax.Json.IJsonElement** %_elem
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2, i32 0, !dbg !928
  store i8 123, i8* %7, !dbg !928
  %8 = bitcast %STRING.0* %_str to i8*, !dbg !928
  %9 = bitcast %STRING.0* %0 to i8*, !dbg !928
  %10 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %8, i8* %9), !dbg !928
  store %STRING.0 %10, %STRING.0* %1, !dbg !928
  %11 = bitcast %STRING.0* %_str to i8*, !dbg !928
  %12 = bitcast %STRING.0* %1 to i8*, !dbg !928
  call void @"$ax.AssignST_String"(i8* %11, i8* %12), !dbg !928
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !929
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 2, !dbg !929
  %13 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !929
  %14 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %13 to i8**, !dbg !929
  %15 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %14), !dbg !929
  %16 = bitcast i8** %15 to %Simatic.Ax.Json.IJsonElement*, !dbg !929
  store %Simatic.Ax.Json.IJsonElement* %16, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !929
  %17 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !930
  %18 = bitcast %Simatic.Ax.Json.IJsonElement* %17 to i8**, !dbg !930
  %19 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %18), !dbg !930
  %20 = bitcast i8** %19 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !930
  store %Simatic.Ax.Json.IJsonElementMuteable* %20, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !930
  br label %bb2, !dbg !930

bb2:                                              ; preds = %bb7, %bb1
  %21 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !931
  %22 = bitcast %Simatic.Ax.Json.IJsonElement* %21 to i8**, !dbg !931
  %23 = call i16 @"$ax.ref_equals_interfaces"(i8** %22, i8** null), !dbg !931
  %24 = icmp ne i16 %23, 1, !dbg !931
  br i1 %24, label %bb3, label %bb4, !dbg !931

bb3:                                              ; preds = %bb2
  %25 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !932
  %26 = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %25, i32 0, i32 0, !dbg !932
  %27 = load i8*, i8** %26, !dbg !932
  %28 = bitcast i8* %27 to %Simatic.Ax.Json.IJsonElement*, !dbg !932
  %"$vTable" = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %28, i32 0, i32 1, !dbg !932
  %29 = getelementptr inbounds [2 x i8*], [2 x i8*]* %"$vTable", i32 0, i32 1, !dbg !932
  %30 = load i8*, i8** %29, !dbg !932
  %31 = bitcast i8* %30 to %STRING.0 (%Simatic.Ax.Json.IJsonElement*)*, !dbg !932
  %32 = call %STRING.0 %31(%Simatic.Ax.Json.IJsonElement* %25), !dbg !932
  store %STRING.0 %32, %STRING.0* %2, !dbg !932
  %33 = bitcast %STRING.0* %_str to i8*, !dbg !932
  %34 = bitcast %STRING.0* %2 to i8*, !dbg !932
  %35 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %33, i8* %34), !dbg !932
  store %STRING.0 %35, %STRING.0* %3, !dbg !932
  %36 = bitcast %STRING.0* %_str to i8*, !dbg !932
  %37 = bitcast %STRING.0* %3 to i8*, !dbg !932
  call void @"$ax.AssignST_String"(i8* %36, i8* %37), !dbg !932
  %38 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !933
  %39 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %38, i32 0, i32 0, !dbg !933
  %40 = load i8*, i8** %39, !dbg !933
  %41 = bitcast i8* %40 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !933
  %"$vTable1" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %41, i32 0, i32 1, !dbg !933
  %42 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable1", i32 0, i32 1, !dbg !933
  %43 = load i8*, i8** %42, !dbg !933
  %44 = bitcast i8* %43 to %Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)*, !dbg !933
  %45 = call %Simatic.Ax.Json.IJsonElementMuteable* %44(%Simatic.Ax.Json.IJsonElementMuteable* %38), !dbg !933
  store %Simatic.Ax.Json.IJsonElementMuteable* %45, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !933
  %46 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !934
  %47 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %46 to i8**, !dbg !934
  %48 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %47), !dbg !934
  %49 = bitcast i8** %48 to %Simatic.Ax.Json.IJsonElement*, !dbg !934
  store %Simatic.Ax.Json.IJsonElement* %49, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !934
  %50 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !935
  %51 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %50 to i8**, !dbg !935
  %52 = call i16 @"$ax.ref_equals_interfaces"(i8** %51, i8** null), !dbg !935
  %53 = icmp ne i16 %52, 1, !dbg !935
  br i1 %53, label %bb8, label %bb6, !dbg !935

bb4:                                              ; preds = %bb2
  br label %bb5, !dbg !936

bb5:                                              ; preds = %bb4
  %54 = getelementptr inbounds %STRING.0, %STRING.0* %5, i32 0, i32 2, i32 0, !dbg !937
  store i8 125, i8* %54, !dbg !937
  %55 = bitcast %STRING.0* %_str to i8*, !dbg !937
  %56 = bitcast %STRING.0* %5 to i8*, !dbg !937
  %57 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %55, i8* %56), !dbg !937
  store %STRING.0 %57, %STRING.0* %6, !dbg !937
  %58 = bitcast %STRING.0* %_str to i8*, !dbg !937
  %59 = bitcast %STRING.0* %6 to i8*, !dbg !937
  call void @"$ax.AssignST_String"(i8* %58, i8* %59), !dbg !937
  %60 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !938
  %61 = bitcast %STRING.0* %_str to i8*, !dbg !938
  call void @"$ax.AssignST_String"(i8* %60, i8* %61), !dbg !938
  %62 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !939
  ret %STRING.0 %62, !dbg !939

bb6:                                              ; preds = %bb8, %bb3
  br label %bb7, !dbg !940

bb7:                                              ; preds = %bb6
  br label %bb2, !dbg !940

bb8:                                              ; preds = %bb3
  %63 = bitcast %STRING.0* %_str to i8*, !dbg !941
  %64 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %63, i8* getelementptr inbounds (%"STRING[2]", %"STRING[2]"* @"$cStr.29", i32 0, i32 0)), !dbg !941
  store %STRING.0 %64, %STRING.0* %4, !dbg !941
  %65 = bitcast %STRING.0* %_str to i8*, !dbg !941
  %66 = bitcast %STRING.0* %4 to i8*, !dbg !941
  call void @"$ax.AssignST_String"(i8* %65, i8* %66), !dbg !941
  br label %bb6, !dbg !941
}

define i1 @"Simatic.Ax.Json.JsonDocument.Serialize$I@R@Simatic.Ax.Json.JsonDocument@this?I@R@ARRAY [*] OF CHAR@buf"(%Simatic.Ax.Json.JsonDocument* %this, %"$ax.ArrayWithBound"* %buf) !dbg !942 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %buf.addr = alloca %"$ax.ArrayWithBound"*
  %_to = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %_elem = alloca %Simatic.Ax.Json.IJsonElement*
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buf.addr, metadata !946, metadata !DIExpression()), !dbg !947
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !948, metadata !DIExpression()), !dbg !949
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_to, metadata !950, metadata !DIExpression()), !dbg !951
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %_elem, metadata !952, metadata !DIExpression()), !dbg !953
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !954, metadata !DIExpression()), !dbg !949
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  store %"$ax.ArrayWithBound"* %buf, %"$ax.ArrayWithBound"** %buf.addr
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_to
  store %Simatic.Ax.Json.IJsonElement* null, %Simatic.Ax.Json.IJsonElement** %_elem
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_buf.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buf.addr, !dbg !955
  %0 = call i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* %auto_deref_buf.addr, i32 1), !dbg !955
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !955
  %_bufLowerBound = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 6, !dbg !955
  store i32 %0, i32* %_bufLowerBound, !dbg !955
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !956
  %_bufLowerBound2 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr1, i32 0, i32 6, !dbg !956
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !956
  %_bufIndex = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr3, i32 0, i32 7, !dbg !956
  %1 = load i32, i32* %_bufLowerBound2, !dbg !956
  store i32 %1, i32* %_bufIndex, !dbg !956
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !957
  %2 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr4, i32 0, i32 0, !dbg !957
  %3 = load i8*, i8** %2, !dbg !957
  %4 = bitcast i8* %3 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !957
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %4, i32 0, i32 4, !dbg !957
  %5 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 0, !dbg !957
  %6 = load i8*, i8** %5, !dbg !957
  %7 = bitcast i8* %6 to i1 (%Simatic.Ax.Json.JsonDocument*, i8)*, !dbg !957
  %8 = call i1 %7(%Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr4, i8 123), !dbg !957
  %auto_deref_this.addr5 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !958
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr5, i32 0, i32 2, !dbg !958
  %9 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !958
  %10 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %9 to i8**, !dbg !958
  %11 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %10), !dbg !958
  %12 = bitcast i8** %11 to %Simatic.Ax.Json.IJsonElement*, !dbg !958
  store %Simatic.Ax.Json.IJsonElement* %12, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !958
  %13 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !959
  %14 = bitcast %Simatic.Ax.Json.IJsonElement* %13 to i8**, !dbg !959
  %15 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %14), !dbg !959
  %16 = bitcast i8** %15 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !959
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !959
  br label %bb2, !dbg !959

bb2:                                              ; preds = %bb7, %bb1
  %17 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !960
  %18 = bitcast %Simatic.Ax.Json.IJsonElement* %17 to i8**, !dbg !960
  %19 = call i16 @"$ax.ref_equals_interfaces"(i8** %18, i8** null), !dbg !960
  %20 = icmp ne i16 %19, 1, !dbg !960
  br i1 %20, label %bb3, label %bb4, !dbg !960

bb3:                                              ; preds = %bb2
  %auto_deref_this.addr6 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !961
  %21 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !961
  %22 = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %21, i32 0, i32 0, !dbg !961
  %23 = load i8*, i8** %22, !dbg !961
  %24 = bitcast i8* %23 to %Simatic.Ax.Json.IJsonElement*, !dbg !961
  %"$vTable7" = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %24, i32 0, i32 1, !dbg !961
  %25 = getelementptr inbounds [2 x i8*], [2 x i8*]* %"$vTable7", i32 0, i32 0, !dbg !961
  %26 = load i8*, i8** %25, !dbg !961
  %27 = bitcast i8* %26 to i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)*, !dbg !961
  %28 = call i1 %27(%Simatic.Ax.Json.IJsonElement* %21, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr6), !dbg !961
  %29 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !962
  %30 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %29, i32 0, i32 0, !dbg !962
  %31 = load i8*, i8** %30, !dbg !962
  %32 = bitcast i8* %31 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !962
  %"$vTable8" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %32, i32 0, i32 1, !dbg !962
  %33 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable8", i32 0, i32 1, !dbg !962
  %34 = load i8*, i8** %33, !dbg !962
  %35 = bitcast i8* %34 to %Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)*, !dbg !962
  %36 = call %Simatic.Ax.Json.IJsonElementMuteable* %35(%Simatic.Ax.Json.IJsonElementMuteable* %29), !dbg !962
  store %Simatic.Ax.Json.IJsonElementMuteable* %36, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !962
  %37 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !963
  %38 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %37 to i8**, !dbg !963
  %39 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %38), !dbg !963
  %40 = bitcast i8** %39 to %Simatic.Ax.Json.IJsonElement*, !dbg !963
  store %Simatic.Ax.Json.IJsonElement* %40, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !963
  %41 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !964
  %42 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %41 to i8**, !dbg !964
  %43 = call i16 @"$ax.ref_equals_interfaces"(i8** %42, i8** null), !dbg !964
  %44 = icmp ne i16 %43, 1, !dbg !964
  br i1 %44, label %bb8, label %bb6, !dbg !964

bb4:                                              ; preds = %bb2
  br label %bb5, !dbg !965

bb5:                                              ; preds = %bb4
  %auto_deref_this.addr11 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !966
  %45 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr11, i32 0, i32 0, !dbg !966
  %46 = load i8*, i8** %45, !dbg !966
  %47 = bitcast i8* %46 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !966
  %"$vTable12" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %47, i32 0, i32 4, !dbg !966
  %48 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable12", i32 0, i32 0, !dbg !966
  %49 = load i8*, i8** %48, !dbg !966
  %50 = bitcast i8* %49 to i1 (%Simatic.Ax.Json.JsonDocument*, i8)*, !dbg !966
  %51 = call i1 %50(%Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr11, i8 125), !dbg !966
  store i1 true, i1* %Serialize.ret, !dbg !967
  %52 = load i1, i1* %Serialize.ret, !dbg !968
  ret i1 %52, !dbg !968

bb6:                                              ; preds = %bb8, %bb3
  br label %bb7, !dbg !969

bb7:                                              ; preds = %bb6
  br label %bb2, !dbg !969

bb8:                                              ; preds = %bb3
  %auto_deref_this.addr9 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !970
  %53 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr9, i32 0, i32 0, !dbg !970
  %54 = load i8*, i8** %53, !dbg !970
  %55 = bitcast i8* %54 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !970
  %"$vTable10" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %55, i32 0, i32 4, !dbg !970
  %56 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable10", i32 0, i32 2, !dbg !970
  %57 = load i8*, i8** %56, !dbg !970
  %58 = bitcast i8* %57 to i1 (%Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !970
  %59 = call i1 %58(%Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr9, i8* getelementptr inbounds (%"STRING[2]", %"STRING[2]"* @"$cStr.30", i32 0, i32 0)), !dbg !970
  br label %bb6, !dbg !970
}

define i1 @"Simatic.Ax.Json.JsonDocument.AddChar$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@Char@c"(%Simatic.Ax.Json.JsonDocument* %this, i8 %c) !dbg !971 {
Entry:
  %AddChar.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %c.addr = alloca i8
  call void @llvm.dbg.declare(metadata i8* %c.addr, metadata !974, metadata !DIExpression()), !dbg !975
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !976, metadata !DIExpression()), !dbg !977
  call void @llvm.dbg.declare(metadata i1* %AddChar.ret, metadata !978, metadata !DIExpression()), !dbg !977
  store i1 false, i1* %AddChar.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  store i8 %c, i8* %c.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !979
  %buffer = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 1, !dbg !979
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !979
  %_bufIndex = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr1, i32 0, i32 7, !dbg !979
  %0 = load i32, i32* %_bufIndex, !dbg !979
  %1 = sub i32 %0, 0, !dbg !979
  %2 = getelementptr inbounds [1000 x i8], [1000 x i8]* %buffer, i32 0, i32 %1, !dbg !979
  %3 = load i8, i8* %c.addr, !dbg !979
  store i8 %3, i8* %2, !dbg !979
  %auto_deref_this.addr2 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !980
  %_bufIndex3 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr2, i32 0, i32 7, !dbg !980
  %4 = load i32, i32* %_bufIndex3, !dbg !980
  %5 = add i32 %4, 1, !dbg !980
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !980
  %_bufIndex5 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr4, i32 0, i32 7, !dbg !980
  store i32 %5, i32* %_bufIndex5, !dbg !980
  %auto_deref_this.addr6 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !981
  %_lentgh = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr6, i32 0, i32 5, !dbg !981
  %6 = load i32, i32* %_lentgh, !dbg !981
  %7 = add i32 %6, 1, !dbg !981
  %auto_deref_this.addr7 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !981
  %_lentgh8 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr7, i32 0, i32 5, !dbg !981
  store i32 %7, i32* %_lentgh8, !dbg !981
  store i1 true, i1* %AddChar.ret, !dbg !982
  %8 = load i1, i1* %AddChar.ret, !dbg !983
  ret i1 %8, !dbg !983
}

define i1 @"Simatic.Ax.Json.JsonDocument.AddString$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@STRING@s"(%Simatic.Ax.Json.JsonDocument* %this, i8* %s) !dbg !984 {
Entry:
  %AddString.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %s.addr = alloca %STRING.0
  %i = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %s.addr, metadata !987, metadata !DIExpression()), !dbg !988
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !989, metadata !DIExpression()), !dbg !990
  call void @llvm.dbg.declare(metadata i16* %i, metadata !991, metadata !DIExpression()), !dbg !992
  call void @llvm.dbg.declare(metadata i1* %AddString.ret, metadata !993, metadata !DIExpression()), !dbg !990
  %0 = alloca i16
  store i16 0, i16* %0
  store i1 false, i1* %AddString.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %s.addr
  %1 = bitcast %STRING.0* %s.addr to i8*, !dbg !990
  call void @"$ax.AssignST_String"(i8* %1, i8* %s), !dbg !990
  store i16 0, i16* %i
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %STRING.0* %s.addr to i8*, !dbg !994
  %3 = call i16 @ax_LenST_String(i8* %2), !dbg !994
  store i16 %3, i16* %0, !dbg !994
  store i16 1, i16* %i, !dbg !995
  br label %bb4, !dbg !996

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !997

bb3:                                              ; preds = %bb2
  store i1 true, i1* %AddString.ret, !dbg !998
  %4 = load i1, i1* %AddString.ret, !dbg !999
  ret i1 %4, !dbg !999

bb4:                                              ; preds = %bb5, %bb1
  %5 = load i16, i16* %i, !dbg !996
  %6 = load i16, i16* %0, !dbg !996
  %7 = icmp sgt i16 %5, %6, !dbg !996
  br i1 %7, label %bb2, label %bb6, !dbg !996

bb5:                                              ; preds = %bb6
  %8 = load i16, i16* %i, !dbg !996
  %9 = add i16 %8, 1, !dbg !996
  store i16 %9, i16* %i, !dbg !996
  br label %bb4, !dbg !996

bb6:                                              ; preds = %bb4
  %10 = load i16, i16* %i, !dbg !1000
  %11 = trunc i16 %10 to i8, !dbg !1000
  %12 = bitcast %STRING.0* %s.addr to i8*, !dbg !1000
  %13 = call i8 @"$ax.GetAtST_String"(i8* %12, i8 %11), !dbg !1000
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1000
  %buffer = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 1, !dbg !1000
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1000
  %_bufIndex = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr1, i32 0, i32 7, !dbg !1000
  %14 = load i32, i32* %_bufIndex, !dbg !1000
  %15 = sub i32 %14, 0, !dbg !1000
  %16 = getelementptr inbounds [1000 x i8], [1000 x i8]* %buffer, i32 0, i32 %15, !dbg !1000
  store i8 %13, i8* %16, !dbg !1000
  %auto_deref_this.addr2 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1001
  %_bufIndex3 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr2, i32 0, i32 7, !dbg !1001
  %17 = load i32, i32* %_bufIndex3, !dbg !1001
  %18 = add i32 %17, 1, !dbg !1001
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1001
  %_bufIndex5 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr4, i32 0, i32 7, !dbg !1001
  store i32 %18, i32* %_bufIndex5, !dbg !1001
  %auto_deref_this.addr6 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1002
  %_lentgh = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr6, i32 0, i32 5, !dbg !1002
  %19 = load i32, i32* %_lentgh, !dbg !1002
  %20 = add i32 %19, 1, !dbg !1002
  %auto_deref_this.addr7 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1002
  %_lentgh8 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr7, i32 0, i32 5, !dbg !1002
  store i32 %20, i32* %_lentgh8, !dbg !1002
  br label %bb5, !dbg !996
}

define i32 @"Simatic.Ax.Json.JsonDocument.GetLength$I@R@Simatic.Ax.Json.JsonDocument@this"(%Simatic.Ax.Json.JsonDocument* %this) !dbg !1003 {
Entry:
  %GetLength.ret = alloca i32
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !1006, metadata !DIExpression()), !dbg !1007
  call void @llvm.dbg.declare(metadata i32* %GetLength.ret, metadata !1008, metadata !DIExpression()), !dbg !1007
  store i32 0, i32* %GetLength.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1009
  %_lentgh = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 5, !dbg !1009
  %0 = load i32, i32* %_lentgh, !dbg !1009
  store i32 %0, i32* %GetLength.ret, !dbg !1009
  %1 = load i32, i32* %GetLength.ret, !dbg !1010
  ret i32 %1, !dbg !1010
}

define %Simatic.Ax.Json.IJsonElement* @"Simatic.Ax.Json.JsonDocument.GetRootElement$I@R@Simatic.Ax.Json.JsonDocument@this"(%Simatic.Ax.Json.JsonDocument* %this) !dbg !1011 {
Entry:
  %GetRootElement.ret = alloca %Simatic.Ax.Json.IJsonElement*
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !1014, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %GetRootElement.ret, metadata !1016, metadata !DIExpression()), !dbg !1015
  store %Simatic.Ax.Json.IJsonElement* null, %Simatic.Ax.Json.IJsonElement** %GetRootElement.ret
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1017
  %_rootElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 4, !dbg !1017
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_rootElement, !dbg !1017
  store %Simatic.Ax.Json.IJsonElement* %0, %Simatic.Ax.Json.IJsonElement** %GetRootElement.ret, !dbg !1017
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %GetRootElement.ret, !dbg !1018
  ret %Simatic.Ax.Json.IJsonElement* %1, !dbg !1018
}

define void @"Simatic.Ax.Json.JsonDocument.AddElement$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !1019 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %_elemMuted = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %elem.addr, metadata !1022, metadata !DIExpression()), !dbg !1023
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %this.addr, metadata !1024, metadata !DIExpression()), !dbg !1025
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, metadata !1026, metadata !DIExpression()), !dbg !1027
  store %Simatic.Ax.Json.JsonDocument* %this, %Simatic.Ax.Json.JsonDocument** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1028
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !1028
  %2 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %1), !dbg !1028
  %3 = bitcast i8** %2 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1028
  store %Simatic.Ax.Json.IJsonElementMuteable* %3, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1028
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1029
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr, i32 0, i32 2, !dbg !1029
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !1029
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8**, !dbg !1029
  %6 = call i16 @"$ax.ref_equals_interfaces"(i8** %5, i8** null), !dbg !1029
  %7 = icmp eq i16 %6, 1, !dbg !1029
  br i1 %7, label %bb5, label %bb2, !dbg !1029

bb2:                                              ; preds = %bb1
  %8 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1030
  %9 = bitcast %Simatic.Ax.Json.IJsonElement* %8 to i8**, !dbg !1030
  %10 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %9), !dbg !1030
  %11 = bitcast i8** %10 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1030
  store %Simatic.Ax.Json.IJsonElementMuteable* %11, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1030
  %auto_deref_this.addr5 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1031
  %_lastElement6 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr5, i32 0, i32 3, !dbg !1031
  %12 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement6, !dbg !1031
  %13 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1031
  %14 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %12, i32 0, i32 0, !dbg !1031
  %15 = load i8*, i8** %14, !dbg !1031
  %16 = bitcast i8* %15 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1031
  %"$vTable" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %16, i32 0, i32 1, !dbg !1031
  %17 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable", i32 0, i32 0, !dbg !1031
  %18 = load i8*, i8** %17, !dbg !1031
  %19 = bitcast i8* %18 to void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)*, !dbg !1031
  call void %19(%Simatic.Ax.Json.IJsonElementMuteable* %12, %Simatic.Ax.Json.IJsonElement* %13), !dbg !1031
  %auto_deref_this.addr7 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1032
  %_lastElement8 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr7, i32 0, i32 3, !dbg !1032
  %20 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1032
  store %Simatic.Ax.Json.IJsonElementMuteable* %20, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement8, !dbg !1032
  br label %bb3, !dbg !1032

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1033

bb4:                                              ; preds = %bb3
  ret void, !dbg !1034

bb5:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1035
  %_firstElement2 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr1, i32 0, i32 2, !dbg !1035
  %21 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1035
  store %Simatic.Ax.Json.IJsonElementMuteable* %21, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement2, !dbg !1035
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1036
  %_lastElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr3, i32 0, i32 3, !dbg !1036
  %22 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1036
  store %Simatic.Ax.Json.IJsonElementMuteable* %22, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement, !dbg !1036
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %this.addr, !dbg !1037
  %_rootElement = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %auto_deref_this.addr4, i32 0, i32 4, !dbg !1037
  %23 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1037
  store %Simatic.Ax.Json.IJsonElement* %23, %Simatic.Ax.Json.IJsonElement** %_rootElement, !dbg !1037
  br label %bb3, !dbg !1037
}

define %STRING.0 @"Simatic.Ax.Json.AbstractJsonElement.ToStringHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@STRING@valueAsString"(%Simatic.Ax.Json.AbstractJsonElement* %this, i8* %valueAsString) !dbg !1038 {
Entry:
  %ToStringHelper.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  %valueAsString.addr = alloca %STRING.0
  %_str = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %STRING.0* %valueAsString.addr, metadata !1050, metadata !DIExpression()), !dbg !1051
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1052, metadata !DIExpression()), !dbg !1053
  call void @llvm.dbg.declare(metadata %STRING.0* %_str, metadata !1054, metadata !DIExpression()), !dbg !1055
  call void @llvm.dbg.declare(metadata %STRING.0* %ToStringHelper.ret, metadata !1056, metadata !DIExpression()), !dbg !1053
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %1
  %2 = alloca %STRING.0
  %3 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %3
  %4 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToStringHelper.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %valueAsString.addr
  %5 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1053
  call void @"$ax.AssignST_String"(i8* %5, i8* %valueAsString), !dbg !1053
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_str
  br label %bb1

bb1:                                              ; preds = %Entry
  %6 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2, i32 0, !dbg !1057
  store i8 34, i8* %6, !dbg !1057
  %auto_deref_this.addr = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %this.addr, !dbg !1057
  %Key = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %auto_deref_this.addr, i32 0, i32 3, !dbg !1057
  %7 = getelementptr inbounds %STRING.0, %STRING.0* %1, i32 0, i32 2, i32 0, !dbg !1057
  store i8 34, i8* %7, !dbg !1057
  %8 = bitcast %STRING.0* %0 to i8*, !dbg !1057
  %9 = bitcast %STRING.0* %Key to i8*, !dbg !1057
  %10 = bitcast %STRING.0* %1 to i8*, !dbg !1057
  %11 = call %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3?I@V@STRING@string4"(i8* %8, i8* %9, i8* %10, i8* getelementptr inbounds (%"STRING[3]", %"STRING[3]"* @"$cStr.31", i32 0, i32 0)), !dbg !1057
  store %STRING.0 %11, %STRING.0* %2, !dbg !1057
  %12 = bitcast %STRING.0* %_str to i8*, !dbg !1057
  %13 = bitcast %STRING.0* %2 to i8*, !dbg !1057
  call void @"$ax.AssignST_String"(i8* %12, i8* %13), !dbg !1057
  %14 = getelementptr inbounds %STRING.0, %STRING.0* %3, i32 0, i32 2, i32 0, !dbg !1058
  store i8 34, i8* %14, !dbg !1058
  %15 = bitcast %STRING.0* %_str to i8*, !dbg !1058
  %16 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1058
  %17 = bitcast %STRING.0* %3 to i8*, !dbg !1058
  %18 = call %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3"(i8* %15, i8* %16, i8* %17), !dbg !1058
  store %STRING.0 %18, %STRING.0* %4, !dbg !1058
  %19 = bitcast %STRING.0* %_str to i8*, !dbg !1058
  %20 = bitcast %STRING.0* %4 to i8*, !dbg !1058
  call void @"$ax.AssignST_String"(i8* %19, i8* %20), !dbg !1058
  %21 = bitcast %STRING.0* %ToStringHelper.ret to i8*, !dbg !1059
  %22 = bitcast %STRING.0* %_str to i8*, !dbg !1059
  call void @"$ax.AssignST_String"(i8* %21, i8* %22), !dbg !1059
  %23 = load %STRING.0, %STRING.0* %ToStringHelper.ret, !dbg !1060
  ret %STRING.0 %23, !dbg !1060
}

define i32 @"Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString"(%Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc, i8* %valueAsString) !dbg !1061 {
Entry:
  %SerializeHelper.ret = alloca i32
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %valueAsString.addr = alloca %STRING.0
  %_i = alloca i32
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1065, metadata !DIExpression()), !dbg !1066
  call void @llvm.dbg.declare(metadata %STRING.0* %valueAsString.addr, metadata !1067, metadata !DIExpression()), !dbg !1068
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1069, metadata !DIExpression()), !dbg !1070
  call void @llvm.dbg.declare(metadata i32* %_i, metadata !1071, metadata !DIExpression()), !dbg !1072
  call void @llvm.dbg.declare(metadata i32* %SerializeHelper.ret, metadata !1073, metadata !DIExpression()), !dbg !1070
  %0 = alloca i32
  store i32 0, i32* %0
  store i32 0, i32* %SerializeHelper.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %valueAsString.addr
  %1 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1070
  call void @"$ax.AssignST_String"(i8* %1, i8* %valueAsString), !dbg !1070
  store i32 0, i32* %_i
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1074
  %3 = call i16 @ax_LenST_String(i8* %2), !dbg !1074
  %4 = sext i16 %3 to i32, !dbg !1074
  store i32 %4, i32* %0, !dbg !1074
  store i32 1, i32* %_i, !dbg !1075
  br label %bb4, !dbg !1076

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !1077

bb3:                                              ; preds = %bb2
  %5 = load i32, i32* %SerializeHelper.ret, !dbg !1078
  ret i32 %5, !dbg !1078

bb4:                                              ; preds = %bb5, %bb1
  %6 = load i32, i32* %_i, !dbg !1076
  %7 = load i32, i32* %0, !dbg !1076
  %8 = icmp sgt i32 %6, %7, !dbg !1076
  br i1 %8, label %bb2, label %bb6, !dbg !1076

bb5:                                              ; preds = %bb6
  %9 = load i32, i32* %_i, !dbg !1076
  %10 = add i32 %9, 1, !dbg !1076
  store i32 %10, i32* %_i, !dbg !1076
  br label %bb4, !dbg !1076

bb6:                                              ; preds = %bb4
  %11 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1079
  %12 = load i32, i32* %_i, !dbg !1079
  %13 = trunc i32 %12 to i8, !dbg !1079
  %14 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1079
  %15 = call i8 @"$ax.GetAtST_String"(i8* %14, i8 %13), !dbg !1079
  %16 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %11, i32 0, i32 0, !dbg !1079
  %17 = load i8*, i8** %16, !dbg !1079
  %18 = bitcast i8* %17 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !1079
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %18, i32 0, i32 4, !dbg !1079
  %19 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 0, !dbg !1079
  %20 = load i8*, i8** %19, !dbg !1079
  %21 = bitcast i8* %20 to i1 (%Simatic.Ax.Json.JsonDocument*, i8)*, !dbg !1079
  %22 = call i1 %21(%Simatic.Ax.Json.JsonDocument* %11, i8 %15), !dbg !1079
  br label %bb5, !dbg !1076
}

define i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %this) !dbg !1080 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1083, metadata !DIExpression()), !dbg !1084
  call void @llvm.dbg.declare(metadata i1* %HasNext.ret, metadata !1085, metadata !DIExpression()), !dbg !1084
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %this.addr, !dbg !1086
  %_next = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %auto_deref_this.addr, i32 0, i32 4, !dbg !1086
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_next, !dbg !1086
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !1086
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !1086
  %3 = icmp ne i16 %2, 1, !dbg !1086
  store i1 %3, i1* %HasNext.ret, !dbg !1086
  %4 = load i1, i1* %HasNext.ret, !dbg !1087
  ret i1 %4, !dbg !1087
}

define %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %this) !dbg !1088 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1091, metadata !DIExpression()), !dbg !1092
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, metadata !1093, metadata !DIExpression()), !dbg !1092
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %this.addr, !dbg !1094
  %_next = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %auto_deref_this.addr, i32 0, i32 4, !dbg !1094
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_next, !dbg !1094
  store %Simatic.Ax.Json.IJsonElementMuteable* %0, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !1094
  %1 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !1095
  ret %Simatic.Ax.Json.IJsonElementMuteable* %1, !dbg !1095
}

define void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !1096 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %elem.addr, metadata !1099, metadata !DIExpression()), !dbg !1100
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1101, metadata !DIExpression()), !dbg !1102
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1103
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !1103
  %2 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %1), !dbg !1103
  %3 = bitcast i8** %2 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1103
  %auto_deref_this.addr = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %this.addr, !dbg !1103
  %_next = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %auto_deref_this.addr, i32 0, i32 4, !dbg !1103
  store %Simatic.Ax.Json.IJsonElementMuteable* %3, %Simatic.Ax.Json.IJsonElementMuteable** %_next, !dbg !1103
  ret void, !dbg !1104
}

define %STRING.0 @"Simatic.Ax.Json.AbstractJsonElement.ToString$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %this) !dbg !1105 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1108, metadata !DIExpression()), !dbg !1109
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1110, metadata !DIExpression()), !dbg !1109
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1111
  ret %STRING.0 %0, !dbg !1111
}

define i1 @"Simatic.Ax.Json.AbstractJsonElement.Serialize$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !1112 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.AbstractJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1115, metadata !DIExpression()), !dbg !1116
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.AbstractJsonElement** %this.addr, metadata !1117, metadata !DIExpression()), !dbg !1118
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !1119, metadata !DIExpression()), !dbg !1118
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.AbstractJsonElement* %this, %Simatic.Ax.Json.AbstractJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i1, i1* %Serialize.ret, !dbg !1120
  ret i1 %0, !dbg !1120
}

define %STRING.0 @"Simatic.Ax.Json.JsonBoolean.ToString$I@R@Simatic.Ax.Json.JsonBoolean@this"(%Simatic.Ax.Json.JsonBoolean* %this) !dbg !1121 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonBoolean*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonBoolean** %this.addr, metadata !1134, metadata !DIExpression()), !dbg !1135
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1136, metadata !DIExpression()), !dbg !1135
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonBoolean* %this, %Simatic.Ax.Json.JsonBoolean** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %this.addr, !dbg !1137
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr, i32 0, i32 1, !dbg !1137
  %2 = load i1, i1* %Value, !dbg !1137
  br i1 %2, label %bb5, label %bb2, !dbg !1137

bb2:                                              ; preds = %bb1
  %auto_deref_this.addr2 = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %this.addr, !dbg !1138
  %3 = bitcast %Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr2 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1138
  %4 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %3, i32 0, i32 0, !dbg !1138
  %5 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %4 to i8**, !dbg !1138
  %6 = load i8*, i8** %5, !dbg !1138
  %7 = bitcast i8* %6 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1138
  %"$vTable3" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %7, i32 0, i32 4, !dbg !1138
  %8 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable3", i32 0, i32 6, !dbg !1138
  %9 = load i8*, i8** %8, !dbg !1138
  %10 = bitcast i8* %9 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1138
  %11 = call %STRING.0 %10(%Simatic.Ax.Json.BaseJsonNumber* %3, i8* getelementptr inbounds (%"STRING[5]", %"STRING[5]"* @"$cStr.33", i32 0, i32 0)), !dbg !1138
  store %STRING.0 %11, %STRING.0* %1, !dbg !1138
  %12 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1138
  %13 = bitcast %STRING.0* %1 to i8*, !dbg !1138
  call void @"$ax.AssignST_String"(i8* %12, i8* %13), !dbg !1138
  br label %bb3, !dbg !1138

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1139

bb4:                                              ; preds = %bb3
  %14 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1140
  ret %STRING.0 %14, !dbg !1140

bb5:                                              ; preds = %bb1
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %this.addr, !dbg !1141
  %15 = bitcast %Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr1 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1141
  %16 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %15, i32 0, i32 0, !dbg !1141
  %17 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %16 to i8**, !dbg !1141
  %18 = load i8*, i8** %17, !dbg !1141
  %19 = bitcast i8* %18 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1141
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %19, i32 0, i32 4, !dbg !1141
  %20 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1141
  %21 = load i8*, i8** %20, !dbg !1141
  %22 = bitcast i8* %21 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1141
  %23 = call %STRING.0 %22(%Simatic.Ax.Json.BaseJsonNumber* %15, i8* getelementptr inbounds (%"STRING[4]", %"STRING[4]"* @"$cStr.32", i32 0, i32 0)), !dbg !1141
  store %STRING.0 %23, %STRING.0* %0, !dbg !1141
  %24 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1141
  %25 = bitcast %STRING.0* %0 to i8*, !dbg !1141
  call void @"$ax.AssignST_String"(i8* %24, i8* %25), !dbg !1141
  br label %bb3, !dbg !1141
}

define i1 @"Simatic.Ax.Json.JsonBoolean.Serialize$I@R@Simatic.Ax.Json.JsonBoolean@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonBoolean* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !1142 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonBoolean*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1145, metadata !DIExpression()), !dbg !1146
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonBoolean** %this.addr, metadata !1147, metadata !DIExpression()), !dbg !1148
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !1149, metadata !DIExpression()), !dbg !1148
  %0 = alloca %STRING.0
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.JsonBoolean* %this, %Simatic.Ax.Json.JsonBoolean** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %this.addr, !dbg !1150
  %1 = bitcast %Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1150
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %this.addr, !dbg !1150
  %2 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr1, i32 0, i32 0, !dbg !1150
  %3 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %2 to i8**, !dbg !1150
  %4 = load i8*, i8** %3, !dbg !1150
  %5 = bitcast i8* %4 to %"$CD_Simatic.Ax.Json.JsonBoolean"*, !dbg !1150
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonBoolean", %"$CD_Simatic.Ax.Json.JsonBoolean"* %5, i32 0, i32 4, !dbg !1150
  %6 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 5, !dbg !1150
  %7 = load i8*, i8** %6, !dbg !1150
  %8 = bitcast i8* %7 to %STRING.0 (%Simatic.Ax.Json.JsonBoolean*)*, !dbg !1150
  %9 = call %STRING.0 %8(%Simatic.Ax.Json.JsonBoolean* %auto_deref_this.addr1), !dbg !1150
  store %STRING.0 %9, %STRING.0* %0, !dbg !1150
  %10 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1150
  %11 = bitcast %STRING.0* %0 to i8*, !dbg !1150
  %12 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %1, i32 0, i32 0, !dbg !1150
  %13 = load i8*, i8** %12, !dbg !1150
  %14 = bitcast i8* %13 to %"$CD_Simatic.Ax.Json.AbstractJsonElement"*, !dbg !1150
  %"$vTable2" = getelementptr inbounds %"$CD_Simatic.Ax.Json.AbstractJsonElement", %"$CD_Simatic.Ax.Json.AbstractJsonElement"* %14, i32 0, i32 4, !dbg !1150
  %15 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable2", i32 0, i32 4, !dbg !1150
  %16 = load i8*, i8** %15, !dbg !1150
  %17 = bitcast i8* %16 to i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !1150
  %18 = call i32 %17(%Simatic.Ax.Json.AbstractJsonElement* %1, %Simatic.Ax.Json.JsonDocument* %10, i8* %11), !dbg !1150
  store i1 false, i1* %Serialize.ret, !dbg !1151
  %19 = load i1, i1* %Serialize.ret, !dbg !1152
  ret i1 %19, !dbg !1152
}

define %STRING.0 @"Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString"(%Simatic.Ax.Json.BaseJsonNumber* %this, i8* %valueAsString) !dbg !1153 {
Entry:
  %ToStringHelper.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.BaseJsonNumber*
  %valueAsString.addr = alloca %STRING.0
  %_str = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %STRING.0* %valueAsString.addr, metadata !1157, metadata !DIExpression()), !dbg !1158
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.BaseJsonNumber** %this.addr, metadata !1159, metadata !DIExpression()), !dbg !1160
  call void @llvm.dbg.declare(metadata %STRING.0* %_str, metadata !1161, metadata !DIExpression()), !dbg !1162
  call void @llvm.dbg.declare(metadata %STRING.0* %ToStringHelper.ret, metadata !1163, metadata !DIExpression()), !dbg !1160
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToStringHelper.ret
  store %Simatic.Ax.Json.BaseJsonNumber* %this, %Simatic.Ax.Json.BaseJsonNumber** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %valueAsString.addr
  %2 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1160
  call void @"$ax.AssignST_String"(i8* %2, i8* %valueAsString), !dbg !1160
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_str
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2, i32 0, !dbg !1164
  store i8 34, i8* %3, !dbg !1164
  %auto_deref_this.addr = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %this.addr, !dbg !1164
  %4 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %auto_deref_this.addr to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1164
  %Key = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %4, i32 0, i32 3, !dbg !1164
  %5 = bitcast %STRING.0* %0 to i8*, !dbg !1164
  %6 = bitcast %STRING.0* %Key to i8*, !dbg !1164
  %7 = bitcast %STRING.0* %valueAsString.addr to i8*, !dbg !1164
  %8 = call %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3?I@V@STRING@string4"(i8* %5, i8* %6, i8* getelementptr inbounds (%"STRING[3]", %"STRING[3]"* @"$cStr.34", i32 0, i32 0), i8* %7), !dbg !1164
  store %STRING.0 %8, %STRING.0* %1, !dbg !1164
  %9 = bitcast %STRING.0* %_str to i8*, !dbg !1164
  %10 = bitcast %STRING.0* %1 to i8*, !dbg !1164
  call void @"$ax.AssignST_String"(i8* %9, i8* %10), !dbg !1164
  %11 = bitcast %STRING.0* %ToStringHelper.ret to i8*, !dbg !1165
  %12 = bitcast %STRING.0* %_str to i8*, !dbg !1165
  call void @"$ax.AssignST_String"(i8* %11, i8* %12), !dbg !1165
  %13 = load %STRING.0, %STRING.0* %ToStringHelper.ret, !dbg !1166
  ret %STRING.0 %13, !dbg !1166
}

define %STRING.0 @"Simatic.Ax.Json.BaseJsonNumber.ToString$I@R@Simatic.Ax.Json.BaseJsonNumber@this"(%Simatic.Ax.Json.BaseJsonNumber* %this) !dbg !1167 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.BaseJsonNumber*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.BaseJsonNumber** %this.addr, metadata !1170, metadata !DIExpression()), !dbg !1171
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1172, metadata !DIExpression()), !dbg !1171
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.BaseJsonNumber* %this, %Simatic.Ax.Json.BaseJsonNumber** %this.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1173
  ret %STRING.0 %0, !dbg !1173
}

define i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !1174 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.BaseJsonNumber*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1177, metadata !DIExpression()), !dbg !1178
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.BaseJsonNumber** %this.addr, metadata !1179, metadata !DIExpression()), !dbg !1180
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !1181, metadata !DIExpression()), !dbg !1180
  %0 = alloca %STRING.0
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.BaseJsonNumber* %this, %Simatic.Ax.Json.BaseJsonNumber** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %this.addr, !dbg !1182
  %1 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %auto_deref_this.addr to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1182
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %this.addr, !dbg !1182
  %2 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %auto_deref_this.addr1, i32 0, i32 0, !dbg !1182
  %3 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %2 to i8**, !dbg !1182
  %4 = load i8*, i8** %3, !dbg !1182
  %5 = bitcast i8* %4 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1182
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %5, i32 0, i32 4, !dbg !1182
  %6 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 5, !dbg !1182
  %7 = load i8*, i8** %6, !dbg !1182
  %8 = bitcast i8* %7 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*)*, !dbg !1182
  %9 = call %STRING.0 %8(%Simatic.Ax.Json.BaseJsonNumber* %auto_deref_this.addr1), !dbg !1182
  store %STRING.0 %9, %STRING.0* %0, !dbg !1182
  %10 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1182
  %11 = bitcast %STRING.0* %0 to i8*, !dbg !1182
  %12 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %1, i32 0, i32 0, !dbg !1182
  %13 = load i8*, i8** %12, !dbg !1182
  %14 = bitcast i8* %13 to %"$CD_Simatic.Ax.Json.AbstractJsonElement"*, !dbg !1182
  %"$vTable2" = getelementptr inbounds %"$CD_Simatic.Ax.Json.AbstractJsonElement", %"$CD_Simatic.Ax.Json.AbstractJsonElement"* %14, i32 0, i32 4, !dbg !1182
  %15 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable2", i32 0, i32 4, !dbg !1182
  %16 = load i8*, i8** %15, !dbg !1182
  %17 = bitcast i8* %16 to i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !1182
  %18 = call i32 %17(%Simatic.Ax.Json.AbstractJsonElement* %1, %Simatic.Ax.Json.JsonDocument* %10, i8* %11), !dbg !1182
  store i1 false, i1* %Serialize.ret, !dbg !1183
  %19 = load i1, i1* %Serialize.ret, !dbg !1184
  ret i1 %19, !dbg !1184
}

define %STRING.0 @"Simatic.Ax.Json.JsonDInt.ToString$I@R@Simatic.Ax.Json.JsonDInt@this"(%Simatic.Ax.Json.JsonDInt* %this) !dbg !1185 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonDInt*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDInt** %this.addr, metadata !1194, metadata !DIExpression()), !dbg !1195
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1196, metadata !DIExpression()), !dbg !1195
  %"$Simatic.Ax.Json.JsonDInt.ToString_mode_def" = alloca i16, !dbg !1197
  %0 = alloca %"STRING[11]"
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonDInt* %this, %Simatic.Ax.Json.JsonDInt** %this.addr
  store i16 0, i16* %"$Simatic.Ax.Json.JsonDInt.ToString_mode_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %this.addr, !dbg !1197
  %2 = bitcast %Simatic.Ax.Json.JsonDInt* %auto_deref_this.addr to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1197
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %this.addr, !dbg !1197
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %auto_deref_this.addr1, i32 0, i32 1, !dbg !1197
  %3 = load i32, i32* %Value, !dbg !1197
  %4 = load i16, i16* %"$Simatic.Ax.Json.JsonDInt.ToString_mode_def", !dbg !1197
  %5 = call %"STRING[11]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int32@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i32 %3, i16 %4), !dbg !1197
  store %"STRING[11]" %5, %"STRING[11]"* %0, !dbg !1197
  %6 = bitcast %"STRING[11]"* %0 to i8*, !dbg !1197
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %2, i32 0, i32 0, !dbg !1197
  %8 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %7 to i8**, !dbg !1197
  %9 = load i8*, i8** %8, !dbg !1197
  %10 = bitcast i8* %9 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1197
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %10, i32 0, i32 4, !dbg !1197
  %11 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1197
  %12 = load i8*, i8** %11, !dbg !1197
  %13 = bitcast i8* %12 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1197
  %14 = call %STRING.0 %13(%Simatic.Ax.Json.BaseJsonNumber* %2, i8* %6), !dbg !1197
  store %STRING.0 %14, %STRING.0* %1, !dbg !1197
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1197
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1197
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1197
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1198
  ret %STRING.0 %17, !dbg !1198
}

define %STRING.0 @"Simatic.Ax.Json.JsonInt.ToString$I@R@Simatic.Ax.Json.JsonInt@this"(%Simatic.Ax.Json.JsonInt* %this) !dbg !1199 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonInt*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonInt** %this.addr, metadata !1208, metadata !DIExpression()), !dbg !1209
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1210, metadata !DIExpression()), !dbg !1209
  %"$Simatic.Ax.Json.JsonInt.ToString_mode_def" = alloca i16, !dbg !1211
  %0 = alloca %"STRING[6]"
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonInt* %this, %Simatic.Ax.Json.JsonInt** %this.addr
  store i16 0, i16* %"$Simatic.Ax.Json.JsonInt.ToString_mode_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %this.addr, !dbg !1211
  %2 = bitcast %Simatic.Ax.Json.JsonInt* %auto_deref_this.addr to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1211
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %this.addr, !dbg !1211
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %auto_deref_this.addr1, i32 0, i32 1, !dbg !1211
  %3 = load i16, i16* %Value, !dbg !1211
  %4 = load i16, i16* %"$Simatic.Ax.Json.JsonInt.ToString_mode_def", !dbg !1211
  %5 = call %"STRING[6]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int16@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i16 %3, i16 %4), !dbg !1211
  store %"STRING[6]" %5, %"STRING[6]"* %0, !dbg !1211
  %6 = bitcast %"STRING[6]"* %0 to i8*, !dbg !1211
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %2, i32 0, i32 0, !dbg !1211
  %8 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %7 to i8**, !dbg !1211
  %9 = load i8*, i8** %8, !dbg !1211
  %10 = bitcast i8* %9 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1211
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %10, i32 0, i32 4, !dbg !1211
  %11 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1211
  %12 = load i8*, i8** %11, !dbg !1211
  %13 = bitcast i8* %12 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1211
  %14 = call %STRING.0 %13(%Simatic.Ax.Json.BaseJsonNumber* %2, i8* %6), !dbg !1211
  store %STRING.0 %14, %STRING.0* %1, !dbg !1211
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1211
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1211
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1211
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1212
  ret %STRING.0 %17, !dbg !1212
}

define %STRING.0 @"Simatic.Ax.Json.JsonLInt.ToString$I@R@Simatic.Ax.Json.JsonLInt@this"(%Simatic.Ax.Json.JsonLInt* %this) !dbg !1213 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonLInt*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonLInt** %this.addr, metadata !1222, metadata !DIExpression()), !dbg !1223
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1224, metadata !DIExpression()), !dbg !1223
  %"$Simatic.Ax.Json.JsonLInt.ToString_mode_def" = alloca i16, !dbg !1225
  %0 = alloca %"STRING[20]"
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonLInt* %this, %Simatic.Ax.Json.JsonLInt** %this.addr
  store i16 0, i16* %"$Simatic.Ax.Json.JsonLInt.ToString_mode_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %this.addr, !dbg !1225
  %2 = bitcast %Simatic.Ax.Json.JsonLInt* %auto_deref_this.addr to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1225
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %this.addr, !dbg !1225
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %auto_deref_this.addr1, i32 0, i32 1, !dbg !1225
  %3 = load i64, i64* %Value, !dbg !1225
  %4 = load i16, i16* %"$Simatic.Ax.Json.JsonLInt.ToString_mode_def", !dbg !1225
  %5 = call %"STRING[20]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %3, i16 %4), !dbg !1225
  store %"STRING[20]" %5, %"STRING[20]"* %0, !dbg !1225
  %6 = bitcast %"STRING[20]"* %0 to i8*, !dbg !1225
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %2, i32 0, i32 0, !dbg !1225
  %8 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %7 to i8**, !dbg !1225
  %9 = load i8*, i8** %8, !dbg !1225
  %10 = bitcast i8* %9 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1225
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %10, i32 0, i32 4, !dbg !1225
  %11 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1225
  %12 = load i8*, i8** %11, !dbg !1225
  %13 = bitcast i8* %12 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1225
  %14 = call %STRING.0 %13(%Simatic.Ax.Json.BaseJsonNumber* %2, i8* %6), !dbg !1225
  store %STRING.0 %14, %STRING.0* %1, !dbg !1225
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1225
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1225
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1225
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1226
  ret %STRING.0 %17, !dbg !1226
}

define %STRING.0 @"Simatic.Ax.Json.JsonUSInt.ToString$I@R@Simatic.Ax.Json.JsonUSInt@this"(%Simatic.Ax.Json.JsonUSInt* %this) !dbg !1227 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonUSInt*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonUSInt** %this.addr, metadata !1236, metadata !DIExpression()), !dbg !1237
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1238, metadata !DIExpression()), !dbg !1237
  %"$Simatic.Ax.Json.JsonUSInt.ToString_mode_def" = alloca i16, !dbg !1239
  %0 = alloca %"STRING[4]"
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonUSInt* %this, %Simatic.Ax.Json.JsonUSInt** %this.addr
  store i16 0, i16* %"$Simatic.Ax.Json.JsonUSInt.ToString_mode_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %this.addr, !dbg !1239
  %2 = bitcast %Simatic.Ax.Json.JsonUSInt* %auto_deref_this.addr to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1239
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %this.addr, !dbg !1239
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %auto_deref_this.addr1, i32 0, i32 1, !dbg !1239
  %3 = load i8, i8* %Value, !dbg !1239
  %4 = load i16, i16* %"$Simatic.Ax.Json.JsonUSInt.ToString_mode_def", !dbg !1239
  %5 = call %"STRING[4]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@UInt8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i8 %3, i16 %4), !dbg !1239
  store %"STRING[4]" %5, %"STRING[4]"* %0, !dbg !1239
  %6 = bitcast %"STRING[4]"* %0 to i8*, !dbg !1239
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %2, i32 0, i32 0, !dbg !1239
  %8 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %7 to i8**, !dbg !1239
  %9 = load i8*, i8** %8, !dbg !1239
  %10 = bitcast i8* %9 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1239
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %10, i32 0, i32 4, !dbg !1239
  %11 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1239
  %12 = load i8*, i8** %11, !dbg !1239
  %13 = bitcast i8* %12 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1239
  %14 = call %STRING.0 %13(%Simatic.Ax.Json.BaseJsonNumber* %2, i8* %6), !dbg !1239
  store %STRING.0 %14, %STRING.0* %1, !dbg !1239
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1239
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1239
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1239
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1240
  ret %STRING.0 %17, !dbg !1240
}

define %STRING.0 @"Simatic.Ax.Json.JsonSInt.ToString$I@R@Simatic.Ax.Json.JsonSInt@this"(%Simatic.Ax.Json.JsonSInt* %this) !dbg !1241 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonSInt*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonSInt** %this.addr, metadata !1250, metadata !DIExpression()), !dbg !1251
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1252, metadata !DIExpression()), !dbg !1251
  %"$Simatic.Ax.Json.JsonSInt.ToString_mode_def" = alloca i16, !dbg !1253
  %0 = alloca %"STRING[4]"
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonSInt* %this, %Simatic.Ax.Json.JsonSInt** %this.addr
  store i16 0, i16* %"$Simatic.Ax.Json.JsonSInt.ToString_mode_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %this.addr, !dbg !1253
  %2 = bitcast %Simatic.Ax.Json.JsonSInt* %auto_deref_this.addr to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !1253
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %this.addr, !dbg !1253
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %auto_deref_this.addr1, i32 0, i32 1, !dbg !1253
  %3 = load i8, i8* %Value, !dbg !1253
  %4 = load i16, i16* %"$Simatic.Ax.Json.JsonSInt.ToString_mode_def", !dbg !1253
  %5 = call %"STRING[4]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i8 %3, i16 %4), !dbg !1253
  store %"STRING[4]" %5, %"STRING[4]"* %0, !dbg !1253
  %6 = bitcast %"STRING[4]"* %0 to i8*, !dbg !1253
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %2, i32 0, i32 0, !dbg !1253
  %8 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %7 to i8**, !dbg !1253
  %9 = load i8*, i8** %8, !dbg !1253
  %10 = bitcast i8* %9 to %"$CD_Simatic.Ax.Json.BaseJsonNumber"*, !dbg !1253
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.BaseJsonNumber", %"$CD_Simatic.Ax.Json.BaseJsonNumber"* %10, i32 0, i32 4, !dbg !1253
  %11 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1253
  %12 = load i8*, i8** %11, !dbg !1253
  %13 = bitcast i8* %12 to %STRING.0 (%Simatic.Ax.Json.BaseJsonNumber*, i8*)*, !dbg !1253
  %14 = call %STRING.0 %13(%Simatic.Ax.Json.BaseJsonNumber* %2, i8* %6), !dbg !1253
  store %STRING.0 %14, %STRING.0* %1, !dbg !1253
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1253
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1253
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1253
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1254
  ret %STRING.0 %17, !dbg !1254
}

define %STRING.0 @"Simatic.Ax.Json.JsonObject.ToString$I@R@Simatic.Ax.Json.JsonObject@this"(%Simatic.Ax.Json.JsonObject* %this) !dbg !1255 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonObject*
  %_str = alloca %STRING.0
  %_to = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %_elem = alloca %Simatic.Ax.Json.IJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonObject** %this.addr, metadata !1265, metadata !DIExpression()), !dbg !1266
  call void @llvm.dbg.declare(metadata %STRING.0* %_str, metadata !1267, metadata !DIExpression()), !dbg !1268
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_to, metadata !1269, metadata !DIExpression()), !dbg !1270
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %_elem, metadata !1271, metadata !DIExpression()), !dbg !1272
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1273, metadata !DIExpression()), !dbg !1266
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %0
  %1 = alloca %STRING.0
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca %STRING.0
  %4 = alloca %STRING.0
  %5 = alloca %STRING.0
  %6 = alloca %STRING.0
  %7 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %7
  %8 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonObject* %this, %Simatic.Ax.Json.JsonObject** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_str
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_to
  store %Simatic.Ax.Json.IJsonElement* null, %Simatic.Ax.Json.IJsonElement** %_elem
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1274
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr, i32 0, i32 2, !dbg !1274
  %9 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !1274
  %10 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %9 to i8**, !dbg !1274
  %11 = call i16 @"$ax.ref_equals_interfaces"(i8** %10, i8** null), !dbg !1274
  %12 = icmp ne i16 %11, 1, !dbg !1274
  br i1 %12, label %bb4, label %bb2, !dbg !1274

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !1275

bb3:                                              ; preds = %bb2
  %13 = getelementptr inbounds %STRING.0, %STRING.0* %2, i32 0, i32 2, i32 0, !dbg !1276
  store i8 123, i8* %13, !dbg !1276
  %14 = bitcast %STRING.0* %_str to i8*, !dbg !1276
  %15 = bitcast %STRING.0* %2 to i8*, !dbg !1276
  %16 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %14, i8* %15), !dbg !1276
  store %STRING.0 %16, %STRING.0* %3, !dbg !1276
  %17 = bitcast %STRING.0* %_str to i8*, !dbg !1276
  %18 = bitcast %STRING.0* %3 to i8*, !dbg !1276
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !1276
  %auto_deref_this.addr2 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1277
  %_firstElement3 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr2, i32 0, i32 2, !dbg !1277
  %19 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement3, !dbg !1277
  %20 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %19 to i8**, !dbg !1277
  %21 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %20), !dbg !1277
  %22 = bitcast i8** %21 to %Simatic.Ax.Json.IJsonElement*, !dbg !1277
  store %Simatic.Ax.Json.IJsonElement* %22, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1277
  %23 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1278
  %24 = bitcast %Simatic.Ax.Json.IJsonElement* %23 to i8**, !dbg !1278
  %25 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %24), !dbg !1278
  %26 = bitcast i8** %25 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1278
  store %Simatic.Ax.Json.IJsonElementMuteable* %26, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1278
  br label %bb5, !dbg !1278

bb4:                                              ; preds = %bb1
  %27 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2, i32 0, !dbg !1279
  store i8 34, i8* %27, !dbg !1279
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1279
  %28 = bitcast %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr1 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1279
  %Key = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %28, i32 0, i32 3, !dbg !1279
  %29 = bitcast %STRING.0* %_str to i8*, !dbg !1279
  %30 = bitcast %STRING.0* %0 to i8*, !dbg !1279
  %31 = bitcast %STRING.0* %Key to i8*, !dbg !1279
  %32 = call %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3?I@V@STRING@string4"(i8* %29, i8* %30, i8* %31, i8* getelementptr inbounds (%"STRING[3]", %"STRING[3]"* @"$cStr.35", i32 0, i32 0)), !dbg !1279
  store %STRING.0 %32, %STRING.0* %1, !dbg !1279
  %33 = bitcast %STRING.0* %_str to i8*, !dbg !1279
  %34 = bitcast %STRING.0* %1 to i8*, !dbg !1279
  call void @"$ax.AssignST_String"(i8* %33, i8* %34), !dbg !1279
  br label %bb2, !dbg !1279

bb5:                                              ; preds = %bb10, %bb3
  %35 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1280
  %36 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %35 to i8**, !dbg !1280
  %37 = call i16 @"$ax.ref_equals_interfaces"(i8** %36, i8** null), !dbg !1280
  %38 = icmp ne i16 %37, 1, !dbg !1280
  br i1 %38, label %bb6, label %bb7, !dbg !1280

bb6:                                              ; preds = %bb5
  %39 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1281
  %40 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %39 to i8**, !dbg !1281
  %41 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %40), !dbg !1281
  %42 = bitcast i8** %41 to %Simatic.Ax.Json.IJsonElement*, !dbg !1281
  store %Simatic.Ax.Json.IJsonElement* %42, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1281
  %43 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1282
  %44 = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %43, i32 0, i32 0, !dbg !1282
  %45 = load i8*, i8** %44, !dbg !1282
  %46 = bitcast i8* %45 to %Simatic.Ax.Json.IJsonElement*, !dbg !1282
  %"$vTable" = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %46, i32 0, i32 1, !dbg !1282
  %47 = getelementptr inbounds [2 x i8*], [2 x i8*]* %"$vTable", i32 0, i32 1, !dbg !1282
  %48 = load i8*, i8** %47, !dbg !1282
  %49 = bitcast i8* %48 to %STRING.0 (%Simatic.Ax.Json.IJsonElement*)*, !dbg !1282
  %50 = call %STRING.0 %49(%Simatic.Ax.Json.IJsonElement* %43), !dbg !1282
  store %STRING.0 %50, %STRING.0* %4, !dbg !1282
  %51 = bitcast %STRING.0* %_str to i8*, !dbg !1282
  %52 = bitcast %STRING.0* %4 to i8*, !dbg !1282
  %53 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %51, i8* %52), !dbg !1282
  store %STRING.0 %53, %STRING.0* %5, !dbg !1282
  %54 = bitcast %STRING.0* %_str to i8*, !dbg !1282
  %55 = bitcast %STRING.0* %5 to i8*, !dbg !1282
  call void @"$ax.AssignST_String"(i8* %54, i8* %55), !dbg !1282
  %56 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1283
  %57 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %56, i32 0, i32 0, !dbg !1283
  %58 = load i8*, i8** %57, !dbg !1283
  %59 = bitcast i8* %58 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1283
  %"$vTable4" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %59, i32 0, i32 1, !dbg !1283
  %60 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable4", i32 0, i32 1, !dbg !1283
  %61 = load i8*, i8** %60, !dbg !1283
  %62 = bitcast i8* %61 to %Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)*, !dbg !1283
  %63 = call %Simatic.Ax.Json.IJsonElementMuteable* %62(%Simatic.Ax.Json.IJsonElementMuteable* %56), !dbg !1283
  store %Simatic.Ax.Json.IJsonElementMuteable* %63, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1283
  %64 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1284
  %65 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %64 to i8**, !dbg !1284
  %66 = call i16 @"$ax.ref_equals_interfaces"(i8** %65, i8** null), !dbg !1284
  %67 = icmp ne i16 %66, 1, !dbg !1284
  br i1 %67, label %bb11, label %bb9, !dbg !1284

bb7:                                              ; preds = %bb5
  br label %bb8, !dbg !1285

bb8:                                              ; preds = %bb7
  %68 = getelementptr inbounds %STRING.0, %STRING.0* %7, i32 0, i32 2, i32 0, !dbg !1286
  store i8 125, i8* %68, !dbg !1286
  %69 = bitcast %STRING.0* %_str to i8*, !dbg !1286
  %70 = bitcast %STRING.0* %7 to i8*, !dbg !1286
  %71 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %69, i8* %70), !dbg !1286
  store %STRING.0 %71, %STRING.0* %8, !dbg !1286
  %72 = bitcast %STRING.0* %_str to i8*, !dbg !1286
  %73 = bitcast %STRING.0* %8 to i8*, !dbg !1286
  call void @"$ax.AssignST_String"(i8* %72, i8* %73), !dbg !1286
  %74 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1287
  %75 = bitcast %STRING.0* %_str to i8*, !dbg !1287
  call void @"$ax.AssignST_String"(i8* %74, i8* %75), !dbg !1287
  %76 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1288
  ret %STRING.0 %76, !dbg !1288

bb9:                                              ; preds = %bb11, %bb6
  br label %bb10, !dbg !1289

bb10:                                             ; preds = %bb9
  br label %bb5, !dbg !1289

bb11:                                             ; preds = %bb6
  %77 = bitcast %STRING.0* %_str to i8*, !dbg !1290
  %78 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %77, i8* getelementptr inbounds (%"STRING[2]", %"STRING[2]"* @"$cStr.36", i32 0, i32 0)), !dbg !1290
  store %STRING.0 %78, %STRING.0* %6, !dbg !1290
  %79 = bitcast %STRING.0* %_str to i8*, !dbg !1290
  %80 = bitcast %STRING.0* %6 to i8*, !dbg !1290
  call void @"$ax.AssignST_String"(i8* %79, i8* %80), !dbg !1290
  br label %bb9, !dbg !1290
}

define i1 @"Simatic.Ax.Json.JsonObject.Serialize$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonObject* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !1291 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonObject*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %_str = alloca %STRING.0
  %_to = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %_elem = alloca %Simatic.Ax.Json.IJsonElement*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1294, metadata !DIExpression()), !dbg !1295
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonObject** %this.addr, metadata !1296, metadata !DIExpression()), !dbg !1297
  call void @llvm.dbg.declare(metadata %STRING.0* %_str, metadata !1298, metadata !DIExpression()), !dbg !1299
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_to, metadata !1300, metadata !DIExpression()), !dbg !1301
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %_elem, metadata !1302, metadata !DIExpression()), !dbg !1303
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !1304, metadata !DIExpression()), !dbg !1297
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %0
  %1 = alloca %STRING.0
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.JsonObject* %this, %Simatic.Ax.Json.JsonObject** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_str
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_to
  store %Simatic.Ax.Json.IJsonElement* null, %Simatic.Ax.Json.IJsonElement** %_elem
  br label %bb1

bb1:                                              ; preds = %Entry
  store i1 false, i1* %Serialize.ret, !dbg !1305
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1306
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr, i32 0, i32 2, !dbg !1306
  %2 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !1306
  %3 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %2 to i8**, !dbg !1306
  %4 = call i16 @"$ax.ref_equals_interfaces"(i8** %3, i8** null), !dbg !1306
  %5 = icmp ne i16 %4, 1, !dbg !1306
  br i1 %5, label %bb4, label %bb2, !dbg !1306

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !1307

bb3:                                              ; preds = %bb2
  %6 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1308
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %6, i32 0, i32 0, !dbg !1308
  %8 = load i8*, i8** %7, !dbg !1308
  %9 = bitcast i8* %8 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !1308
  %"$vTable2" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %9, i32 0, i32 4, !dbg !1308
  %10 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable2", i32 0, i32 0, !dbg !1308
  %11 = load i8*, i8** %10, !dbg !1308
  %12 = bitcast i8* %11 to i1 (%Simatic.Ax.Json.JsonDocument*, i8)*, !dbg !1308
  %13 = call i1 %12(%Simatic.Ax.Json.JsonDocument* %6, i8 123), !dbg !1308
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1309
  %_firstElement4 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr3, i32 0, i32 2, !dbg !1309
  %14 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement4, !dbg !1309
  %15 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %14 to i8**, !dbg !1309
  %16 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %15), !dbg !1309
  %17 = bitcast i8** %16 to %Simatic.Ax.Json.IJsonElement*, !dbg !1309
  store %Simatic.Ax.Json.IJsonElement* %17, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1309
  %18 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1310
  %19 = bitcast %Simatic.Ax.Json.IJsonElement* %18 to i8**, !dbg !1310
  %20 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %19), !dbg !1310
  %21 = bitcast i8** %20 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1310
  store %Simatic.Ax.Json.IJsonElementMuteable* %21, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1310
  br label %bb5, !dbg !1310

bb4:                                              ; preds = %bb1
  %22 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2, i32 0, !dbg !1311
  store i8 34, i8* %22, !dbg !1311
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1311
  %23 = bitcast %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr1 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1311
  %Key = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %23, i32 0, i32 3, !dbg !1311
  %24 = bitcast %STRING.0* %_str to i8*, !dbg !1311
  %25 = bitcast %STRING.0* %0 to i8*, !dbg !1311
  %26 = bitcast %STRING.0* %Key to i8*, !dbg !1311
  %27 = call %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3?I@V@STRING@string4"(i8* %24, i8* %25, i8* %26, i8* getelementptr inbounds (%"STRING[3]", %"STRING[3]"* @"$cStr.37", i32 0, i32 0)), !dbg !1311
  store %STRING.0 %27, %STRING.0* %1, !dbg !1311
  %28 = bitcast %STRING.0* %_str to i8*, !dbg !1311
  %29 = bitcast %STRING.0* %1 to i8*, !dbg !1311
  call void @"$ax.AssignST_String"(i8* %28, i8* %29), !dbg !1311
  %30 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1312
  %31 = bitcast %STRING.0* %_str to i8*, !dbg !1312
  %32 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %30, i32 0, i32 0, !dbg !1312
  %33 = load i8*, i8** %32, !dbg !1312
  %34 = bitcast i8* %33 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !1312
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %34, i32 0, i32 4, !dbg !1312
  %35 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 2, !dbg !1312
  %36 = load i8*, i8** %35, !dbg !1312
  %37 = bitcast i8* %36 to i1 (%Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !1312
  %38 = call i1 %37(%Simatic.Ax.Json.JsonDocument* %30, i8* %31), !dbg !1312
  br label %bb2, !dbg !1312

bb5:                                              ; preds = %bb10, %bb3
  %39 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1313
  %40 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %39 to i8**, !dbg !1313
  %41 = call i16 @"$ax.ref_equals_interfaces"(i8** %40, i8** null), !dbg !1313
  %42 = icmp ne i16 %41, 1, !dbg !1313
  br i1 %42, label %bb6, label %bb7, !dbg !1313

bb6:                                              ; preds = %bb5
  %43 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1314
  %44 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1314
  %45 = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %43, i32 0, i32 0, !dbg !1314
  %46 = load i8*, i8** %45, !dbg !1314
  %47 = bitcast i8* %46 to %Simatic.Ax.Json.IJsonElement*, !dbg !1314
  %"$vTable5" = getelementptr inbounds %Simatic.Ax.Json.IJsonElement, %Simatic.Ax.Json.IJsonElement* %47, i32 0, i32 1, !dbg !1314
  %48 = getelementptr inbounds [2 x i8*], [2 x i8*]* %"$vTable5", i32 0, i32 0, !dbg !1314
  %49 = load i8*, i8** %48, !dbg !1314
  %50 = bitcast i8* %49 to i1 (%Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.JsonDocument*)*, !dbg !1314
  %51 = call i1 %50(%Simatic.Ax.Json.IJsonElement* %43, %Simatic.Ax.Json.JsonDocument* %44), !dbg !1314
  %52 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1315
  %53 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %52, i32 0, i32 0, !dbg !1315
  %54 = load i8*, i8** %53, !dbg !1315
  %55 = bitcast i8* %54 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1315
  %"$vTable6" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %55, i32 0, i32 1, !dbg !1315
  %56 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable6", i32 0, i32 1, !dbg !1315
  %57 = load i8*, i8** %56, !dbg !1315
  %58 = bitcast i8* %57 to %Simatic.Ax.Json.IJsonElementMuteable* (%Simatic.Ax.Json.IJsonElementMuteable*)*, !dbg !1315
  %59 = call %Simatic.Ax.Json.IJsonElementMuteable* %58(%Simatic.Ax.Json.IJsonElementMuteable* %52), !dbg !1315
  store %Simatic.Ax.Json.IJsonElementMuteable* %59, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1315
  %60 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1316
  %61 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %60 to i8**, !dbg !1316
  %62 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -274380306, i8** %61), !dbg !1316
  %63 = bitcast i8** %62 to %Simatic.Ax.Json.IJsonElement*, !dbg !1316
  store %Simatic.Ax.Json.IJsonElement* %63, %Simatic.Ax.Json.IJsonElement** %_elem, !dbg !1316
  %64 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_to, !dbg !1317
  %65 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %64 to i8**, !dbg !1317
  %66 = call i16 @"$ax.ref_equals_interfaces"(i8** %65, i8** null), !dbg !1317
  %67 = icmp ne i16 %66, 1, !dbg !1317
  br i1 %67, label %bb11, label %bb9, !dbg !1317

bb7:                                              ; preds = %bb5
  br label %bb8, !dbg !1318

bb8:                                              ; preds = %bb7
  %68 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1319
  %69 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %68, i32 0, i32 0, !dbg !1319
  %70 = load i8*, i8** %69, !dbg !1319
  %71 = bitcast i8* %70 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !1319
  %"$vTable8" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %71, i32 0, i32 4, !dbg !1319
  %72 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable8", i32 0, i32 0, !dbg !1319
  %73 = load i8*, i8** %72, !dbg !1319
  %74 = bitcast i8* %73 to i1 (%Simatic.Ax.Json.JsonDocument*, i8)*, !dbg !1319
  %75 = call i1 %74(%Simatic.Ax.Json.JsonDocument* %68, i8 125), !dbg !1319
  store i1 true, i1* %Serialize.ret, !dbg !1320
  %76 = load i1, i1* %Serialize.ret, !dbg !1321
  ret i1 %76, !dbg !1321

bb9:                                              ; preds = %bb11, %bb6
  br label %bb10, !dbg !1322

bb10:                                             ; preds = %bb9
  br label %bb5, !dbg !1322

bb11:                                             ; preds = %bb6
  %77 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1323
  %78 = getelementptr inbounds %Simatic.Ax.Json.JsonDocument, %Simatic.Ax.Json.JsonDocument* %77, i32 0, i32 0, !dbg !1323
  %79 = load i8*, i8** %78, !dbg !1323
  %80 = bitcast i8* %79 to %"$CD_Simatic.Ax.Json.JsonDocument"*, !dbg !1323
  %"$vTable7" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonDocument", %"$CD_Simatic.Ax.Json.JsonDocument"* %80, i32 0, i32 4, !dbg !1323
  %81 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable7", i32 0, i32 2, !dbg !1323
  %82 = load i8*, i8** %81, !dbg !1323
  %83 = bitcast i8* %82 to i1 (%Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !1323
  %84 = call i1 %83(%Simatic.Ax.Json.JsonDocument* %77, i8* getelementptr inbounds (%"STRING[2]", %"STRING[2]"* @"$cStr.38", i32 0, i32 0)), !dbg !1323
  br label %bb9, !dbg !1323
}

define void @"Simatic.Ax.Json.JsonObject.AddElement$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.JsonObject* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !1324 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.JsonObject*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %_elemMuted = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElement** %elem.addr, metadata !1327, metadata !DIExpression()), !dbg !1328
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonObject** %this.addr, metadata !1329, metadata !DIExpression()), !dbg !1330
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, metadata !1331, metadata !DIExpression()), !dbg !1332
  store %Simatic.Ax.Json.JsonObject* %this, %Simatic.Ax.Json.JsonObject** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1333
  %_firstElement = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr, i32 0, i32 2, !dbg !1333
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement, !dbg !1333
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !1333
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !1333
  %3 = icmp eq i16 %2, 1, !dbg !1333
  br i1 %3, label %bb5, label %bb2, !dbg !1333

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1334
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8**, !dbg !1334
  %6 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %5), !dbg !1334
  %7 = bitcast i8** %6 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1334
  store %Simatic.Ax.Json.IJsonElementMuteable* %7, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1334
  %auto_deref_this.addr4 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1335
  %_lastElement5 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr4, i32 0, i32 1, !dbg !1335
  %8 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement5, !dbg !1335
  %9 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1335
  %10 = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %8, i32 0, i32 0, !dbg !1335
  %11 = load i8*, i8** %10, !dbg !1335
  %12 = bitcast i8* %11 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1335
  %"$vTable" = getelementptr inbounds %Simatic.Ax.Json.IJsonElementMuteable, %Simatic.Ax.Json.IJsonElementMuteable* %12, i32 0, i32 1, !dbg !1335
  %13 = getelementptr inbounds [3 x i8*], [3 x i8*]* %"$vTable", i32 0, i32 0, !dbg !1335
  %14 = load i8*, i8** %13, !dbg !1335
  %15 = bitcast i8* %14 to void (%Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElement*)*, !dbg !1335
  call void %15(%Simatic.Ax.Json.IJsonElementMuteable* %8, %Simatic.Ax.Json.IJsonElement* %9), !dbg !1335
  %auto_deref_this.addr6 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1336
  %_lastElement7 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr6, i32 0, i32 1, !dbg !1336
  %16 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1336
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement7, !dbg !1336
  br label %bb3, !dbg !1336

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1337

bb4:                                              ; preds = %bb3
  ret void, !dbg !1338

bb5:                                              ; preds = %bb1
  %17 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !1339
  %18 = bitcast %Simatic.Ax.Json.IJsonElement* %17 to i8**, !dbg !1339
  %19 = call i8** @"$ax.dyn_cast_itf_itf"(i64 -1600813877, i8** %18), !dbg !1339
  %20 = bitcast i8** %19 to %Simatic.Ax.Json.IJsonElementMuteable*, !dbg !1339
  store %Simatic.Ax.Json.IJsonElementMuteable* %20, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1339
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1340
  %_firstElement2 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr1, i32 0, i32 2, !dbg !1340
  %21 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1340
  store %Simatic.Ax.Json.IJsonElementMuteable* %21, %Simatic.Ax.Json.IJsonElementMuteable** %_firstElement2, !dbg !1340
  %auto_deref_this.addr3 = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %this.addr, !dbg !1341
  %_lastElement = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %auto_deref_this.addr3, i32 0, i32 1, !dbg !1341
  %22 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %_elemMuted, !dbg !1341
  store %Simatic.Ax.Json.IJsonElementMuteable* %22, %Simatic.Ax.Json.IJsonElementMuteable** %_lastElement, !dbg !1341
  br label %bb3, !dbg !1341
}

define %STRING.0 @"Simatic.Ax.Json.JsonString.ToString$I@R@Simatic.Ax.Json.JsonString@this"(%Simatic.Ax.Json.JsonString* %this) !dbg !1342 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.JsonString*
  %_S = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonString** %this.addr, metadata !1351, metadata !DIExpression()), !dbg !1352
  call void @llvm.dbg.declare(metadata %STRING.0* %_S, metadata !1353, metadata !DIExpression()), !dbg !1354
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1355, metadata !DIExpression()), !dbg !1352
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.JsonString* %this, %Simatic.Ax.Json.JsonString** %this.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_S
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %this.addr, !dbg !1356
  %Value = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %auto_deref_this.addr, i32 0, i32 1, !dbg !1356
  %1 = bitcast %STRING.0* %_S to i8*, !dbg !1356
  %2 = bitcast %STRING.0* %Value to i8*, !dbg !1356
  call void @"$ax.AssignST_String"(i8* %1, i8* %2), !dbg !1356
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %this.addr, !dbg !1357
  %3 = bitcast %Simatic.Ax.Json.JsonString* %auto_deref_this.addr1 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1357
  %4 = bitcast %STRING.0* %_S to i8*, !dbg !1357
  %5 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %3, i32 0, i32 0, !dbg !1357
  %6 = load i8*, i8** %5, !dbg !1357
  %7 = bitcast i8* %6 to %"$CD_Simatic.Ax.Json.AbstractJsonElement"*, !dbg !1357
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.AbstractJsonElement", %"$CD_Simatic.Ax.Json.AbstractJsonElement"* %7, i32 0, i32 4, !dbg !1357
  %8 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 6, !dbg !1357
  %9 = load i8*, i8** %8, !dbg !1357
  %10 = bitcast i8* %9 to %STRING.0 (%Simatic.Ax.Json.AbstractJsonElement*, i8*)*, !dbg !1357
  %11 = call %STRING.0 %10(%Simatic.Ax.Json.AbstractJsonElement* %3, i8* %4), !dbg !1357
  store %STRING.0 %11, %STRING.0* %0, !dbg !1357
  %12 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1357
  %13 = bitcast %STRING.0* %0 to i8*, !dbg !1357
  call void @"$ax.AssignST_String"(i8* %12, i8* %13), !dbg !1357
  %14 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1358
  ret %STRING.0 %14, !dbg !1358
}

define i1 @"Simatic.Ax.Json.JsonString.Serialize$I@R@Simatic.Ax.Json.JsonString@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonString* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !1359 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.JsonString*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %_s = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonDocument** %doc.addr, metadata !1362, metadata !DIExpression()), !dbg !1363
  call void @llvm.dbg.declare(metadata %Simatic.Ax.Json.JsonString** %this.addr, metadata !1364, metadata !DIExpression()), !dbg !1365
  call void @llvm.dbg.declare(metadata %STRING.0* %_s, metadata !1366, metadata !DIExpression()), !dbg !1367
  call void @llvm.dbg.declare(metadata i1* %Serialize.ret, metadata !1368, metadata !DIExpression()), !dbg !1365
  %0 = alloca %STRING.0
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.JsonString* %this, %Simatic.Ax.Json.JsonString** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_s
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_this.addr = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %this.addr, !dbg !1369
  %1 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %auto_deref_this.addr, i32 0, i32 0, !dbg !1369
  %2 = bitcast %Simatic.Ax.Json.AbstractJsonElement* %1 to i8**, !dbg !1369
  %3 = load i8*, i8** %2, !dbg !1369
  %4 = bitcast i8* %3 to %"$CD_Simatic.Ax.Json.JsonString"*, !dbg !1369
  %"$vTable" = getelementptr inbounds %"$CD_Simatic.Ax.Json.JsonString", %"$CD_Simatic.Ax.Json.JsonString"* %4, i32 0, i32 4, !dbg !1369
  %5 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable", i32 0, i32 5, !dbg !1369
  %6 = load i8*, i8** %5, !dbg !1369
  %7 = bitcast i8* %6 to %STRING.0 (%Simatic.Ax.Json.JsonString*)*, !dbg !1369
  %8 = call %STRING.0 %7(%Simatic.Ax.Json.JsonString* %auto_deref_this.addr), !dbg !1369
  store %STRING.0 %8, %STRING.0* %0, !dbg !1369
  %9 = bitcast %STRING.0* %_s to i8*, !dbg !1369
  %10 = bitcast %STRING.0* %0 to i8*, !dbg !1369
  call void @"$ax.AssignST_String"(i8* %9, i8* %10), !dbg !1369
  %auto_deref_this.addr1 = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %this.addr, !dbg !1370
  %11 = bitcast %Simatic.Ax.Json.JsonString* %auto_deref_this.addr1 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !1370
  %12 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !1370
  %13 = bitcast %STRING.0* %_s to i8*, !dbg !1370
  %14 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %11, i32 0, i32 0, !dbg !1370
  %15 = load i8*, i8** %14, !dbg !1370
  %16 = bitcast i8* %15 to %"$CD_Simatic.Ax.Json.AbstractJsonElement"*, !dbg !1370
  %"$vTable2" = getelementptr inbounds %"$CD_Simatic.Ax.Json.AbstractJsonElement", %"$CD_Simatic.Ax.Json.AbstractJsonElement"* %16, i32 0, i32 4, !dbg !1370
  %17 = getelementptr inbounds [7 x i8*], [7 x i8*]* %"$vTable2", i32 0, i32 4, !dbg !1370
  %18 = load i8*, i8** %17, !dbg !1370
  %19 = bitcast i8* %18 to i32 (%Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.JsonDocument*, i8*)*, !dbg !1370
  %20 = call i32 %19(%Simatic.Ax.Json.AbstractJsonElement* %11, %Simatic.Ax.Json.JsonDocument* %12, i8* %13), !dbg !1370
  store i1 false, i1* %Serialize.ret, !dbg !1371
  %21 = load i1, i1* %Serialize.ret, !dbg !1372
  ret i1 %21, !dbg !1372
}

define void @MyProgram() !dbg !1373 {
Entry:
  br label %bb1, !dbg !1377

bb1:                                              ; preds = %Entry
  ret void, !dbg !1377
}

define %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %value, i16 %mode) !dbg !1378 {
Entry:
  %AnyIntToString.ret = alloca %STRING.0
  %value.addr = alloca i64
  %mode.addr = alloca i16
  %_value = alloca i64
  %digit = alloca i16
  %c = alloca i8
  %i = alloca i16
  %digits = alloca i16
  %offset = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1382, metadata !DIExpression()), !dbg !1383
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1384, metadata !DIExpression()), !dbg !1385
  call void @llvm.dbg.declare(metadata i64* %_value, metadata !1386, metadata !DIExpression()), !dbg !1387
  call void @llvm.dbg.declare(metadata i16* %digit, metadata !1388, metadata !DIExpression()), !dbg !1389
  call void @llvm.dbg.declare(metadata i8* %c, metadata !1390, metadata !DIExpression()), !dbg !1391
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1392, metadata !DIExpression()), !dbg !1393
  call void @llvm.dbg.declare(metadata i16* %digits, metadata !1394, metadata !DIExpression()), !dbg !1395
  call void @llvm.dbg.declare(metadata i16* %offset, metadata !1396, metadata !DIExpression()), !dbg !1397
  call void @llvm.dbg.declare(metadata %STRING.0* %AnyIntToString.ret, metadata !1398, metadata !DIExpression()), !dbg !1399
  %"$Simatic.Ax.Conversion.AnyIntToString_str_def" = alloca %STRING.0, !dbg !1400
  %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def" = alloca %"STRING[1]", !dbg !1400
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  %2 = alloca %STRING.0
  %3 = alloca i16
  store i16 0, i16* %3
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %AnyIntToString.ret
  store i64 %value, i64* %value.addr
  store i16 %mode, i16* %mode.addr
  store i64 0, i64* %_value
  store i16 0, i16* %digit
  store i8 0, i8* %c
  store i16 0, i16* %i
  store i16 0, i16* %digits
  store i16 0, i16* %offset
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def"
  store %"STRING[1]" { i8 1, i8 1, [2 x i8] c"0\00" }, %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def"
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def"
  store %"STRING[1]" { i8 1, i8 1, [2 x i8] c"0\00" }, %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def"
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def"
  store %"STRING[1]" { i8 1, i8 1, [2 x i8] c"0\00" }, %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = load i64, i64* %value.addr, !dbg !1401
  store i64 %4, i64* %_value, !dbg !1401
  %5 = load i64, i64* %value.addr, !dbg !1402
  %6 = call i16 @"Simatic.Ax.Conversion.CountDigits$I@V@Int64@value"(i64 %5), !dbg !1402
  store i16 %6, i16* %digits, !dbg !1402
  %7 = bitcast %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def" to i8*, !dbg !1400
  %8 = load i16, i16* %digits, !dbg !1400
  %9 = bitcast %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def" to i8*, !dbg !1400
  %10 = call %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %7, i16 %8, i8* %9), !dbg !1400
  store %STRING.0 %10, %STRING.0* %0, !dbg !1400
  %11 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1400
  %12 = bitcast %STRING.0* %0 to i8*, !dbg !1400
  call void @"$ax.AssignST_String"(i8* %11, i8* %12), !dbg !1400
  %13 = load i64, i64* %_value, !dbg !1403
  %14 = icmp slt i64 %13, 0, !dbg !1403
  br i1 %14, label %bb6, label %bb3, !dbg !1403

bb2:                                              ; preds = %bb3
  store i16 0, i16* %offset, !dbg !1404
  br label %bb4, !dbg !1404

bb3:                                              ; preds = %bb1
  %15 = load i64, i64* %_value, !dbg !1405
  %16 = icmp sgt i64 %15, 0, !dbg !1405
  %17 = load i16, i16* %mode.addr, !dbg !1405
  %18 = and i16 %17, 1, !dbg !1405
  %19 = icmp eq i16 %18, 1, !dbg !1405
  %20 = and i1 %16, %19, !dbg !1405
  br i1 %20, label %bb7, label %bb2, !dbg !1405

bb4:                                              ; preds = %bb2, %bb7, %bb6
  br label %bb5, !dbg !1406

bb5:                                              ; preds = %bb4
  %21 = load i16, i16* %digits, !dbg !1407
  %22 = sub i16 %21, 1, !dbg !1407
  store i16 %22, i16* %3, !dbg !1407
  store i16 0, i16* %i, !dbg !1408
  br label %bb10, !dbg !1409

bb6:                                              ; preds = %bb1
  %23 = load i16, i16* %digits, !dbg !1410
  %24 = add i16 %23, 1, !dbg !1410
  %25 = bitcast %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def" to i8*, !dbg !1410
  %26 = bitcast %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def" to i8*, !dbg !1410
  %27 = call %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %25, i16 %24, i8* %26), !dbg !1410
  store %STRING.0 %27, %STRING.0* %1, !dbg !1410
  %28 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1410
  %29 = bitcast %STRING.0* %1 to i8*, !dbg !1410
  call void @"$ax.AssignST_String"(i8* %28, i8* %29), !dbg !1410
  %30 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1411
  call void @"$ax.SetAtST_String"(i8* %30, i8 1, i8 45), !dbg !1411
  store i16 1, i16* %offset, !dbg !1412
  br label %bb4, !dbg !1412

bb7:                                              ; preds = %bb3
  %31 = load i16, i16* %digits, !dbg !1413
  %32 = add i16 %31, 1, !dbg !1413
  %33 = bitcast %STRING.0* %"$Simatic.Ax.Conversion.AnyIntToString_str_def" to i8*, !dbg !1413
  %34 = bitcast %"STRING[1]"* %"$Simatic.Ax.Conversion.AnyIntToString__tempString_def" to i8*, !dbg !1413
  %35 = call %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %33, i16 %32, i8* %34), !dbg !1413
  store %STRING.0 %35, %STRING.0* %2, !dbg !1413
  %36 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1413
  %37 = bitcast %STRING.0* %2 to i8*, !dbg !1413
  call void @"$ax.AssignST_String"(i8* %36, i8* %37), !dbg !1413
  %38 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1414
  call void @"$ax.SetAtST_String"(i8* %38, i8 1, i8 43), !dbg !1414
  store i16 1, i16* %offset, !dbg !1415
  br label %bb4, !dbg !1415

bb8:                                              ; preds = %bb10
  br label %bb9, !dbg !1416

bb9:                                              ; preds = %bb8
  %39 = load %STRING.0, %STRING.0* %AnyIntToString.ret, !dbg !1417
  ret %STRING.0 %39, !dbg !1417

bb10:                                             ; preds = %bb11, %bb5
  %40 = load i16, i16* %i, !dbg !1409
  %41 = load i16, i16* %3, !dbg !1409
  %42 = icmp sgt i16 %40, %41, !dbg !1409
  br i1 %42, label %bb8, label %bb12, !dbg !1409

bb11:                                             ; preds = %bb12
  %43 = load i16, i16* %i, !dbg !1409
  %44 = add i16 %43, 1, !dbg !1409
  store i16 %44, i16* %i, !dbg !1409
  br label %bb10, !dbg !1409

bb12:                                             ; preds = %bb10
  %45 = load i64, i64* %_value, !dbg !1418
  %46 = call i64 @"$ax.smod_i64"(i64 %45, i64 10), !dbg !1418
  %47 = trunc i64 %46 to i16, !dbg !1418
  %48 = call i16 @"System.Math.Abs$I@V@Int16@value"(i16 %47), !dbg !1418
  store i16 %48, i16* %digit, !dbg !1418
  %49 = load i16, i16* %digit, !dbg !1419
  %50 = trunc i16 %49 to i8, !dbg !1419
  %51 = add i8 48, %50, !dbg !1419
  store i8 %51, i8* %c, !dbg !1419
  %52 = load i16, i16* %digits, !dbg !1420
  %53 = load i16, i16* %i, !dbg !1420
  %54 = sub i16 %52, %53, !dbg !1420
  %55 = load i16, i16* %offset, !dbg !1420
  %56 = add i16 %54, %55, !dbg !1420
  %57 = trunc i16 %56 to i8, !dbg !1420
  %58 = bitcast %STRING.0* %AnyIntToString.ret to i8*, !dbg !1420
  %59 = load i8, i8* %c, !dbg !1420
  call void @"$ax.SetAtST_String"(i8* %58, i8 %57, i8 %59), !dbg !1420
  %60 = load i64, i64* %_value, !dbg !1421
  %61 = call i64 @"$ax.sdiv_i64"(i64 %60, i64 10), !dbg !1421
  store i64 %61, i64* %_value, !dbg !1421
  br label %bb11, !dbg !1409
}

define %STRING.0 @"Simatic.Ax.Conversion.ULintToString$I@V@UInt64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %value, i16 %mode) !dbg !1422 {
Entry:
  %ULintToString.ret = alloca %STRING.0
  %value.addr = alloca i64
  %mode.addr = alloca i16
  %_value = alloca i64
  %digit = alloca i16
  %c = alloca i8
  %i = alloca i16
  %digits = alloca i16
  %offset = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1425, metadata !DIExpression()), !dbg !1426
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1427, metadata !DIExpression()), !dbg !1428
  call void @llvm.dbg.declare(metadata i64* %_value, metadata !1429, metadata !DIExpression()), !dbg !1430
  call void @llvm.dbg.declare(metadata i16* %digit, metadata !1431, metadata !DIExpression()), !dbg !1432
  call void @llvm.dbg.declare(metadata i8* %c, metadata !1433, metadata !DIExpression()), !dbg !1434
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1435, metadata !DIExpression()), !dbg !1436
  call void @llvm.dbg.declare(metadata i16* %digits, metadata !1437, metadata !DIExpression()), !dbg !1438
  call void @llvm.dbg.declare(metadata i16* %offset, metadata !1439, metadata !DIExpression()), !dbg !1440
  call void @llvm.dbg.declare(metadata %STRING.0* %ULintToString.ret, metadata !1441, metadata !DIExpression()), !dbg !1442
  %"$Simatic.Ax.Conversion.ULintToString_str_def" = alloca %STRING.0, !dbg !1443
  %"$Simatic.Ax.Conversion.ULintToString__tempString_def" = alloca %"STRING[1]", !dbg !1443
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  %2 = alloca i16
  store i16 0, i16* %2
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ULintToString.ret
  store i64 %value, i64* %value.addr
  store i16 %mode, i16* %mode.addr
  store i64 0, i64* %_value
  store i16 0, i16* %digit
  store i8 0, i8* %c
  store i16 0, i16* %i
  store i16 0, i16* %digits
  store i16 0, i16* %offset
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %"$Simatic.Ax.Conversion.ULintToString_str_def"
  store %"STRING[1]" { i8 1, i8 1, [2 x i8] c"0\00" }, %"STRING[1]"* %"$Simatic.Ax.Conversion.ULintToString__tempString_def"
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %"$Simatic.Ax.Conversion.ULintToString_str_def"
  store %"STRING[1]" { i8 1, i8 1, [2 x i8] c"0\00" }, %"STRING[1]"* %"$Simatic.Ax.Conversion.ULintToString__tempString_def"
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i64, i64* %value.addr, !dbg !1444
  store i64 %3, i64* %_value, !dbg !1444
  %4 = load i64, i64* %value.addr, !dbg !1445
  %5 = call i16 @"Simatic.Ax.Conversion.CountDigits$I@V@UInt64@value"(i64 %4), !dbg !1445
  store i16 %5, i16* %digits, !dbg !1445
  %6 = bitcast %STRING.0* %"$Simatic.Ax.Conversion.ULintToString_str_def" to i8*, !dbg !1443
  %7 = load i16, i16* %digits, !dbg !1443
  %8 = bitcast %"STRING[1]"* %"$Simatic.Ax.Conversion.ULintToString__tempString_def" to i8*, !dbg !1443
  %9 = call %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %6, i16 %7, i8* %8), !dbg !1443
  store %STRING.0 %9, %STRING.0* %0, !dbg !1443
  %10 = bitcast %STRING.0* %ULintToString.ret to i8*, !dbg !1443
  %11 = bitcast %STRING.0* %0 to i8*, !dbg !1443
  call void @"$ax.AssignST_String"(i8* %10, i8* %11), !dbg !1443
  %12 = load i64, i64* %_value, !dbg !1446
  %13 = icmp ugt i64 %12, 0, !dbg !1446
  %14 = load i16, i16* %mode.addr, !dbg !1446
  %15 = and i16 %14, 1, !dbg !1446
  %16 = icmp eq i16 %15, 1, !dbg !1446
  %17 = and i1 %13, %16, !dbg !1446
  br i1 %17, label %bb5, label %bb2, !dbg !1446

bb2:                                              ; preds = %bb1
  store i16 0, i16* %offset, !dbg !1447
  br label %bb3, !dbg !1447

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1448

bb4:                                              ; preds = %bb3
  %18 = load i16, i16* %digits, !dbg !1449
  %19 = sub i16 %18, 1, !dbg !1449
  store i16 %19, i16* %2, !dbg !1449
  store i16 0, i16* %i, !dbg !1450
  br label %bb8, !dbg !1451

bb5:                                              ; preds = %bb1
  %20 = load i16, i16* %digits, !dbg !1452
  %21 = add i16 %20, 1, !dbg !1452
  %22 = bitcast %STRING.0* %"$Simatic.Ax.Conversion.ULintToString_str_def" to i8*, !dbg !1452
  %23 = bitcast %"STRING[1]"* %"$Simatic.Ax.Conversion.ULintToString__tempString_def" to i8*, !dbg !1452
  %24 = call %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %22, i16 %21, i8* %23), !dbg !1452
  store %STRING.0 %24, %STRING.0* %1, !dbg !1452
  %25 = bitcast %STRING.0* %ULintToString.ret to i8*, !dbg !1452
  %26 = bitcast %STRING.0* %1 to i8*, !dbg !1452
  call void @"$ax.AssignST_String"(i8* %25, i8* %26), !dbg !1452
  %27 = bitcast %STRING.0* %ULintToString.ret to i8*, !dbg !1453
  call void @"$ax.SetAtST_String"(i8* %27, i8 1, i8 43), !dbg !1453
  store i16 1, i16* %offset, !dbg !1454
  br label %bb3, !dbg !1454

bb6:                                              ; preds = %bb8
  br label %bb7, !dbg !1455

bb7:                                              ; preds = %bb6
  %28 = load %STRING.0, %STRING.0* %ULintToString.ret, !dbg !1456
  ret %STRING.0 %28, !dbg !1456

bb8:                                              ; preds = %bb9, %bb4
  %29 = load i16, i16* %i, !dbg !1451
  %30 = load i16, i16* %2, !dbg !1451
  %31 = icmp sgt i16 %29, %30, !dbg !1451
  br i1 %31, label %bb6, label %bb10, !dbg !1451

bb9:                                              ; preds = %bb10
  %32 = load i16, i16* %i, !dbg !1451
  %33 = add i16 %32, 1, !dbg !1451
  store i16 %33, i16* %i, !dbg !1451
  br label %bb8, !dbg !1451

bb10:                                             ; preds = %bb8
  %34 = load i64, i64* %_value, !dbg !1457
  %35 = call i64 @"$ax.umod_i64"(i64 %34, i64 10), !dbg !1457
  %36 = trunc i64 %35 to i16, !dbg !1457
  %37 = call i16 @"System.Math.Abs$I@V@Int16@value"(i16 %36), !dbg !1457
  store i16 %37, i16* %digit, !dbg !1457
  %38 = load i16, i16* %digit, !dbg !1458
  %39 = trunc i16 %38 to i8, !dbg !1458
  %40 = add i8 48, %39, !dbg !1458
  store i8 %40, i8* %c, !dbg !1458
  %41 = load i16, i16* %digits, !dbg !1459
  %42 = load i16, i16* %i, !dbg !1459
  %43 = sub i16 %41, %42, !dbg !1459
  %44 = load i16, i16* %offset, !dbg !1459
  %45 = add i16 %43, %44, !dbg !1459
  %46 = trunc i16 %45 to i8, !dbg !1459
  %47 = bitcast %STRING.0* %ULintToString.ret to i8*, !dbg !1459
  %48 = load i8, i8* %c, !dbg !1459
  call void @"$ax.SetAtST_String"(i8* %47, i8 %46, i8 %48), !dbg !1459
  %49 = load i64, i64* %_value, !dbg !1460
  %50 = udiv i64 %49, 10, !dbg !1460
  store i64 %50, i64* %_value, !dbg !1460
  br label %bb9, !dbg !1451
}

define %STRING.0 @"Simatic.Ax.Conversion.Arrays.ToString$I@V@ARRAY [*] OF CHAR@arr?I@V@Int16@startIdx?I@V@Int16@endIdx"(%"$ax.ArrayWithBound" %arr, i16 %startIdx, i16 %endIdx) !dbg !1461 {
Entry:
  %ToString.ret = alloca %STRING.0
  %arr.addr = alloca %"$ax.ArrayWithBound"
  %startIdx.addr = alloca i16
  %endIdx.addr = alloca i16
  %i = alloca i32
  %_lb = alloca i32
  %_ub = alloca i32
  %_arrayLen = alloca i32
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %arr.addr, metadata !1466, metadata !DIExpression()), !dbg !1467
  call void @llvm.dbg.declare(metadata i16* %startIdx.addr, metadata !1468, metadata !DIExpression()), !dbg !1469
  call void @llvm.dbg.declare(metadata i16* %endIdx.addr, metadata !1470, metadata !DIExpression()), !dbg !1471
  call void @llvm.dbg.declare(metadata i32* %i, metadata !1472, metadata !DIExpression()), !dbg !1473
  call void @llvm.dbg.declare(metadata i32* %_lb, metadata !1474, metadata !DIExpression()), !dbg !1475
  call void @llvm.dbg.declare(metadata i32* %_ub, metadata !1476, metadata !DIExpression()), !dbg !1477
  call void @llvm.dbg.declare(metadata i32* %_arrayLen, metadata !1478, metadata !DIExpression()), !dbg !1479
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1480, metadata !DIExpression()), !dbg !1481
  %0 = alloca i32
  store i32 0, i32* %0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %"$ax.ArrayWithBound" %arr, %"$ax.ArrayWithBound"* %arr.addr
  store i16 %startIdx, i16* %startIdx.addr
  store i16 %endIdx, i16* %endIdx.addr
  store i32 0, i32* %i
  store i32 0, i32* %_lb
  store i32 0, i32* %_ub
  store i32 0, i32* %_arrayLen
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = call i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* %arr.addr, i32 1), !dbg !1482
  store i32 %1, i32* %_lb, !dbg !1482
  %2 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %arr.addr, i32 1), !dbg !1483
  store i32 %2, i32* %_ub, !dbg !1483
  %3 = load i16, i16* %startIdx.addr, !dbg !1484
  %4 = load i16, i16* %endIdx.addr, !dbg !1484
  %5 = icmp sgt i16 %3, %4, !dbg !1484
  br i1 %5, label %bb4, label %bb2, !dbg !1484

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3, !dbg !1485

bb3:                                              ; preds = %bb2
  %6 = load i16, i16* %startIdx.addr, !dbg !1486
  %7 = sext i16 %6 to i32, !dbg !1486
  %8 = load i32, i32* %_lb, !dbg !1486
  %9 = icmp slt i32 %7, %8, !dbg !1486
  %10 = load i16, i16* %startIdx.addr, !dbg !1486
  %11 = sext i16 %10 to i32, !dbg !1486
  %12 = load i32, i32* %_ub, !dbg !1486
  %13 = icmp sgt i32 %11, %12, !dbg !1486
  %14 = load i16, i16* %startIdx.addr, !dbg !1486
  %15 = icmp ne i16 %14, 0, !dbg !1486
  %16 = and i1 %13, %15, !dbg !1486
  %17 = or i1 %9, %16, !dbg !1486
  br i1 %17, label %bb8, label %bb6, !dbg !1486

bb4:                                              ; preds = %bb1
  %18 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1487
  call void @"$ax.AssignST_String"(i8* %18, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr", i32 0, i32 0)), !dbg !1487
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1488
  ret %STRING.0 %19, !dbg !1488

bb5:                                              ; No predecessors!
  br label %bb2, !dbg !1488

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7, !dbg !1489

bb7:                                              ; preds = %bb6
  %20 = load i16, i16* %endIdx.addr, !dbg !1490
  %21 = sext i16 %20 to i32, !dbg !1490
  %22 = load i32, i32* %_ub, !dbg !1490
  %23 = icmp sgt i32 %21, %22, !dbg !1490
  br i1 %23, label %bb12, label %bb10, !dbg !1490

bb8:                                              ; preds = %bb3
  %24 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1491
  call void @"$ax.AssignST_String"(i8* %24, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr.1", i32 0, i32 0)), !dbg !1491
  %25 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1492
  ret %STRING.0 %25, !dbg !1492

bb9:                                              ; No predecessors!
  br label %bb6, !dbg !1492

bb10:                                             ; preds = %bb13, %bb7
  br label %bb11, !dbg !1493

bb11:                                             ; preds = %bb10
  %26 = load i16, i16* %endIdx.addr, !dbg !1494
  %27 = load i16, i16* %startIdx.addr, !dbg !1494
  %28 = sub i16 %26, %27, !dbg !1494
  %29 = add i16 %28, 1, !dbg !1494
  %30 = sext i16 %29 to i32, !dbg !1494
  store i32 %30, i32* %_arrayLen, !dbg !1494
  %31 = load i32, i32* %_arrayLen, !dbg !1495
  %32 = icmp sgt i32 %31, 254, !dbg !1495
  br i1 %32, label %bb16, label %bb14, !dbg !1495

bb12:                                             ; preds = %bb7
  %33 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1496
  call void @"$ax.AssignST_String"(i8* %33, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr.2", i32 0, i32 0)), !dbg !1496
  %34 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1497
  ret %STRING.0 %34, !dbg !1497

bb13:                                             ; No predecessors!
  br label %bb10, !dbg !1497

bb14:                                             ; preds = %bb16, %bb11
  br label %bb15, !dbg !1498

bb15:                                             ; preds = %bb14
  %35 = load i32, i32* %_arrayLen, !dbg !1499
  %36 = sub i32 %35, 1, !dbg !1499
  store i32 %36, i32* %0, !dbg !1499
  store i32 0, i32* %i, !dbg !1500
  br label %bb19, !dbg !1501

bb16:                                             ; preds = %bb11
  store i32 254, i32* %_arrayLen, !dbg !1502
  br label %bb14, !dbg !1502

bb17:                                             ; preds = %bb19
  br label %bb18, !dbg !1503

bb18:                                             ; preds = %bb17
  %37 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1504
  ret %STRING.0 %37, !dbg !1504

bb19:                                             ; preds = %bb20, %bb15
  %38 = load i32, i32* %i, !dbg !1501
  %39 = load i32, i32* %0, !dbg !1501
  %40 = icmp sgt i32 %38, %39, !dbg !1501
  br i1 %40, label %bb17, label %bb21, !dbg !1501

bb20:                                             ; preds = %bb21
  %41 = load i32, i32* %i, !dbg !1501
  %42 = add i32 %41, 1, !dbg !1501
  store i32 %42, i32* %i, !dbg !1501
  br label %bb19, !dbg !1501

bb21:                                             ; preds = %bb19
  %43 = load i32, i32* %i, !dbg !1505
  %44 = load i32, i32* %_lb, !dbg !1505
  %45 = add i32 %43, %44, !dbg !1505
  %46 = load i16, i16* %startIdx.addr, !dbg !1505
  %47 = sext i16 %46 to i32, !dbg !1505
  %48 = add i32 %45, %47, !dbg !1505
  %49 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %arr.addr, i32 0, i32 0, !dbg !1505
  %"$elementPtr" = load i8*, i8** %49, !dbg !1505
  %"$allBounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %arr.addr, i32 0, i32 2, !dbg !1505
  %50 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds", !dbg !1505
  %"$bounds0" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %50, i32 0, !dbg !1505
  %51 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 0, !dbg !1505
  %"$lowerBound0" = load i32, i32* %51, !dbg !1505
  %52 = sub i32 %48, %"$lowerBound0", !dbg !1505
  %53 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 2, !dbg !1505
  %"$countNextDims0" = load i32, i32* %53, !dbg !1505
  %54 = mul i32 %52, %"$countNextDims0", !dbg !1505
  %"$gepIndex0" = add i32 0, %54, !dbg !1505
  %55 = getelementptr i8, i8* %"$elementPtr", i32 %"$gepIndex0", !dbg !1505
  %56 = load i32, i32* %i, !dbg !1505
  %57 = add i32 %56, 1, !dbg !1505
  %58 = trunc i32 %57 to i8, !dbg !1505
  %59 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1505
  %60 = load i8, i8* %55, !dbg !1505
  call void @"$ax.SetAtST_String"(i8* %59, i8 %58, i8 %60), !dbg !1505
  br label %bb20, !dbg !1501
}

define %STRING.0 @"Simatic.Ax.Conversion.Arrays.ToString$I@V@ARRAY [*] OF CHAR@arr"(%"$ax.ArrayWithBound" %arr) !dbg !1506 {
Entry:
  %ToString.ret = alloca %STRING.0
  %arr.addr = alloca %"$ax.ArrayWithBound"
  %i = alloca i32
  %_lb = alloca i32
  %_ub = alloca i32
  %_arrayLen = alloca i32
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %arr.addr, metadata !1509, metadata !DIExpression()), !dbg !1510
  call void @llvm.dbg.declare(metadata i32* %i, metadata !1511, metadata !DIExpression()), !dbg !1512
  call void @llvm.dbg.declare(metadata i32* %_lb, metadata !1513, metadata !DIExpression()), !dbg !1514
  call void @llvm.dbg.declare(metadata i32* %_ub, metadata !1515, metadata !DIExpression()), !dbg !1516
  call void @llvm.dbg.declare(metadata i32* %_arrayLen, metadata !1517, metadata !DIExpression()), !dbg !1518
  call void @llvm.dbg.declare(metadata %STRING.0* %ToString.ret, metadata !1519, metadata !DIExpression()), !dbg !1520
  %0 = alloca i32
  store i32 0, i32* %0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %"$ax.ArrayWithBound" %arr, %"$ax.ArrayWithBound"* %arr.addr
  store i32 0, i32* %i
  store i32 0, i32* %_lb
  store i32 0, i32* %_ub
  store i32 0, i32* %_arrayLen
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = call i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* %arr.addr, i32 1), !dbg !1521
  store i32 %1, i32* %_lb, !dbg !1521
  %2 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %arr.addr, i32 1), !dbg !1522
  store i32 %2, i32* %_ub, !dbg !1522
  %3 = load i32, i32* %_ub, !dbg !1523
  %4 = load i32, i32* %_lb, !dbg !1523
  %5 = sub i32 %3, %4, !dbg !1523
  %6 = add i32 %5, 1, !dbg !1523
  store i32 %6, i32* %_arrayLen, !dbg !1523
  %7 = load i32, i32* %_arrayLen, !dbg !1524
  %8 = icmp sgt i32 %7, 254, !dbg !1524
  br i1 %8, label %bb4, label %bb2, !dbg !1524

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !1525

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %_arrayLen, !dbg !1526
  %10 = sub i32 %9, 1, !dbg !1526
  store i32 %10, i32* %0, !dbg !1526
  store i32 0, i32* %i, !dbg !1527
  br label %bb7, !dbg !1528

bb4:                                              ; preds = %bb1
  store i32 254, i32* %_arrayLen, !dbg !1529
  br label %bb2, !dbg !1529

bb5:                                              ; preds = %bb7
  br label %bb6, !dbg !1530

bb6:                                              ; preds = %bb5
  %11 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !1531
  ret %STRING.0 %11, !dbg !1531

bb7:                                              ; preds = %bb8, %bb3
  %12 = load i32, i32* %i, !dbg !1528
  %13 = load i32, i32* %0, !dbg !1528
  %14 = icmp sgt i32 %12, %13, !dbg !1528
  br i1 %14, label %bb5, label %bb9, !dbg !1528

bb8:                                              ; preds = %bb9
  %15 = load i32, i32* %i, !dbg !1528
  %16 = add i32 %15, 1, !dbg !1528
  store i32 %16, i32* %i, !dbg !1528
  br label %bb7, !dbg !1528

bb9:                                              ; preds = %bb7
  %17 = load i32, i32* %i, !dbg !1532
  %18 = load i32, i32* %_lb, !dbg !1532
  %19 = add i32 %17, %18, !dbg !1532
  %20 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %arr.addr, i32 0, i32 0, !dbg !1532
  %"$elementPtr" = load i8*, i8** %20, !dbg !1532
  %"$allBounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %arr.addr, i32 0, i32 2, !dbg !1532
  %21 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds", !dbg !1532
  %"$bounds0" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %21, i32 0, !dbg !1532
  %22 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 0, !dbg !1532
  %"$lowerBound0" = load i32, i32* %22, !dbg !1532
  %23 = sub i32 %19, %"$lowerBound0", !dbg !1532
  %24 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 2, !dbg !1532
  %"$countNextDims0" = load i32, i32* %24, !dbg !1532
  %25 = mul i32 %23, %"$countNextDims0", !dbg !1532
  %"$gepIndex0" = add i32 0, %25, !dbg !1532
  %26 = getelementptr i8, i8* %"$elementPtr", i32 %"$gepIndex0", !dbg !1532
  %27 = load i32, i32* %i, !dbg !1532
  %28 = add i32 %27, 1, !dbg !1532
  %29 = trunc i32 %28 to i8, !dbg !1532
  %30 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !1532
  %31 = load i8, i8* %26, !dbg !1532
  call void @"$ax.SetAtST_String"(i8* %30, i8 %29, i8 %31), !dbg !1532
  br label %bb8, !dbg !1528
}

define i16 @"Simatic.Ax.Conversion.CountDigits$I@V@Int64@value"(i64 %value) !dbg !1533 {
Entry:
  %CountDigits.ret = alloca i16
  %value.addr = alloca i64
  %divisor = alloca i64
  %i = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1537, metadata !DIExpression()), !dbg !1538
  call void @llvm.dbg.declare(metadata i64* %divisor, metadata !1539, metadata !DIExpression()), !dbg !1540
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1541, metadata !DIExpression()), !dbg !1542
  call void @llvm.dbg.declare(metadata i16* %CountDigits.ret, metadata !1543, metadata !DIExpression()), !dbg !1544
  %0 = alloca i16
  store i16 0, i16* %0
  store i16 0, i16* %CountDigits.ret
  store i64 %value, i64* %value.addr
  store i64 1, i64* %divisor
  store i16 0, i16* %i
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i64, i64* %value.addr, !dbg !1545
  %2 = icmp eq i64 %1, 0, !dbg !1545
  br i1 %2, label %bb4, label %bb2, !dbg !1545

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3, !dbg !1546

bb3:                                              ; preds = %bb2
  store i16 19, i16* %0, !dbg !1547
  store i16 0, i16* %i, !dbg !1548
  br label %bb8, !dbg !1549

bb4:                                              ; preds = %bb1
  store i16 1, i16* %CountDigits.ret, !dbg !1550
  %3 = load i16, i16* %CountDigits.ret, !dbg !1551
  ret i16 %3, !dbg !1551

bb5:                                              ; No predecessors!
  br label %bb2, !dbg !1551

bb6:                                              ; preds = %bb8
  br label %bb7, !dbg !1552

bb7:                                              ; preds = %bb6
  store i16 19, i16* %CountDigits.ret, !dbg !1553
  %4 = load i16, i16* %CountDigits.ret, !dbg !1554
  ret i16 %4, !dbg !1554

bb8:                                              ; preds = %bb9, %bb3
  %5 = load i16, i16* %i, !dbg !1549
  %6 = load i16, i16* %0, !dbg !1549
  %7 = icmp sgt i16 %5, %6, !dbg !1549
  br i1 %7, label %bb6, label %bb10, !dbg !1549

bb9:                                              ; preds = %bb12
  %8 = load i16, i16* %i, !dbg !1549
  %9 = add i16 %8, 1, !dbg !1549
  store i16 %9, i16* %i, !dbg !1549
  br label %bb8, !dbg !1549

bb10:                                             ; preds = %bb8
  %10 = load i64, i64* %value.addr, !dbg !1555
  %11 = load i64, i64* %divisor, !dbg !1555
  %12 = call i64 @"$ax.sdiv_i64"(i64 %10, i64 %11), !dbg !1555
  %13 = icmp eq i64 %12, 0, !dbg !1555
  br i1 %13, label %bb13, label %bb11, !dbg !1555

bb11:                                             ; preds = %bb14, %bb10
  br label %bb12, !dbg !1556

bb12:                                             ; preds = %bb11
  %14 = load i64, i64* %divisor, !dbg !1557
  %15 = mul i64 %14, 10, !dbg !1557
  store i64 %15, i64* %divisor, !dbg !1557
  br label %bb9, !dbg !1549

bb13:                                             ; preds = %bb10
  %16 = load i16, i16* %i, !dbg !1558
  store i16 %16, i16* %CountDigits.ret, !dbg !1558
  %17 = load i16, i16* %CountDigits.ret, !dbg !1559
  ret i16 %17, !dbg !1559

bb14:                                             ; No predecessors!
  br label %bb11, !dbg !1559
}

define i16 @"Simatic.Ax.Conversion.CountDigits$I@V@UInt64@value"(i64 %value) !dbg !1560 {
Entry:
  %CountDigits.ret = alloca i16
  %value.addr = alloca i64
  %divisor = alloca i64
  %i = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1563, metadata !DIExpression()), !dbg !1564
  call void @llvm.dbg.declare(metadata i64* %divisor, metadata !1565, metadata !DIExpression()), !dbg !1566
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1567, metadata !DIExpression()), !dbg !1568
  call void @llvm.dbg.declare(metadata i16* %CountDigits.ret, metadata !1569, metadata !DIExpression()), !dbg !1570
  %0 = alloca i16
  store i16 0, i16* %0
  store i16 0, i16* %CountDigits.ret
  store i64 %value, i64* %value.addr
  store i64 1, i64* %divisor
  store i16 0, i16* %i
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i64, i64* %value.addr, !dbg !1571
  %2 = icmp eq i64 %1, 0, !dbg !1571
  br i1 %2, label %bb4, label %bb2, !dbg !1571

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3, !dbg !1572

bb3:                                              ; preds = %bb2
  store i16 19, i16* %0, !dbg !1573
  store i16 0, i16* %i, !dbg !1574
  br label %bb8, !dbg !1575

bb4:                                              ; preds = %bb1
  store i16 1, i16* %CountDigits.ret, !dbg !1576
  %3 = load i16, i16* %CountDigits.ret, !dbg !1577
  ret i16 %3, !dbg !1577

bb5:                                              ; No predecessors!
  br label %bb2, !dbg !1577

bb6:                                              ; preds = %bb8
  br label %bb7, !dbg !1578

bb7:                                              ; preds = %bb6
  store i16 20, i16* %CountDigits.ret, !dbg !1579
  %4 = load i16, i16* %CountDigits.ret, !dbg !1580
  ret i16 %4, !dbg !1580

bb8:                                              ; preds = %bb9, %bb3
  %5 = load i16, i16* %i, !dbg !1575
  %6 = load i16, i16* %0, !dbg !1575
  %7 = icmp sgt i16 %5, %6, !dbg !1575
  br i1 %7, label %bb6, label %bb10, !dbg !1575

bb9:                                              ; preds = %bb12
  %8 = load i16, i16* %i, !dbg !1575
  %9 = add i16 %8, 1, !dbg !1575
  store i16 %9, i16* %i, !dbg !1575
  br label %bb8, !dbg !1575

bb10:                                             ; preds = %bb8
  %10 = load i64, i64* %value.addr, !dbg !1581
  %11 = load i64, i64* %divisor, !dbg !1581
  %12 = udiv i64 %10, %11, !dbg !1581
  %13 = icmp eq i64 %12, 0, !dbg !1581
  br i1 %13, label %bb13, label %bb11, !dbg !1581

bb11:                                             ; preds = %bb14, %bb10
  br label %bb12, !dbg !1582

bb12:                                             ; preds = %bb11
  %14 = load i64, i64* %divisor, !dbg !1583
  %15 = mul i64 %14, 10, !dbg !1583
  store i64 %15, i64* %divisor, !dbg !1583
  br label %bb9, !dbg !1575

bb13:                                             ; preds = %bb10
  %16 = load i16, i16* %i, !dbg !1584
  store i16 %16, i16* %CountDigits.ret, !dbg !1584
  %17 = load i16, i16* %CountDigits.ret, !dbg !1585
  ret i16 %17, !dbg !1585

bb14:                                             ; No predecessors!
  br label %bb11, !dbg !1585
}

define %STRING.0 @"Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString"(i8* %str, i16 %len, i8* %_tempString) !dbg !1586 {
Entry:
  %CreateStringWithBlanksOfLength.ret = alloca %STRING.0
  %str.addr = alloca %STRING.0
  %len.addr = alloca i16
  %_tempString.addr = alloca %"STRING[1]"
  %i = alloca i16
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1590, metadata !DIExpression()), !dbg !1591
  call void @llvm.dbg.declare(metadata i16* %len.addr, metadata !1592, metadata !DIExpression()), !dbg !1593
  call void @llvm.dbg.declare(metadata %"STRING[1]"* %_tempString.addr, metadata !1594, metadata !DIExpression()), !dbg !1599
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1600, metadata !DIExpression()), !dbg !1601
  call void @llvm.dbg.declare(metadata %STRING.0* %CreateStringWithBlanksOfLength.ret, metadata !1602, metadata !DIExpression()), !dbg !1603
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %CreateStringWithBlanksOfLength.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %2 = bitcast %STRING.0* %str.addr to i8*, !dbg !1603
  call void @"$ax.AssignST_String"(i8* %2, i8* %str), !dbg !1603
  store i16 %len, i16* %len.addr
  store %"STRING[1]" { i8 1, i8 0, [2 x i8] zeroinitializer }, %"STRING[1]"* %_tempString.addr
  %3 = bitcast %"STRING[1]"* %_tempString.addr to i8*, !dbg !1603
  call void @"$ax.AssignST_String"(i8* %3, i8* %_tempString), !dbg !1603
  store i16 0, i16* %i
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = bitcast %STRING.0* %CreateStringWithBlanksOfLength.ret to i8*, !dbg !1604
  call void @"$ax.AssignST_String"(i8* %4, i8* getelementptr inbounds (%"STRING[0]", %"STRING[0]"* @"$cStr.3", i32 0, i32 0)), !dbg !1604
  %5 = load i16, i16* %len.addr, !dbg !1605
  store i16 %5, i16* %0, !dbg !1605
  store i16 1, i16* %i, !dbg !1606
  br label %bb4, !dbg !1607

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !1608

bb3:                                              ; preds = %bb2
  %6 = load %STRING.0, %STRING.0* %CreateStringWithBlanksOfLength.ret, !dbg !1609
  ret %STRING.0 %6, !dbg !1609

bb4:                                              ; preds = %bb5, %bb1
  %7 = load i16, i16* %i, !dbg !1607
  %8 = load i16, i16* %0, !dbg !1607
  %9 = icmp sgt i16 %7, %8, !dbg !1607
  br i1 %9, label %bb2, label %bb6, !dbg !1607

bb5:                                              ; preds = %bb6
  %10 = load i16, i16* %i, !dbg !1607
  %11 = add i16 %10, 1, !dbg !1607
  store i16 %11, i16* %i, !dbg !1607
  br label %bb4, !dbg !1607

bb6:                                              ; preds = %bb4
  %12 = bitcast %STRING.0* %CreateStringWithBlanksOfLength.ret to i8*, !dbg !1610
  %13 = bitcast %"STRING[1]"* %_tempString.addr to i8*, !dbg !1610
  %14 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %12, i8* %13), !dbg !1610
  store %STRING.0 %14, %STRING.0* %1, !dbg !1610
  %15 = bitcast %STRING.0* %CreateStringWithBlanksOfLength.ret to i8*, !dbg !1610
  %16 = bitcast %STRING.0* %1 to i8*, !dbg !1610
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !1610
  br label %bb5, !dbg !1607
}

define %"STRING[4]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i8 %value, i16 %mode) !dbg !1611 {
Entry:
  %ToString.ret = alloca %"STRING[4]"
  %value.addr = alloca i8
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !1622, metadata !DIExpression()), !dbg !1623
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1624, metadata !DIExpression()), !dbg !1625
  call void @llvm.dbg.declare(metadata %"STRING[4]"* %ToString.ret, metadata !1626, metadata !DIExpression()), !dbg !1627
  %0 = alloca %STRING.0
  store %"STRING[4]" { i8 4, i8 0, [5 x i8] zeroinitializer }, %"STRING[4]"* %ToString.ret
  store i8 %value, i8* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i8, i8* %value.addr, !dbg !1628
  %2 = sext i8 %1 to i64, !dbg !1628
  %3 = load i16, i16* %mode.addr, !dbg !1628
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1628
  store %STRING.0 %4, %STRING.0* %0, !dbg !1628
  %5 = bitcast %"STRING[4]"* %ToString.ret to i8*, !dbg !1628
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1628
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1628
  %7 = load %"STRING[4]", %"STRING[4]"* %ToString.ret, !dbg !1629
  ret %"STRING[4]" %7, !dbg !1629
}

define %"STRING[4]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@UInt8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i8 %value, i16 %mode) !dbg !1630 {
Entry:
  %ToString.ret = alloca %"STRING[4]"
  %value.addr = alloca i8
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !1633, metadata !DIExpression()), !dbg !1634
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1635, metadata !DIExpression()), !dbg !1636
  call void @llvm.dbg.declare(metadata %"STRING[4]"* %ToString.ret, metadata !1637, metadata !DIExpression()), !dbg !1638
  %0 = alloca %STRING.0
  store %"STRING[4]" { i8 4, i8 0, [5 x i8] zeroinitializer }, %"STRING[4]"* %ToString.ret
  store i8 %value, i8* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i8, i8* %value.addr, !dbg !1639
  %2 = zext i8 %1 to i64, !dbg !1639
  %3 = load i16, i16* %mode.addr, !dbg !1639
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1639
  store %STRING.0 %4, %STRING.0* %0, !dbg !1639
  %5 = bitcast %"STRING[4]"* %ToString.ret to i8*, !dbg !1639
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1639
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1639
  %7 = load %"STRING[4]", %"STRING[4]"* %ToString.ret, !dbg !1640
  ret %"STRING[4]" %7, !dbg !1640
}

define %"STRING[6]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int16@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i16 %value, i16 %mode) !dbg !1641 {
Entry:
  %ToString.ret = alloca %"STRING[6]"
  %value.addr = alloca i16
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !1650, metadata !DIExpression()), !dbg !1651
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1652, metadata !DIExpression()), !dbg !1653
  call void @llvm.dbg.declare(metadata %"STRING[6]"* %ToString.ret, metadata !1654, metadata !DIExpression()), !dbg !1655
  %0 = alloca %STRING.0
  store %"STRING[6]" { i8 6, i8 0, [7 x i8] zeroinitializer }, %"STRING[6]"* %ToString.ret
  store i16 %value, i16* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i16, i16* %value.addr, !dbg !1656
  %2 = sext i16 %1 to i64, !dbg !1656
  %3 = load i16, i16* %mode.addr, !dbg !1656
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1656
  store %STRING.0 %4, %STRING.0* %0, !dbg !1656
  %5 = bitcast %"STRING[6]"* %ToString.ret to i8*, !dbg !1656
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1656
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1656
  %7 = load %"STRING[6]", %"STRING[6]"* %ToString.ret, !dbg !1657
  ret %"STRING[6]" %7, !dbg !1657
}

define %"STRING[6]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@UInt16@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i16 %value, i16 %mode) !dbg !1658 {
Entry:
  %ToString.ret = alloca %"STRING[6]"
  %value.addr = alloca i16
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !1661, metadata !DIExpression()), !dbg !1662
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1663, metadata !DIExpression()), !dbg !1664
  call void @llvm.dbg.declare(metadata %"STRING[6]"* %ToString.ret, metadata !1665, metadata !DIExpression()), !dbg !1666
  %0 = alloca %STRING.0
  store %"STRING[6]" { i8 6, i8 0, [7 x i8] zeroinitializer }, %"STRING[6]"* %ToString.ret
  store i16 %value, i16* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i16, i16* %value.addr, !dbg !1667
  %2 = zext i16 %1 to i64, !dbg !1667
  %3 = load i16, i16* %mode.addr, !dbg !1667
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1667
  store %STRING.0 %4, %STRING.0* %0, !dbg !1667
  %5 = bitcast %"STRING[6]"* %ToString.ret to i8*, !dbg !1667
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1667
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1667
  %7 = load %"STRING[6]", %"STRING[6]"* %ToString.ret, !dbg !1668
  ret %"STRING[6]" %7, !dbg !1668
}

define %"STRING[11]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int32@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i32 %value, i16 %mode) !dbg !1669 {
Entry:
  %ToString.ret = alloca %"STRING[11]"
  %value.addr = alloca i32
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !1678, metadata !DIExpression()), !dbg !1679
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1680, metadata !DIExpression()), !dbg !1681
  call void @llvm.dbg.declare(metadata %"STRING[11]"* %ToString.ret, metadata !1682, metadata !DIExpression()), !dbg !1683
  %0 = alloca %STRING.0
  store %"STRING[11]" { i8 11, i8 0, [12 x i8] zeroinitializer }, %"STRING[11]"* %ToString.ret
  store i32 %value, i32* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i32, i32* %value.addr, !dbg !1684
  %2 = sext i32 %1 to i64, !dbg !1684
  %3 = load i16, i16* %mode.addr, !dbg !1684
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1684
  store %STRING.0 %4, %STRING.0* %0, !dbg !1684
  %5 = bitcast %"STRING[11]"* %ToString.ret to i8*, !dbg !1684
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1684
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1684
  %7 = load %"STRING[11]", %"STRING[11]"* %ToString.ret, !dbg !1685
  ret %"STRING[11]" %7, !dbg !1685
}

define %"STRING[11]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@UInt32@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i32 %value, i16 %mode) !dbg !1686 {
Entry:
  %ToString.ret = alloca %"STRING[11]"
  %value.addr = alloca i32
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !1689, metadata !DIExpression()), !dbg !1690
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1691, metadata !DIExpression()), !dbg !1692
  call void @llvm.dbg.declare(metadata %"STRING[11]"* %ToString.ret, metadata !1693, metadata !DIExpression()), !dbg !1694
  %0 = alloca %STRING.0
  store %"STRING[11]" { i8 11, i8 0, [12 x i8] zeroinitializer }, %"STRING[11]"* %ToString.ret
  store i32 %value, i32* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i32, i32* %value.addr, !dbg !1695
  %2 = zext i32 %1 to i64, !dbg !1695
  %3 = load i16, i16* %mode.addr, !dbg !1695
  %4 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %2, i16 %3), !dbg !1695
  store %STRING.0 %4, %STRING.0* %0, !dbg !1695
  %5 = bitcast %"STRING[11]"* %ToString.ret to i8*, !dbg !1695
  %6 = bitcast %STRING.0* %0 to i8*, !dbg !1695
  call void @"$ax.AssignST_String"(i8* %5, i8* %6), !dbg !1695
  %7 = load %"STRING[11]", %"STRING[11]"* %ToString.ret, !dbg !1696
  ret %"STRING[11]" %7, !dbg !1696
}

define %"STRING[20]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %value, i16 %mode) !dbg !1697 {
Entry:
  %ToString.ret = alloca %"STRING[20]"
  %value.addr = alloca i64
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1706, metadata !DIExpression()), !dbg !1707
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1708, metadata !DIExpression()), !dbg !1709
  call void @llvm.dbg.declare(metadata %"STRING[20]"* %ToString.ret, metadata !1710, metadata !DIExpression()), !dbg !1711
  %0 = alloca %STRING.0
  store %"STRING[20]" { i8 20, i8 0, [21 x i8] zeroinitializer }, %"STRING[20]"* %ToString.ret
  store i64 %value, i64* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i64, i64* %value.addr, !dbg !1712
  %2 = load i16, i16* %mode.addr, !dbg !1712
  %3 = call %STRING.0 @"Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %1, i16 %2), !dbg !1712
  store %STRING.0 %3, %STRING.0* %0, !dbg !1712
  %4 = bitcast %"STRING[20]"* %ToString.ret to i8*, !dbg !1712
  %5 = bitcast %STRING.0* %0 to i8*, !dbg !1712
  call void @"$ax.AssignST_String"(i8* %4, i8* %5), !dbg !1712
  %6 = load %"STRING[20]", %"STRING[20]"* %ToString.ret, !dbg !1713
  ret %"STRING[20]" %6, !dbg !1713
}

define %"STRING[21]" @"Simatic.Ax.Conversion.Integer.ToString$I@V@UInt64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %value, i16 %mode) !dbg !1714 {
Entry:
  %ToString.ret = alloca %"STRING[21]"
  %value.addr = alloca i64
  %mode.addr = alloca i16
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !1723, metadata !DIExpression()), !dbg !1724
  call void @llvm.dbg.declare(metadata i16* %mode.addr, metadata !1725, metadata !DIExpression()), !dbg !1726
  call void @llvm.dbg.declare(metadata %"STRING[21]"* %ToString.ret, metadata !1727, metadata !DIExpression()), !dbg !1728
  %0 = alloca %STRING.0
  store %"STRING[21]" { i8 21, i8 0, [22 x i8] zeroinitializer }, %"STRING[21]"* %ToString.ret
  store i64 %value, i64* %value.addr
  store i16 %mode, i16* %mode.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load i64, i64* %value.addr, !dbg !1729
  %2 = load i16, i16* %mode.addr, !dbg !1729
  %3 = call %STRING.0 @"Simatic.Ax.Conversion.ULintToString$I@V@UInt64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode"(i64 %1, i16 %2), !dbg !1729
  store %STRING.0 %3, %STRING.0* %0, !dbg !1729
  %4 = bitcast %"STRING[21]"* %ToString.ret to i8*, !dbg !1729
  %5 = bitcast %STRING.0* %0 to i8*, !dbg !1729
  call void @"$ax.AssignST_String"(i8* %4, i8* %5), !dbg !1729
  %6 = load %"STRING[21]", %"STRING[21]"* %ToString.ret, !dbg !1730
  ret %"STRING[21]" %6, !dbg !1730
}

define i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %str, i64* %value) !dbg !1731 {
Entry:
  %StringToAnyInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %_len = alloca i16
  %i = alloca i16
  %_val = alloca i16
  %_sig = alloca i16
  %_start = alloca i16
  %_c = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1735, metadata !DIExpression()), !dbg !1736
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !1737, metadata !DIExpression()), !dbg !1738
  call void @llvm.dbg.declare(metadata i16* %_len, metadata !1739, metadata !DIExpression()), !dbg !1740
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1741, metadata !DIExpression()), !dbg !1742
  call void @llvm.dbg.declare(metadata i16* %_val, metadata !1743, metadata !DIExpression()), !dbg !1744
  call void @llvm.dbg.declare(metadata i16* %_sig, metadata !1745, metadata !DIExpression()), !dbg !1746
  call void @llvm.dbg.declare(metadata i16* %_start, metadata !1747, metadata !DIExpression()), !dbg !1748
  call void @llvm.dbg.declare(metadata %STRING.0* %_c, metadata !1749, metadata !DIExpression()), !dbg !1750
  call void @llvm.dbg.declare(metadata i1* %StringToAnyInt.ret, metadata !1751, metadata !DIExpression()), !dbg !1752
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %1
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %3
  %4 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %4
  %5 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %5
  %6 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %6
  %7 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %7
  %8 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %8
  %9 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %9
  %10 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %10
  %11 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %11
  %12 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %12
  store i1 false, i1* %StringToAnyInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %13 = bitcast %STRING.0* %str.addr to i8*, !dbg !1752
  call void @"$ax.AssignST_String"(i8* %13, i8* %str), !dbg !1752
  store i64* %value, i64** %value.addr
  store i16 0, i16* %_len
  store i16 0, i16* %i
  store i16 0, i16* %_val
  store i16 0, i16* %_sig
  store i16 0, i16* %_start
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_c
  br label %bb1

bb1:                                              ; preds = %Entry
  %14 = bitcast %STRING.0* %str.addr to i8*, !dbg !1753
  %15 = call i16 @ax_LenST_String(i8* %14), !dbg !1753
  store i16 %15, i16* %_len, !dbg !1753
  %16 = bitcast %STRING.0* %str.addr to i8*, !dbg !1754
  %17 = call i8 @"$ax.GetAtST_String"(i8* %16, i8 1), !dbg !1754
  %18 = icmp eq i8 %17, 43, !dbg !1754
  br i1 %18, label %bb6, label %bb3, !dbg !1754

bb2:                                              ; preds = %bb3
  store i16 1, i16* %_sig, !dbg !1755
  store i16 1, i16* %_start, !dbg !1756
  br label %bb4, !dbg !1756

bb3:                                              ; preds = %bb1
  %19 = bitcast %STRING.0* %str.addr to i8*, !dbg !1757
  %20 = call i8 @"$ax.GetAtST_String"(i8* %19, i8 1), !dbg !1757
  %21 = icmp eq i8 %20, 45, !dbg !1757
  br i1 %21, label %bb7, label %bb2, !dbg !1757

bb4:                                              ; preds = %bb2, %bb7, %bb6
  br label %bb5, !dbg !1758

bb5:                                              ; preds = %bb4
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !1759
  store i64 0, i64* %auto_deref_value.addr, !dbg !1759
  %22 = load i16, i16* %_len, !dbg !1760
  store i16 %22, i16* %0, !dbg !1760
  %23 = load i16, i16* %_start, !dbg !1761
  store i16 %23, i16* %i, !dbg !1761
  br label %bb10, !dbg !1762

bb6:                                              ; preds = %bb1
  store i16 1, i16* %_sig, !dbg !1763
  store i16 2, i16* %_start, !dbg !1764
  br label %bb4, !dbg !1764

bb7:                                              ; preds = %bb3
  store i16 -1, i16* %_sig, !dbg !1765
  store i16 2, i16* %_start, !dbg !1766
  br label %bb4, !dbg !1766

bb8:                                              ; preds = %bb10
  br label %bb9, !dbg !1767

bb9:                                              ; preds = %bb8
  %24 = load i16, i16* %_sig, !dbg !1768
  %25 = sext i16 %24 to i64, !dbg !1768
  %auto_deref_value.addr8 = load i64*, i64** %value.addr, !dbg !1768
  %26 = load i64, i64* %auto_deref_value.addr8, !dbg !1768
  %27 = mul i64 %26, %25, !dbg !1768
  %auto_deref_value.addr9 = load i64*, i64** %value.addr, !dbg !1768
  store i64 %27, i64* %auto_deref_value.addr9, !dbg !1768
  %28 = load i16, i16* %_sig, !dbg !1769
  %29 = icmp eq i16 %28, 1, !dbg !1769
  %auto_deref_value.addr10 = load i64*, i64** %value.addr, !dbg !1769
  %30 = load i64, i64* %auto_deref_value.addr10, !dbg !1769
  %31 = icmp slt i64 %30, 0, !dbg !1769
  %32 = and i1 %29, %31, !dbg !1769
  %33 = load i16, i16* %_sig, !dbg !1769
  %34 = icmp eq i16 %33, -1, !dbg !1769
  %auto_deref_value.addr11 = load i64*, i64** %value.addr, !dbg !1769
  %35 = load i64, i64* %auto_deref_value.addr11, !dbg !1769
  %36 = icmp sgt i64 %35, 0, !dbg !1769
  %37 = and i1 %34, %36, !dbg !1769
  %38 = or i1 %32, %37, !dbg !1769
  br i1 %38, label %bb41, label %bb38, !dbg !1769

bb10:                                             ; preds = %bb11, %bb5
  %39 = load i16, i16* %i, !dbg !1762
  %40 = load i16, i16* %0, !dbg !1762
  %41 = icmp sgt i16 %39, %40, !dbg !1762
  br i1 %41, label %bb8, label %bb12, !dbg !1762

bb11:                                             ; preds = %bb13
  %42 = load i16, i16* %i, !dbg !1762
  %43 = add i16 %42, 1, !dbg !1762
  store i16 %43, i16* %i, !dbg !1762
  br label %bb10, !dbg !1762

bb12:                                             ; preds = %bb10
  %auto_deref_value.addr1 = load i64*, i64** %value.addr, !dbg !1770
  %44 = load i64, i64* %auto_deref_value.addr1, !dbg !1770
  %45 = mul i64 %44, 10, !dbg !1770
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !1770
  store i64 %45, i64* %auto_deref_value.addr2, !dbg !1770
  %46 = load i16, i16* %i, !dbg !1771
  %47 = trunc i16 %46 to i8, !dbg !1771
  %48 = bitcast %STRING.0* %str.addr to i8*, !dbg !1771
  %49 = call i8 @"$ax.GetAtST_String"(i8* %48, i8 %47), !dbg !1771
  %50 = getelementptr inbounds %STRING.0, %STRING.0* %1, i32 0, i32 2, i32 0, !dbg !1771
  store i8 %49, i8* %50, !dbg !1771
  %51 = bitcast %STRING.0* %_c to i8*, !dbg !1771
  %52 = bitcast %STRING.0* %1 to i8*, !dbg !1771
  call void @"$ax.AssignST_String"(i8* %51, i8* %52), !dbg !1771
  %53 = getelementptr inbounds %STRING.0, %STRING.0* %2, i32 0, i32 2, i32 0, !dbg !1772
  store i8 48, i8* %53, !dbg !1772
  %54 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %55 = bitcast %STRING.0* %2 to i8*, !dbg !1772
  %56 = call i32 @"$ax.CmpST_String"(i8* %54, i8* %55), !dbg !1772
  %57 = icmp eq i32 %56, 0, !dbg !1772
  %58 = getelementptr inbounds %STRING.0, %STRING.0* %3, i32 0, i32 2, i32 0, !dbg !1772
  store i8 49, i8* %58, !dbg !1772
  %59 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %60 = bitcast %STRING.0* %3 to i8*, !dbg !1772
  %61 = call i32 @"$ax.CmpST_String"(i8* %59, i8* %60), !dbg !1772
  %62 = icmp eq i32 %61, 0, !dbg !1772
  %63 = getelementptr inbounds %STRING.0, %STRING.0* %4, i32 0, i32 2, i32 0, !dbg !1772
  store i8 50, i8* %63, !dbg !1772
  %64 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %65 = bitcast %STRING.0* %4 to i8*, !dbg !1772
  %66 = call i32 @"$ax.CmpST_String"(i8* %64, i8* %65), !dbg !1772
  %67 = icmp eq i32 %66, 0, !dbg !1772
  %68 = getelementptr inbounds %STRING.0, %STRING.0* %5, i32 0, i32 2, i32 0, !dbg !1772
  store i8 51, i8* %68, !dbg !1772
  %69 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %70 = bitcast %STRING.0* %5 to i8*, !dbg !1772
  %71 = call i32 @"$ax.CmpST_String"(i8* %69, i8* %70), !dbg !1772
  %72 = icmp eq i32 %71, 0, !dbg !1772
  %73 = getelementptr inbounds %STRING.0, %STRING.0* %6, i32 0, i32 2, i32 0, !dbg !1772
  store i8 52, i8* %73, !dbg !1772
  %74 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %75 = bitcast %STRING.0* %6 to i8*, !dbg !1772
  %76 = call i32 @"$ax.CmpST_String"(i8* %74, i8* %75), !dbg !1772
  %77 = icmp eq i32 %76, 0, !dbg !1772
  %78 = getelementptr inbounds %STRING.0, %STRING.0* %7, i32 0, i32 2, i32 0, !dbg !1772
  store i8 53, i8* %78, !dbg !1772
  %79 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %80 = bitcast %STRING.0* %7 to i8*, !dbg !1772
  %81 = call i32 @"$ax.CmpST_String"(i8* %79, i8* %80), !dbg !1772
  %82 = icmp eq i32 %81, 0, !dbg !1772
  %83 = getelementptr inbounds %STRING.0, %STRING.0* %8, i32 0, i32 2, i32 0, !dbg !1772
  store i8 54, i8* %83, !dbg !1772
  %84 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %85 = bitcast %STRING.0* %8 to i8*, !dbg !1772
  %86 = call i32 @"$ax.CmpST_String"(i8* %84, i8* %85), !dbg !1772
  %87 = icmp eq i32 %86, 0, !dbg !1772
  %88 = getelementptr inbounds %STRING.0, %STRING.0* %9, i32 0, i32 2, i32 0, !dbg !1772
  store i8 55, i8* %88, !dbg !1772
  %89 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %90 = bitcast %STRING.0* %9 to i8*, !dbg !1772
  %91 = call i32 @"$ax.CmpST_String"(i8* %89, i8* %90), !dbg !1772
  %92 = icmp eq i32 %91, 0, !dbg !1772
  %93 = getelementptr inbounds %STRING.0, %STRING.0* %10, i32 0, i32 2, i32 0, !dbg !1772
  store i8 56, i8* %93, !dbg !1772
  %94 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %95 = bitcast %STRING.0* %10 to i8*, !dbg !1772
  %96 = call i32 @"$ax.CmpST_String"(i8* %94, i8* %95), !dbg !1772
  %97 = icmp eq i32 %96, 0, !dbg !1772
  %98 = getelementptr inbounds %STRING.0, %STRING.0* %11, i32 0, i32 2, i32 0, !dbg !1772
  store i8 57, i8* %98, !dbg !1772
  %99 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %100 = bitcast %STRING.0* %11 to i8*, !dbg !1772
  %101 = call i32 @"$ax.CmpST_String"(i8* %99, i8* %100), !dbg !1772
  %102 = icmp eq i32 %101, 0, !dbg !1772
  %103 = getelementptr inbounds %STRING.0, %STRING.0* %12, i32 0, i32 2, i32 0, !dbg !1772
  store i8 0, i8* %103, !dbg !1772
  %104 = bitcast %STRING.0* %_c to i8*, !dbg !1772
  %105 = bitcast %STRING.0* %12 to i8*, !dbg !1772
  %106 = call i32 @"$ax.CmpST_String"(i8* %104, i8* %105), !dbg !1772
  %107 = icmp eq i32 %106, 0, !dbg !1772
  br i1 %57, label %bb14, label %bb15, !dbg !1772

bb13:                                             ; preds = %bb37, %bb35, %bb32, %bb30, %bb28, %bb26, %bb24, %bb22, %bb20, %bb18, %bb16, %bb14
  %108 = load i16, i16* %_val, !dbg !1773
  %109 = sext i16 %108 to i64, !dbg !1773
  %auto_deref_value.addr6 = load i64*, i64** %value.addr, !dbg !1773
  %110 = load i64, i64* %auto_deref_value.addr6, !dbg !1773
  %111 = add i64 %110, %109, !dbg !1773
  %auto_deref_value.addr7 = load i64*, i64** %value.addr, !dbg !1773
  store i64 %111, i64* %auto_deref_value.addr7, !dbg !1773
  br label %bb11, !dbg !1762

bb14:                                             ; preds = %bb12
  store i16 0, i16* %_val, !dbg !1774
  br label %bb13, !dbg !1774

bb15:                                             ; preds = %bb12
  br i1 %62, label %bb16, label %bb17, !dbg !1772

bb16:                                             ; preds = %bb15
  store i16 1, i16* %_val, !dbg !1775
  br label %bb13, !dbg !1775

bb17:                                             ; preds = %bb15
  br i1 %67, label %bb18, label %bb19, !dbg !1772

bb18:                                             ; preds = %bb17
  store i16 2, i16* %_val, !dbg !1776
  br label %bb13, !dbg !1776

bb19:                                             ; preds = %bb17
  br i1 %72, label %bb20, label %bb21, !dbg !1772

bb20:                                             ; preds = %bb19
  store i16 3, i16* %_val, !dbg !1777
  br label %bb13, !dbg !1777

bb21:                                             ; preds = %bb19
  br i1 %77, label %bb22, label %bb23, !dbg !1772

bb22:                                             ; preds = %bb21
  store i16 4, i16* %_val, !dbg !1778
  br label %bb13, !dbg !1778

bb23:                                             ; preds = %bb21
  br i1 %82, label %bb24, label %bb25, !dbg !1772

bb24:                                             ; preds = %bb23
  store i16 5, i16* %_val, !dbg !1779
  br label %bb13, !dbg !1779

bb25:                                             ; preds = %bb23
  br i1 %87, label %bb26, label %bb27, !dbg !1772

bb26:                                             ; preds = %bb25
  store i16 6, i16* %_val, !dbg !1780
  br label %bb13, !dbg !1780

bb27:                                             ; preds = %bb25
  br i1 %92, label %bb28, label %bb29, !dbg !1772

bb28:                                             ; preds = %bb27
  store i16 7, i16* %_val, !dbg !1781
  br label %bb13, !dbg !1781

bb29:                                             ; preds = %bb27
  br i1 %97, label %bb30, label %bb31, !dbg !1772

bb30:                                             ; preds = %bb29
  store i16 8, i16* %_val, !dbg !1782
  br label %bb13, !dbg !1782

bb31:                                             ; preds = %bb29
  br i1 %102, label %bb32, label %bb33, !dbg !1772

bb32:                                             ; preds = %bb31
  store i16 9, i16* %_val, !dbg !1783
  br label %bb13, !dbg !1783

bb33:                                             ; preds = %bb31
  br i1 %107, label %bb34, label %bb36, !dbg !1772

bb34:                                             ; preds = %bb33
  store i1 true, i1* %StringToAnyInt.ret, !dbg !1784
  %112 = load i16, i16* %_sig, !dbg !1785
  %113 = sext i16 %112 to i64, !dbg !1785
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !1785
  %114 = load i64, i64* %auto_deref_value.addr3, !dbg !1785
  %115 = mul i64 %114, %113, !dbg !1785
  %auto_deref_value.addr4 = load i64*, i64** %value.addr, !dbg !1785
  store i64 %115, i64* %auto_deref_value.addr4, !dbg !1785
  %116 = load i1, i1* %StringToAnyInt.ret, !dbg !1786
  ret i1 %116, !dbg !1786

bb35:                                             ; No predecessors!
  br label %bb13, !dbg !1786

bb36:                                             ; preds = %bb33
  %auto_deref_value.addr5 = load i64*, i64** %value.addr, !dbg !1787
  store i64 0, i64* %auto_deref_value.addr5, !dbg !1787
  store i1 false, i1* %StringToAnyInt.ret, !dbg !1788
  %117 = load i1, i1* %StringToAnyInt.ret, !dbg !1789
  ret i1 %117, !dbg !1789

bb37:                                             ; No predecessors!
  br label %bb13, !dbg !1789

bb38:                                             ; preds = %bb9
  store i1 true, i1* %StringToAnyInt.ret, !dbg !1790
  br label %bb39, !dbg !1790

bb39:                                             ; preds = %bb38, %bb41
  br label %bb40, !dbg !1791

bb40:                                             ; preds = %bb39
  %118 = load i1, i1* %StringToAnyInt.ret, !dbg !1792
  ret i1 %118, !dbg !1792

bb41:                                             ; preds = %bb9
  %auto_deref_value.addr12 = load i64*, i64** %value.addr, !dbg !1793
  store i64 0, i64* %auto_deref_value.addr12, !dbg !1793
  store i1 false, i1* %StringToAnyInt.ret, !dbg !1794
  br label %bb39, !dbg !1794
}

define i1 @"Simatic.Ax.Conversion.StringToULint$I@V@STRING@str?O@V@UInt64@value"(i8* %str, i64* %value) !dbg !1795 {
Entry:
  %StringToULint.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %_len = alloca i16
  %i = alloca i16
  %_val = alloca i64
  %_start = alloca i16
  %_c = alloca %STRING.0
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1798, metadata !DIExpression()), !dbg !1799
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !1800, metadata !DIExpression()), !dbg !1801
  call void @llvm.dbg.declare(metadata i16* %_len, metadata !1802, metadata !DIExpression()), !dbg !1803
  call void @llvm.dbg.declare(metadata i16* %i, metadata !1804, metadata !DIExpression()), !dbg !1805
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1806, metadata !DIExpression()), !dbg !1807
  call void @llvm.dbg.declare(metadata i16* %_start, metadata !1808, metadata !DIExpression()), !dbg !1809
  call void @llvm.dbg.declare(metadata %STRING.0* %_c, metadata !1810, metadata !DIExpression()), !dbg !1811
  call void @llvm.dbg.declare(metadata i1* %StringToULint.ret, metadata !1812, metadata !DIExpression()), !dbg !1813
  %0 = alloca i16
  store i16 0, i16* %0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %1
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %2
  %3 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %3
  %4 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %4
  %5 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %5
  %6 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %6
  %7 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %7
  %8 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %8
  %9 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %9
  %10 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %10
  %11 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %11
  %12 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 1, [255 x i8] zeroinitializer }, %STRING.0* %12
  store i1 false, i1* %StringToULint.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %13 = bitcast %STRING.0* %str.addr to i8*, !dbg !1813
  call void @"$ax.AssignST_String"(i8* %13, i8* %str), !dbg !1813
  store i64* %value, i64** %value.addr
  store i16 0, i16* %_len
  store i16 0, i16* %i
  store i64 0, i64* %_val
  store i16 0, i16* %_start
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %_c
  br label %bb1

bb1:                                              ; preds = %Entry
  %14 = bitcast %STRING.0* %str.addr to i8*, !dbg !1814
  %15 = call i16 @ax_LenST_String(i8* %14), !dbg !1814
  store i16 %15, i16* %_len, !dbg !1814
  %16 = bitcast %STRING.0* %str.addr to i8*, !dbg !1815
  %17 = call i8 @"$ax.GetAtST_String"(i8* %16, i8 1), !dbg !1815
  %18 = icmp eq i8 %17, 43, !dbg !1815
  br i1 %18, label %bb5, label %bb2, !dbg !1815

bb2:                                              ; preds = %bb1
  store i16 1, i16* %_start, !dbg !1816
  br label %bb3, !dbg !1816

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1817

bb4:                                              ; preds = %bb3
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !1818
  store i64 0, i64* %auto_deref_value.addr, !dbg !1818
  %19 = load i16, i16* %_len, !dbg !1819
  store i16 %19, i16* %0, !dbg !1819
  %20 = load i16, i16* %_start, !dbg !1820
  store i16 %20, i16* %i, !dbg !1820
  br label %bb8, !dbg !1821

bb5:                                              ; preds = %bb1
  store i16 2, i16* %_start, !dbg !1822
  br label %bb3, !dbg !1822

bb6:                                              ; preds = %bb8
  br label %bb7, !dbg !1823

bb7:                                              ; preds = %bb6
  store i1 true, i1* %StringToULint.ret, !dbg !1824
  %21 = load i1, i1* %StringToULint.ret, !dbg !1825
  ret i1 %21, !dbg !1825

bb8:                                              ; preds = %bb9, %bb4
  %22 = load i16, i16* %i, !dbg !1821
  %23 = load i16, i16* %0, !dbg !1821
  %24 = icmp sgt i16 %22, %23, !dbg !1821
  br i1 %24, label %bb6, label %bb10, !dbg !1821

bb9:                                              ; preds = %bb11
  %25 = load i16, i16* %i, !dbg !1821
  %26 = add i16 %25, 1, !dbg !1821
  store i16 %26, i16* %i, !dbg !1821
  br label %bb8, !dbg !1821

bb10:                                             ; preds = %bb8
  %auto_deref_value.addr1 = load i64*, i64** %value.addr, !dbg !1826
  %27 = load i64, i64* %auto_deref_value.addr1, !dbg !1826
  %28 = mul i64 %27, 10, !dbg !1826
  %auto_deref_value.addr2 = load i64*, i64** %value.addr, !dbg !1826
  store i64 %28, i64* %auto_deref_value.addr2, !dbg !1826
  %29 = load i16, i16* %i, !dbg !1827
  %30 = trunc i16 %29 to i8, !dbg !1827
  %31 = bitcast %STRING.0* %str.addr to i8*, !dbg !1827
  %32 = call i8 @"$ax.GetAtST_String"(i8* %31, i8 %30), !dbg !1827
  %33 = getelementptr inbounds %STRING.0, %STRING.0* %1, i32 0, i32 2, i32 0, !dbg !1827
  store i8 %32, i8* %33, !dbg !1827
  %34 = bitcast %STRING.0* %_c to i8*, !dbg !1827
  %35 = bitcast %STRING.0* %1 to i8*, !dbg !1827
  call void @"$ax.AssignST_String"(i8* %34, i8* %35), !dbg !1827
  %36 = getelementptr inbounds %STRING.0, %STRING.0* %2, i32 0, i32 2, i32 0, !dbg !1828
  store i8 48, i8* %36, !dbg !1828
  %37 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %38 = bitcast %STRING.0* %2 to i8*, !dbg !1828
  %39 = call i32 @"$ax.CmpST_String"(i8* %37, i8* %38), !dbg !1828
  %40 = icmp eq i32 %39, 0, !dbg !1828
  %41 = getelementptr inbounds %STRING.0, %STRING.0* %3, i32 0, i32 2, i32 0, !dbg !1828
  store i8 49, i8* %41, !dbg !1828
  %42 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %43 = bitcast %STRING.0* %3 to i8*, !dbg !1828
  %44 = call i32 @"$ax.CmpST_String"(i8* %42, i8* %43), !dbg !1828
  %45 = icmp eq i32 %44, 0, !dbg !1828
  %46 = getelementptr inbounds %STRING.0, %STRING.0* %4, i32 0, i32 2, i32 0, !dbg !1828
  store i8 50, i8* %46, !dbg !1828
  %47 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %48 = bitcast %STRING.0* %4 to i8*, !dbg !1828
  %49 = call i32 @"$ax.CmpST_String"(i8* %47, i8* %48), !dbg !1828
  %50 = icmp eq i32 %49, 0, !dbg !1828
  %51 = getelementptr inbounds %STRING.0, %STRING.0* %5, i32 0, i32 2, i32 0, !dbg !1828
  store i8 51, i8* %51, !dbg !1828
  %52 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %53 = bitcast %STRING.0* %5 to i8*, !dbg !1828
  %54 = call i32 @"$ax.CmpST_String"(i8* %52, i8* %53), !dbg !1828
  %55 = icmp eq i32 %54, 0, !dbg !1828
  %56 = getelementptr inbounds %STRING.0, %STRING.0* %6, i32 0, i32 2, i32 0, !dbg !1828
  store i8 52, i8* %56, !dbg !1828
  %57 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %58 = bitcast %STRING.0* %6 to i8*, !dbg !1828
  %59 = call i32 @"$ax.CmpST_String"(i8* %57, i8* %58), !dbg !1828
  %60 = icmp eq i32 %59, 0, !dbg !1828
  %61 = getelementptr inbounds %STRING.0, %STRING.0* %7, i32 0, i32 2, i32 0, !dbg !1828
  store i8 53, i8* %61, !dbg !1828
  %62 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %63 = bitcast %STRING.0* %7 to i8*, !dbg !1828
  %64 = call i32 @"$ax.CmpST_String"(i8* %62, i8* %63), !dbg !1828
  %65 = icmp eq i32 %64, 0, !dbg !1828
  %66 = getelementptr inbounds %STRING.0, %STRING.0* %8, i32 0, i32 2, i32 0, !dbg !1828
  store i8 54, i8* %66, !dbg !1828
  %67 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %68 = bitcast %STRING.0* %8 to i8*, !dbg !1828
  %69 = call i32 @"$ax.CmpST_String"(i8* %67, i8* %68), !dbg !1828
  %70 = icmp eq i32 %69, 0, !dbg !1828
  %71 = getelementptr inbounds %STRING.0, %STRING.0* %9, i32 0, i32 2, i32 0, !dbg !1828
  store i8 55, i8* %71, !dbg !1828
  %72 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %73 = bitcast %STRING.0* %9 to i8*, !dbg !1828
  %74 = call i32 @"$ax.CmpST_String"(i8* %72, i8* %73), !dbg !1828
  %75 = icmp eq i32 %74, 0, !dbg !1828
  %76 = getelementptr inbounds %STRING.0, %STRING.0* %10, i32 0, i32 2, i32 0, !dbg !1828
  store i8 56, i8* %76, !dbg !1828
  %77 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %78 = bitcast %STRING.0* %10 to i8*, !dbg !1828
  %79 = call i32 @"$ax.CmpST_String"(i8* %77, i8* %78), !dbg !1828
  %80 = icmp eq i32 %79, 0, !dbg !1828
  %81 = getelementptr inbounds %STRING.0, %STRING.0* %11, i32 0, i32 2, i32 0, !dbg !1828
  store i8 57, i8* %81, !dbg !1828
  %82 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %83 = bitcast %STRING.0* %11 to i8*, !dbg !1828
  %84 = call i32 @"$ax.CmpST_String"(i8* %82, i8* %83), !dbg !1828
  %85 = icmp eq i32 %84, 0, !dbg !1828
  %86 = getelementptr inbounds %STRING.0, %STRING.0* %12, i32 0, i32 2, i32 0, !dbg !1828
  store i8 0, i8* %86, !dbg !1828
  %87 = bitcast %STRING.0* %_c to i8*, !dbg !1828
  %88 = bitcast %STRING.0* %12 to i8*, !dbg !1828
  %89 = call i32 @"$ax.CmpST_String"(i8* %87, i8* %88), !dbg !1828
  %90 = icmp eq i32 %89, 0, !dbg !1828
  br i1 %40, label %bb12, label %bb13, !dbg !1828

bb11:                                             ; preds = %bb35, %bb33, %bb30, %bb28, %bb26, %bb24, %bb22, %bb20, %bb18, %bb16, %bb14, %bb12
  %auto_deref_value.addr4 = load i64*, i64** %value.addr, !dbg !1829
  %91 = load i64, i64* %auto_deref_value.addr4, !dbg !1829
  %92 = load i64, i64* %_val, !dbg !1829
  %93 = add i64 %91, %92, !dbg !1829
  %auto_deref_value.addr5 = load i64*, i64** %value.addr, !dbg !1829
  store i64 %93, i64* %auto_deref_value.addr5, !dbg !1829
  br label %bb9, !dbg !1821

bb12:                                             ; preds = %bb10
  store i64 0, i64* %_val, !dbg !1830
  br label %bb11, !dbg !1830

bb13:                                             ; preds = %bb10
  br i1 %45, label %bb14, label %bb15, !dbg !1828

bb14:                                             ; preds = %bb13
  store i64 1, i64* %_val, !dbg !1831
  br label %bb11, !dbg !1831

bb15:                                             ; preds = %bb13
  br i1 %50, label %bb16, label %bb17, !dbg !1828

bb16:                                             ; preds = %bb15
  store i64 2, i64* %_val, !dbg !1832
  br label %bb11, !dbg !1832

bb17:                                             ; preds = %bb15
  br i1 %55, label %bb18, label %bb19, !dbg !1828

bb18:                                             ; preds = %bb17
  store i64 3, i64* %_val, !dbg !1833
  br label %bb11, !dbg !1833

bb19:                                             ; preds = %bb17
  br i1 %60, label %bb20, label %bb21, !dbg !1828

bb20:                                             ; preds = %bb19
  store i64 4, i64* %_val, !dbg !1834
  br label %bb11, !dbg !1834

bb21:                                             ; preds = %bb19
  br i1 %65, label %bb22, label %bb23, !dbg !1828

bb22:                                             ; preds = %bb21
  store i64 5, i64* %_val, !dbg !1835
  br label %bb11, !dbg !1835

bb23:                                             ; preds = %bb21
  br i1 %70, label %bb24, label %bb25, !dbg !1828

bb24:                                             ; preds = %bb23
  store i64 6, i64* %_val, !dbg !1836
  br label %bb11, !dbg !1836

bb25:                                             ; preds = %bb23
  br i1 %75, label %bb26, label %bb27, !dbg !1828

bb26:                                             ; preds = %bb25
  store i64 7, i64* %_val, !dbg !1837
  br label %bb11, !dbg !1837

bb27:                                             ; preds = %bb25
  br i1 %80, label %bb28, label %bb29, !dbg !1828

bb28:                                             ; preds = %bb27
  store i64 8, i64* %_val, !dbg !1838
  br label %bb11, !dbg !1838

bb29:                                             ; preds = %bb27
  br i1 %85, label %bb30, label %bb31, !dbg !1828

bb30:                                             ; preds = %bb29
  store i64 9, i64* %_val, !dbg !1839
  br label %bb11, !dbg !1839

bb31:                                             ; preds = %bb29
  br i1 %90, label %bb32, label %bb34, !dbg !1828

bb32:                                             ; preds = %bb31
  store i1 true, i1* %StringToULint.ret, !dbg !1840
  %94 = load i1, i1* %StringToULint.ret, !dbg !1841
  ret i1 %94, !dbg !1841

bb33:                                             ; No predecessors!
  br label %bb11, !dbg !1841

bb34:                                             ; preds = %bb31
  %auto_deref_value.addr3 = load i64*, i64** %value.addr, !dbg !1842
  store i64 0, i64* %auto_deref_value.addr3, !dbg !1842
  store i1 false, i1* %StringToULint.ret, !dbg !1843
  %95 = load i1, i1* %StringToULint.ret, !dbg !1844
  ret i1 %95, !dbg !1844

bb35:                                             ; No predecessors!
  br label %bb11, !dbg !1844
}

define i32 @"Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr"(i8* %str, %"$ax.ArrayWithBound"* %arr) !dbg !1845 {
Entry:
  %ToArray.ret = alloca i32
  %str.addr = alloca %STRING.0
  %arr.addr = alloca %"$ax.ArrayWithBound"*
  %i = alloca i32
  %_lb = alloca i32
  %_ub = alloca i32
  %_maxLen = alloca i32
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1850, metadata !DIExpression()), !dbg !1851
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %arr.addr, metadata !1852, metadata !DIExpression()), !dbg !1853
  call void @llvm.dbg.declare(metadata i32* %i, metadata !1854, metadata !DIExpression()), !dbg !1855
  call void @llvm.dbg.declare(metadata i32* %_lb, metadata !1856, metadata !DIExpression()), !dbg !1857
  call void @llvm.dbg.declare(metadata i32* %_ub, metadata !1858, metadata !DIExpression()), !dbg !1859
  call void @llvm.dbg.declare(metadata i32* %_maxLen, metadata !1860, metadata !DIExpression()), !dbg !1861
  call void @llvm.dbg.declare(metadata i32* %ToArray.ret, metadata !1862, metadata !DIExpression()), !dbg !1863
  %0 = alloca i32
  store i32 0, i32* %0
  store i32 0, i32* %ToArray.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1863
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1863
  store %"$ax.ArrayWithBound"* %arr, %"$ax.ArrayWithBound"** %arr.addr
  store i32 0, i32* %i
  store i32 0, i32* %_lb
  store i32 0, i32* %_ub
  store i32 0, i32* %_maxLen
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_arr.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %arr.addr, !dbg !1864
  %2 = call i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* %auto_deref_arr.addr, i32 1), !dbg !1864
  store i32 %2, i32* %_lb, !dbg !1864
  %auto_deref_arr.addr1 = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %arr.addr, !dbg !1865
  %3 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %auto_deref_arr.addr1, i32 1), !dbg !1865
  store i32 %3, i32* %_ub, !dbg !1865
  %4 = bitcast %STRING.0* %str.addr to i8*, !dbg !1866
  %5 = call i16 @ax_LenST_String(i8* %4), !dbg !1866
  %6 = sext i16 %5 to i32, !dbg !1866
  store i32 %6, i32* %_maxLen, !dbg !1866
  %7 = load i32, i32* %_ub, !dbg !1867
  %8 = load i32, i32* %_lb, !dbg !1867
  %9 = sub i32 %7, %8, !dbg !1867
  %10 = add i32 %9, 1, !dbg !1867
  %11 = load i32, i32* %_maxLen, !dbg !1867
  %12 = icmp sgt i32 %11, %10, !dbg !1867
  br i1 %12, label %bb4, label %bb2, !dbg !1867

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3, !dbg !1868

bb3:                                              ; preds = %bb2
  %13 = load i32, i32* %_maxLen, !dbg !1869
  %14 = sub i32 %13, 1, !dbg !1869
  store i32 %14, i32* %0, !dbg !1869
  store i32 0, i32* %i, !dbg !1870
  br label %bb7, !dbg !1871

bb4:                                              ; preds = %bb1
  %15 = load i32, i32* %_ub, !dbg !1872
  %16 = load i32, i32* %_lb, !dbg !1872
  %17 = sub i32 %15, %16, !dbg !1872
  %18 = add i32 %17, 1, !dbg !1872
  %19 = trunc i32 %18 to i16, !dbg !1872
  %20 = sext i16 %19 to i32, !dbg !1872
  store i32 %20, i32* %_maxLen, !dbg !1872
  br label %bb2, !dbg !1872

bb5:                                              ; preds = %bb7
  br label %bb6, !dbg !1873

bb6:                                              ; preds = %bb5
  %21 = load i32, i32* %i, !dbg !1874
  store i32 %21, i32* %ToArray.ret, !dbg !1874
  %22 = load i32, i32* %ToArray.ret, !dbg !1875
  ret i32 %22, !dbg !1875

bb7:                                              ; preds = %bb8, %bb3
  %23 = load i32, i32* %i, !dbg !1871
  %24 = load i32, i32* %0, !dbg !1871
  %25 = icmp sgt i32 %23, %24, !dbg !1871
  br i1 %25, label %bb5, label %bb9, !dbg !1871

bb8:                                              ; preds = %bb9
  %26 = load i32, i32* %i, !dbg !1871
  %27 = add i32 %26, 1, !dbg !1871
  store i32 %27, i32* %i, !dbg !1871
  br label %bb7, !dbg !1871

bb9:                                              ; preds = %bb7
  %28 = load i32, i32* %i, !dbg !1876
  %29 = add i32 %28, 1, !dbg !1876
  %30 = trunc i32 %29 to i8, !dbg !1876
  %31 = bitcast %STRING.0* %str.addr to i8*, !dbg !1876
  %32 = call i8 @"$ax.GetAtST_String"(i8* %31, i8 %30), !dbg !1876
  %33 = load i32, i32* %i, !dbg !1876
  %34 = load i32, i32* %_lb, !dbg !1876
  %35 = add i32 %33, %34, !dbg !1876
  %auto_deref_arr.addr2 = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %arr.addr, !dbg !1876
  %36 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %auto_deref_arr.addr2, i32 0, i32 0, !dbg !1876
  %"$elementPtr" = load i8*, i8** %36, !dbg !1876
  %"$allBounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %auto_deref_arr.addr2, i32 0, i32 2, !dbg !1876
  %37 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds", !dbg !1876
  %"$bounds0" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %37, i32 0, !dbg !1876
  %38 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 0, !dbg !1876
  %"$lowerBound0" = load i32, i32* %38, !dbg !1876
  %39 = sub i32 %35, %"$lowerBound0", !dbg !1876
  %40 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 2, !dbg !1876
  %"$countNextDims0" = load i32, i32* %40, !dbg !1876
  %41 = mul i32 %39, %"$countNextDims0", !dbg !1876
  %"$gepIndex0" = add i32 0, %41, !dbg !1876
  %42 = getelementptr i8, i8* %"$elementPtr", i32 %"$gepIndex0", !dbg !1876
  store i8 %32, i8* %42, !dbg !1876
  br label %bb8, !dbg !1871
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int8@value"(i8* %str, i8* %value) !dbg !1877 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i8*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1881, metadata !DIExpression()), !dbg !1882
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !1883, metadata !DIExpression()), !dbg !1884
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1885, metadata !DIExpression()), !dbg !1886
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1887, metadata !DIExpression()), !dbg !1888
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1888
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1888
  store i8* %value, i8** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1889
  store i64 %2, i64* %0, !dbg !1889
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1889
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1889
  %5 = load i64, i64* %0, !dbg !1889
  store i64 %5, i64* %_val, !dbg !1889
  store i1 %4, i1* %ToInt.ret, !dbg !1889
  %6 = load i64, i64* %_val, !dbg !1890
  %7 = icmp slt i64 %6, -128, !dbg !1890
  %8 = load i64, i64* %_val, !dbg !1890
  %9 = icmp sgt i64 %8, 127, !dbg !1890
  %10 = or i1 %7, %9, !dbg !1890
  br i1 %10, label %bb5, label %bb2, !dbg !1890

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1891
  %12 = trunc i64 %11 to i8, !dbg !1891
  %auto_deref_value.addr1 = load i8*, i8** %value.addr, !dbg !1891
  store i8 %12, i8* %auto_deref_value.addr1, !dbg !1891
  br label %bb3, !dbg !1891

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1892

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1893
  ret i1 %13, !dbg !1893

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !1894
  store i8 0, i8* %auto_deref_value.addr, !dbg !1894
  store i1 false, i1* %ToInt.ret, !dbg !1895
  br label %bb3, !dbg !1895
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int16@value"(i8* %str, i16* %value) !dbg !1896 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i16*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1899, metadata !DIExpression()), !dbg !1900
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !1901, metadata !DIExpression()), !dbg !1902
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1903, metadata !DIExpression()), !dbg !1904
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1905, metadata !DIExpression()), !dbg !1906
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1906
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1906
  store i16* %value, i16** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1907
  store i64 %2, i64* %0, !dbg !1907
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1907
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1907
  %5 = load i64, i64* %0, !dbg !1907
  store i64 %5, i64* %_val, !dbg !1907
  store i1 %4, i1* %ToInt.ret, !dbg !1907
  %6 = load i64, i64* %_val, !dbg !1908
  %7 = icmp slt i64 %6, -32768, !dbg !1908
  %8 = load i64, i64* %_val, !dbg !1908
  %9 = icmp sgt i64 %8, 32767, !dbg !1908
  %10 = or i1 %7, %9, !dbg !1908
  br i1 %10, label %bb5, label %bb2, !dbg !1908

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1909
  %12 = trunc i64 %11 to i16, !dbg !1909
  %auto_deref_value.addr1 = load i16*, i16** %value.addr, !dbg !1909
  store i16 %12, i16* %auto_deref_value.addr1, !dbg !1909
  br label %bb3, !dbg !1909

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1910

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1911
  ret i1 %13, !dbg !1911

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !1912
  store i16 0, i16* %auto_deref_value.addr, !dbg !1912
  store i1 false, i1* %ToInt.ret, !dbg !1913
  br label %bb3, !dbg !1913
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int32@value"(i8* %str, i32* %value) !dbg !1914 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i32*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1917, metadata !DIExpression()), !dbg !1918
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !1919, metadata !DIExpression()), !dbg !1920
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1921, metadata !DIExpression()), !dbg !1922
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1923, metadata !DIExpression()), !dbg !1924
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1924
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1924
  store i32* %value, i32** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1925
  store i64 %2, i64* %0, !dbg !1925
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1925
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1925
  %5 = load i64, i64* %0, !dbg !1925
  store i64 %5, i64* %_val, !dbg !1925
  store i1 %4, i1* %ToInt.ret, !dbg !1925
  %6 = load i64, i64* %_val, !dbg !1926
  %7 = icmp slt i64 %6, -2147483648, !dbg !1926
  %8 = load i64, i64* %_val, !dbg !1926
  %9 = icmp sgt i64 %8, 2147483647, !dbg !1926
  %10 = or i1 %7, %9, !dbg !1926
  br i1 %10, label %bb5, label %bb2, !dbg !1926

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1927
  %12 = trunc i64 %11 to i32, !dbg !1927
  %auto_deref_value.addr1 = load i32*, i32** %value.addr, !dbg !1927
  store i32 %12, i32* %auto_deref_value.addr1, !dbg !1927
  br label %bb3, !dbg !1927

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1928

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1929
  ret i1 %13, !dbg !1929

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !1930
  store i32 0, i32* %auto_deref_value.addr, !dbg !1930
  store i1 false, i1* %ToInt.ret, !dbg !1931
  br label %bb3, !dbg !1931
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int64@value"(i8* %str, i64* %value) !dbg !1932 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1933, metadata !DIExpression()), !dbg !1934
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !1935, metadata !DIExpression()), !dbg !1936
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1937, metadata !DIExpression()), !dbg !1938
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1939, metadata !DIExpression()), !dbg !1940
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1940
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1940
  store i64* %value, i64** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1941
  store i64 %2, i64* %0, !dbg !1941
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1941
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1941
  %5 = load i64, i64* %0, !dbg !1941
  store i64 %5, i64* %_val, !dbg !1941
  store i1 %4, i1* %ToInt.ret, !dbg !1941
  %6 = load i64, i64* %_val, !dbg !1942
  %7 = icmp slt i64 %6, -9223372036854775808, !dbg !1942
  %8 = load i64, i64* %_val, !dbg !1942
  %9 = icmp sgt i64 %8, 9223372036854775807, !dbg !1942
  %10 = or i1 %7, %9, !dbg !1942
  br i1 %10, label %bb5, label %bb2, !dbg !1942

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1943
  %auto_deref_value.addr1 = load i64*, i64** %value.addr, !dbg !1943
  store i64 %11, i64* %auto_deref_value.addr1, !dbg !1943
  br label %bb3, !dbg !1943

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1944

bb4:                                              ; preds = %bb3
  %12 = load i1, i1* %ToInt.ret, !dbg !1945
  ret i1 %12, !dbg !1945

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !1946
  store i64 0, i64* %auto_deref_value.addr, !dbg !1946
  store i1 false, i1* %ToInt.ret, !dbg !1947
  br label %bb3, !dbg !1947
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt8@value"(i8* %str, i8* %value) !dbg !1948 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i8*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1951, metadata !DIExpression()), !dbg !1952
  call void @llvm.dbg.declare(metadata i8** %value.addr, metadata !1953, metadata !DIExpression()), !dbg !1954
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1955, metadata !DIExpression()), !dbg !1956
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1957, metadata !DIExpression()), !dbg !1958
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1958
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1958
  store i8* %value, i8** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1959
  store i64 %2, i64* %0, !dbg !1959
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1959
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1959
  %5 = load i64, i64* %0, !dbg !1959
  store i64 %5, i64* %_val, !dbg !1959
  store i1 %4, i1* %ToInt.ret, !dbg !1959
  %6 = load i64, i64* %_val, !dbg !1960
  %7 = icmp slt i64 %6, 0, !dbg !1960
  %8 = load i64, i64* %_val, !dbg !1960
  %9 = icmp sgt i64 %8, 255, !dbg !1960
  %10 = or i1 %7, %9, !dbg !1960
  br i1 %10, label %bb5, label %bb2, !dbg !1960

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1961
  %12 = trunc i64 %11 to i8, !dbg !1961
  %auto_deref_value.addr1 = load i8*, i8** %value.addr, !dbg !1961
  store i8 %12, i8* %auto_deref_value.addr1, !dbg !1961
  br label %bb3, !dbg !1961

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1962

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1963
  ret i1 %13, !dbg !1963

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i8*, i8** %value.addr, !dbg !1964
  store i8 0, i8* %auto_deref_value.addr, !dbg !1964
  store i1 false, i1* %ToInt.ret, !dbg !1965
  br label %bb3, !dbg !1965
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt16@value"(i8* %str, i16* %value) !dbg !1966 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i16*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1969, metadata !DIExpression()), !dbg !1970
  call void @llvm.dbg.declare(metadata i16** %value.addr, metadata !1971, metadata !DIExpression()), !dbg !1972
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1973, metadata !DIExpression()), !dbg !1974
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1975, metadata !DIExpression()), !dbg !1976
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1976
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1976
  store i16* %value, i16** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1977
  store i64 %2, i64* %0, !dbg !1977
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1977
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1977
  %5 = load i64, i64* %0, !dbg !1977
  store i64 %5, i64* %_val, !dbg !1977
  store i1 %4, i1* %ToInt.ret, !dbg !1977
  %6 = load i64, i64* %_val, !dbg !1978
  %7 = icmp slt i64 %6, 0, !dbg !1978
  %8 = load i64, i64* %_val, !dbg !1978
  %9 = icmp sgt i64 %8, 65535, !dbg !1978
  %10 = or i1 %7, %9, !dbg !1978
  br i1 %10, label %bb5, label %bb2, !dbg !1978

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1979
  %12 = trunc i64 %11 to i16, !dbg !1979
  %auto_deref_value.addr1 = load i16*, i16** %value.addr, !dbg !1979
  store i16 %12, i16* %auto_deref_value.addr1, !dbg !1979
  br label %bb3, !dbg !1979

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1980

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1981
  ret i1 %13, !dbg !1981

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i16*, i16** %value.addr, !dbg !1982
  store i16 0, i16* %auto_deref_value.addr, !dbg !1982
  store i1 false, i1* %ToInt.ret, !dbg !1983
  br label %bb3, !dbg !1983
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt32@value"(i8* %str, i32* %value) !dbg !1984 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i32*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !1987, metadata !DIExpression()), !dbg !1988
  call void @llvm.dbg.declare(metadata i32** %value.addr, metadata !1989, metadata !DIExpression()), !dbg !1990
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !1991, metadata !DIExpression()), !dbg !1992
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !1993, metadata !DIExpression()), !dbg !1994
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !1994
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !1994
  store i32* %value, i32** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !1995
  store i64 %2, i64* %0, !dbg !1995
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !1995
  %4 = call i1 @"Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value"(i8* %3, i64* %0), !dbg !1995
  %5 = load i64, i64* %0, !dbg !1995
  store i64 %5, i64* %_val, !dbg !1995
  store i1 %4, i1* %ToInt.ret, !dbg !1995
  %6 = load i64, i64* %_val, !dbg !1996
  %7 = icmp slt i64 %6, 0, !dbg !1996
  %8 = load i64, i64* %_val, !dbg !1996
  %9 = icmp sgt i64 %8, 4294967295, !dbg !1996
  %10 = or i1 %7, %9, !dbg !1996
  br i1 %10, label %bb5, label %bb2, !dbg !1996

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !1997
  %12 = trunc i64 %11 to i32, !dbg !1997
  %auto_deref_value.addr1 = load i32*, i32** %value.addr, !dbg !1997
  store i32 %12, i32* %auto_deref_value.addr1, !dbg !1997
  br label %bb3, !dbg !1997

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !1998

bb4:                                              ; preds = %bb3
  %13 = load i1, i1* %ToInt.ret, !dbg !1999
  ret i1 %13, !dbg !1999

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i32*, i32** %value.addr, !dbg !2000
  store i32 0, i32* %auto_deref_value.addr, !dbg !2000
  store i1 false, i1* %ToInt.ret, !dbg !2001
  br label %bb3, !dbg !2001
}

define i1 @"Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt64@value"(i8* %str, i64* %value) !dbg !2002 {
Entry:
  %ToInt.ret = alloca i1
  %str.addr = alloca %STRING.0
  %value.addr = alloca i64*
  %_val = alloca i64
  call void @llvm.dbg.declare(metadata %STRING.0* %str.addr, metadata !2003, metadata !DIExpression()), !dbg !2004
  call void @llvm.dbg.declare(metadata i64** %value.addr, metadata !2005, metadata !DIExpression()), !dbg !2006
  call void @llvm.dbg.declare(metadata i64* %_val, metadata !2007, metadata !DIExpression()), !dbg !2008
  call void @llvm.dbg.declare(metadata i1* %ToInt.ret, metadata !2009, metadata !DIExpression()), !dbg !2010
  %0 = alloca i64
  store i64 0, i64* %0
  store i1 false, i1* %ToInt.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %str.addr
  %1 = bitcast %STRING.0* %str.addr to i8*, !dbg !2010
  call void @"$ax.AssignST_String"(i8* %1, i8* %str), !dbg !2010
  store i64* %value, i64** %value.addr
  store i64 0, i64* %_val
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load i64, i64* %_val, !dbg !2011
  store i64 %2, i64* %0, !dbg !2011
  %3 = bitcast %STRING.0* %str.addr to i8*, !dbg !2011
  %4 = call i1 @"Simatic.Ax.Conversion.StringToULint$I@V@STRING@str?O@V@UInt64@value"(i8* %3, i64* %0), !dbg !2011
  %5 = load i64, i64* %0, !dbg !2011
  store i64 %5, i64* %_val, !dbg !2011
  store i1 %4, i1* %ToInt.ret, !dbg !2011
  %6 = load i64, i64* %_val, !dbg !2012
  %7 = icmp ult i64 %6, 0, !dbg !2012
  %8 = load i64, i64* %_val, !dbg !2012
  %9 = icmp ugt i64 %8, -1, !dbg !2012
  %10 = or i1 %7, %9, !dbg !2012
  br i1 %10, label %bb5, label %bb2, !dbg !2012

bb2:                                              ; preds = %bb1
  %11 = load i64, i64* %_val, !dbg !2013
  %auto_deref_value.addr1 = load i64*, i64** %value.addr, !dbg !2013
  store i64 %11, i64* %auto_deref_value.addr1, !dbg !2013
  br label %bb3, !dbg !2013

bb3:                                              ; preds = %bb2, %bb5
  br label %bb4, !dbg !2014

bb4:                                              ; preds = %bb3
  %12 = load i1, i1* %ToInt.ret, !dbg !2015
  ret i1 %12, !dbg !2015

bb5:                                              ; preds = %bb1
  %auto_deref_value.addr = load i64*, i64** %value.addr, !dbg !2016
  store i64 0, i64* %auto_deref_value.addr, !dbg !2016
  store i1 false, i1* %ToInt.ret, !dbg !2017
  br label %bb3, !dbg !2017
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, %"$ax.ArrayWithBound" %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2018 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca %"$ax.ArrayWithBound"
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %index = alloca i32
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2026, metadata !DIExpression()), !dbg !2027
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"* %value.addr, metadata !2028, metadata !DIExpression()), !dbg !2029
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2030, metadata !DIExpression()), !dbg !2031
  call void @llvm.dbg.declare(metadata i32* %index, metadata !2032, metadata !DIExpression()), !dbg !2033
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2034, metadata !DIExpression()), !dbg !2035
  %0 = alloca i32
  store i32 0, i32* %0
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store %"$ax.ArrayWithBound" %value, %"$ax.ArrayWithBound"* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store i32 0, i32* %index
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %value.addr, i32 1), !dbg !2036
  store i32 %1, i32* %0, !dbg !2036
  store i32 0, i32* %index, !dbg !2037
  br label %bb4, !dbg !2038

bb2:                                              ; preds = %bb4
  br label %bb3, !dbg !2039

bb3:                                              ; preds = %bb2
  %2 = load i16, i16* %offset.addr, !dbg !2040
  %3 = add i16 %2, 1, !dbg !2040
  %4 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %value.addr, i32 1), !dbg !2040
  %5 = trunc i32 %4 to i16, !dbg !2040
  %6 = add i16 %3, %5, !dbg !2040
  store i16 %6, i16* %WriteToArray.ret, !dbg !2040
  %7 = load i16, i16* %WriteToArray.ret, !dbg !2041
  ret i16 %7, !dbg !2041

bb4:                                              ; preds = %bb5, %bb1
  %8 = load i32, i32* %index, !dbg !2038
  %9 = load i32, i32* %0, !dbg !2038
  %10 = icmp sgt i32 %8, %9, !dbg !2038
  br i1 %10, label %bb2, label %bb6, !dbg !2038

bb5:                                              ; preds = %bb8
  %11 = load i32, i32* %index, !dbg !2038
  %12 = add i32 %11, 1, !dbg !2038
  store i32 %12, i32* %index, !dbg !2038
  br label %bb4, !dbg !2038

bb6:                                              ; preds = %bb4
  %13 = load i16, i16* %offset.addr, !dbg !2042
  %14 = zext i16 %13 to i32, !dbg !2042
  %15 = load i32, i32* %index, !dbg !2042
  %16 = add i32 %15, %14, !dbg !2042
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2042
  %17 = call i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* %auto_deref_buffer.addr, i32 1), !dbg !2042
  %18 = icmp slt i32 %16, %17, !dbg !2042
  br i1 %18, label %bb9, label %bb7, !dbg !2042

bb7:                                              ; preds = %bb9, %bb6
  br label %bb8, !dbg !2043

bb8:                                              ; preds = %bb7
  br label %bb5, !dbg !2038

bb9:                                              ; preds = %bb6
  %19 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %value.addr, i32 0, i32 0, !dbg !2044
  %"$elementPtr" = load i8*, i8** %19, !dbg !2044
  %"$allBounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %value.addr, i32 0, i32 2, !dbg !2044
  %20 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds", !dbg !2044
  %"$bounds0" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %20, i32 0, !dbg !2044
  %21 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 0, !dbg !2044
  %"$lowerBound0" = load i32, i32* %21, !dbg !2044
  %22 = load i32, i32* %index, !dbg !2044
  %23 = sub i32 %22, %"$lowerBound0", !dbg !2044
  %24 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds0", i32 0, i32 2, !dbg !2044
  %"$countNextDims0" = load i32, i32* %24, !dbg !2044
  %25 = mul i32 %23, %"$countNextDims0", !dbg !2044
  %"$gepIndex0" = add i32 0, %25, !dbg !2044
  %26 = getelementptr i8, i8* %"$elementPtr", i32 %"$gepIndex0", !dbg !2044
  %27 = load i16, i16* %offset.addr, !dbg !2044
  %28 = zext i16 %27 to i32, !dbg !2044
  %29 = load i32, i32* %index, !dbg !2044
  %30 = add i32 %28, %29, !dbg !2044
  %auto_deref_buffer.addr1 = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2044
  %31 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %auto_deref_buffer.addr1, i32 0, i32 0, !dbg !2044
  %"$elementPtr2" = load i8*, i8** %31, !dbg !2044
  %"$allBounds3" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %auto_deref_buffer.addr1, i32 0, i32 2, !dbg !2044
  %32 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %"$allBounds3", !dbg !2044
  %"$bounds04" = getelementptr %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %32, i32 0, !dbg !2044
  %33 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds04", i32 0, i32 0, !dbg !2044
  %"$lowerBound05" = load i32, i32* %33, !dbg !2044
  %34 = sub i32 %30, %"$lowerBound05", !dbg !2044
  %35 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %"$bounds04", i32 0, i32 2, !dbg !2044
  %"$countNextDims06" = load i32, i32* %35, !dbg !2044
  %36 = mul i32 %34, %"$countNextDims06", !dbg !2044
  %"$gepIndex07" = add i32 0, %36, !dbg !2044
  %37 = getelementptr i8, i8* %"$elementPtr2", i32 %"$gepIndex07", !dbg !2044
  %38 = load i8, i8* %26, !dbg !2044
  store i8 %38, i8* %37, !dbg !2044
  br label %bb7, !dbg !2044
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int1@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i1 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2045 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i1
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [1 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2048, metadata !DIExpression()), !dbg !2049
  call void @llvm.dbg.declare(metadata i1* %value.addr, metadata !2050, metadata !DIExpression()), !dbg !2051
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2052, metadata !DIExpression()), !dbg !2053
  call void @llvm.dbg.declare(metadata [1 x i8]* %valueArray, metadata !2054, metadata !DIExpression()), !dbg !2057
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2058, metadata !DIExpression()), !dbg !2059
  %0 = alloca [1 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i1 %value, i1* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [1 x i8] zeroinitializer, [1 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i1, i1* %value.addr, !dbg !2060
  %4 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %3), !dbg !2060
  store [1 x i8] %4, [1 x i8]* %0, !dbg !2060
  %5 = load [1 x i8], [1 x i8]* %0, !dbg !2060
  store [1 x i8] %5, [1 x i8]* %valueArray, !dbg !2060
  %6 = load i16, i16* %offset.addr, !dbg !2061
  %7 = bitcast [1 x i8]* %valueArray to i8*, !dbg !2061
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2061
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2061
  store i8* %7, i8** %"$array_ptr", !dbg !2061
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2061
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2061
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2061
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2061
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2061
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2061
  store i16 %10, i16* %WriteToArray.ret, !dbg !2061
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2062
  ret i16 %11, !dbg !2062
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i16 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2063 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i16
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [2 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2068, metadata !DIExpression()), !dbg !2069
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2070, metadata !DIExpression()), !dbg !2071
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2072, metadata !DIExpression()), !dbg !2073
  call void @llvm.dbg.declare(metadata [2 x i8]* %valueArray, metadata !2074, metadata !DIExpression()), !dbg !2077
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2078, metadata !DIExpression()), !dbg !2079
  %0 = alloca [2 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i16 %value, i16* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [2 x i8] zeroinitializer, [2 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i16, i16* %value.addr, !dbg !2080
  %4 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Byte16@value"(i16 %3), !dbg !2080
  store [2 x i8] %4, [2 x i8]* %0, !dbg !2080
  %5 = load [2 x i8], [2 x i8]* %0, !dbg !2080
  store [2 x i8] %5, [2 x i8]* %valueArray, !dbg !2080
  %6 = load i16, i16* %offset.addr, !dbg !2081
  %7 = bitcast [2 x i8]* %valueArray to i8*, !dbg !2081
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2081
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2081
  store i8* %7, i8** %"$array_ptr", !dbg !2081
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2081
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2081
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2081
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2081
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2081
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2081
  store i16 %10, i16* %WriteToArray.ret, !dbg !2081
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2082
  ret i16 %11, !dbg !2082
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte32@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i32 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2083 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i32
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [4 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2088, metadata !DIExpression()), !dbg !2089
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2090, metadata !DIExpression()), !dbg !2091
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2092, metadata !DIExpression()), !dbg !2093
  call void @llvm.dbg.declare(metadata [4 x i8]* %valueArray, metadata !2094, metadata !DIExpression()), !dbg !2099
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2100, metadata !DIExpression()), !dbg !2101
  %0 = alloca [4 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 3, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i32 %value, i32* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [4 x i8] zeroinitializer, [4 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i32, i32* %value.addr, !dbg !2102
  %4 = call [4 x i8] @"AxUnit.ToByteArray$I@V@Byte32@value"(i32 %3), !dbg !2102
  store [4 x i8] %4, [4 x i8]* %0, !dbg !2102
  %5 = load [4 x i8], [4 x i8]* %0, !dbg !2102
  store [4 x i8] %5, [4 x i8]* %valueArray, !dbg !2102
  %6 = load i16, i16* %offset.addr, !dbg !2103
  %7 = bitcast [4 x i8]* %valueArray to i8*, !dbg !2103
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2103
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2103
  store i8* %7, i8** %"$array_ptr", !dbg !2103
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2103
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2103
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2103
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2103
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2103
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2103
  store i16 %10, i16* %WriteToArray.ret, !dbg !2103
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2104
  ret i16 %11, !dbg !2104
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte64@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i64 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2105 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i64
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [8 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2110, metadata !DIExpression()), !dbg !2111
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2112, metadata !DIExpression()), !dbg !2113
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2114, metadata !DIExpression()), !dbg !2115
  call void @llvm.dbg.declare(metadata [8 x i8]* %valueArray, metadata !2116, metadata !DIExpression()), !dbg !2121
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2122, metadata !DIExpression()), !dbg !2123
  %0 = alloca [8 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 7, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i64 %value, i64* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [8 x i8] zeroinitializer, [8 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i64, i64* %value.addr, !dbg !2124
  %4 = call [8 x i8] @"AxUnit.ToByteArray$I@V@Byte64@value"(i64 %3), !dbg !2124
  store [8 x i8] %4, [8 x i8]* %0, !dbg !2124
  %5 = load [8 x i8], [8 x i8]* %0, !dbg !2124
  store [8 x i8] %5, [8 x i8]* %valueArray, !dbg !2124
  %6 = load i16, i16* %offset.addr, !dbg !2125
  %7 = bitcast [8 x i8]* %valueArray to i8*, !dbg !2125
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2125
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2125
  store i8* %7, i8** %"$array_ptr", !dbg !2125
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2125
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2125
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2125
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2125
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2125
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2125
  store i16 %10, i16* %WriteToArray.ret, !dbg !2125
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2126
  ret i16 %11, !dbg !2126
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i8 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2127 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i8
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [1 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2130, metadata !DIExpression()), !dbg !2131
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2132, metadata !DIExpression()), !dbg !2133
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2134, metadata !DIExpression()), !dbg !2135
  call void @llvm.dbg.declare(metadata [1 x i8]* %valueArray, metadata !2136, metadata !DIExpression()), !dbg !2137
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2138, metadata !DIExpression()), !dbg !2139
  %0 = alloca [1 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i8 %value, i8* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [1 x i8] zeroinitializer, [1 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i8, i8* %value.addr, !dbg !2140
  %4 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Byte8@value"(i8 %3), !dbg !2140
  store [1 x i8] %4, [1 x i8]* %0, !dbg !2140
  %5 = load [1 x i8], [1 x i8]* %0, !dbg !2140
  store [1 x i8] %5, [1 x i8]* %valueArray, !dbg !2140
  %6 = load i16, i16* %offset.addr, !dbg !2141
  %7 = bitcast [1 x i8]* %valueArray to i8*, !dbg !2141
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2141
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2141
  store i8* %7, i8** %"$array_ptr", !dbg !2141
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2141
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2141
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2141
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2141
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2141
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2141
  store i16 %10, i16* %WriteToArray.ret, !dbg !2141
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2142
  ret i16 %11, !dbg !2142
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i8 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2143 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i8
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [1 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2146, metadata !DIExpression()), !dbg !2147
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2148, metadata !DIExpression()), !dbg !2149
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2150, metadata !DIExpression()), !dbg !2151
  call void @llvm.dbg.declare(metadata [1 x i8]* %valueArray, metadata !2152, metadata !DIExpression()), !dbg !2153
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2154, metadata !DIExpression()), !dbg !2155
  %0 = alloca [1 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i8 %value, i8* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [1 x i8] zeroinitializer, [1 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i8, i8* %value.addr, !dbg !2156
  %4 = call [1 x i8] @"AxUnit.ToByteArray$I@V@Int8@value"(i8 %3), !dbg !2156
  store [1 x i8] %4, [1 x i8]* %0, !dbg !2156
  %5 = load [1 x i8], [1 x i8]* %0, !dbg !2156
  store [1 x i8] %5, [1 x i8]* %valueArray, !dbg !2156
  %6 = load i16, i16* %offset.addr, !dbg !2157
  %7 = bitcast [1 x i8]* %valueArray to i8*, !dbg !2157
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2157
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2157
  store i8* %7, i8** %"$array_ptr", !dbg !2157
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2157
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2157
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2157
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2157
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2157
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2157
  store i16 %10, i16* %WriteToArray.ret, !dbg !2157
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2158
  ret i16 %11, !dbg !2158
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i16 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2159 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i16
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [2 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2162, metadata !DIExpression()), !dbg !2163
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2164, metadata !DIExpression()), !dbg !2165
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2166, metadata !DIExpression()), !dbg !2167
  call void @llvm.dbg.declare(metadata [2 x i8]* %valueArray, metadata !2168, metadata !DIExpression()), !dbg !2169
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2170, metadata !DIExpression()), !dbg !2171
  %0 = alloca [2 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i16 %value, i16* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [2 x i8] zeroinitializer, [2 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i16, i16* %value.addr, !dbg !2172
  %4 = call [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %3), !dbg !2172
  store [2 x i8] %4, [2 x i8]* %0, !dbg !2172
  %5 = load [2 x i8], [2 x i8]* %0, !dbg !2172
  store [2 x i8] %5, [2 x i8]* %valueArray, !dbg !2172
  %6 = load i16, i16* %offset.addr, !dbg !2173
  %7 = bitcast [2 x i8]* %valueArray to i8*, !dbg !2173
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2173
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2173
  store i8* %7, i8** %"$array_ptr", !dbg !2173
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2173
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2173
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2173
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2173
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2173
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2173
  store i16 %10, i16* %WriteToArray.ret, !dbg !2173
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2174
  ret i16 %11, !dbg !2174
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int32@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i32 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2175 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i32
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [4 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2178, metadata !DIExpression()), !dbg !2179
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2180, metadata !DIExpression()), !dbg !2181
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2182, metadata !DIExpression()), !dbg !2183
  call void @llvm.dbg.declare(metadata [4 x i8]* %valueArray, metadata !2184, metadata !DIExpression()), !dbg !2185
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2186, metadata !DIExpression()), !dbg !2187
  %0 = alloca [4 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 3, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i32 %value, i32* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [4 x i8] zeroinitializer, [4 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i32, i32* %value.addr, !dbg !2188
  %4 = call [4 x i8] @"AxUnit.ToByteArray$I@V@Int32@value"(i32 %3), !dbg !2188
  store [4 x i8] %4, [4 x i8]* %0, !dbg !2188
  %5 = load [4 x i8], [4 x i8]* %0, !dbg !2188
  store [4 x i8] %5, [4 x i8]* %valueArray, !dbg !2188
  %6 = load i16, i16* %offset.addr, !dbg !2189
  %7 = bitcast [4 x i8]* %valueArray to i8*, !dbg !2189
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2189
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2189
  store i8* %7, i8** %"$array_ptr", !dbg !2189
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2189
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2189
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2189
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2189
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2189
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2189
  store i16 %10, i16* %WriteToArray.ret, !dbg !2189
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2190
  ret i16 %11, !dbg !2190
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int64@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i64 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2191 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i64
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [8 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2194, metadata !DIExpression()), !dbg !2195
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2196, metadata !DIExpression()), !dbg !2197
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2198, metadata !DIExpression()), !dbg !2199
  call void @llvm.dbg.declare(metadata [8 x i8]* %valueArray, metadata !2200, metadata !DIExpression()), !dbg !2201
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2202, metadata !DIExpression()), !dbg !2203
  %0 = alloca [8 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 7, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i64 %value, i64* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [8 x i8] zeroinitializer, [8 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i64, i64* %value.addr, !dbg !2204
  %4 = call [8 x i8] @"AxUnit.ToByteArray$I@V@Int64@value"(i64 %3), !dbg !2204
  store [8 x i8] %4, [8 x i8]* %0, !dbg !2204
  %5 = load [8 x i8], [8 x i8]* %0, !dbg !2204
  store [8 x i8] %5, [8 x i8]* %valueArray, !dbg !2204
  %6 = load i16, i16* %offset.addr, !dbg !2205
  %7 = bitcast [8 x i8]* %valueArray to i8*, !dbg !2205
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2205
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2205
  store i8* %7, i8** %"$array_ptr", !dbg !2205
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2205
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2205
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2205
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2205
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2205
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2205
  store i16 %10, i16* %WriteToArray.ret, !dbg !2205
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2206
  ret i16 %11, !dbg !2206
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i8 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2207 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i8
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [1 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2210, metadata !DIExpression()), !dbg !2211
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2212, metadata !DIExpression()), !dbg !2213
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2214, metadata !DIExpression()), !dbg !2215
  call void @llvm.dbg.declare(metadata [1 x i8]* %valueArray, metadata !2216, metadata !DIExpression()), !dbg !2217
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2218, metadata !DIExpression()), !dbg !2219
  %0 = alloca [1 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 0, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i8 %value, i8* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [1 x i8] zeroinitializer, [1 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i8, i8* %value.addr, !dbg !2220
  %4 = call [1 x i8] @"AxUnit.ToByteArray$I@V@UInt8@value"(i8 %3), !dbg !2220
  store [1 x i8] %4, [1 x i8]* %0, !dbg !2220
  %5 = load [1 x i8], [1 x i8]* %0, !dbg !2220
  store [1 x i8] %5, [1 x i8]* %valueArray, !dbg !2220
  %6 = load i16, i16* %offset.addr, !dbg !2221
  %7 = bitcast [1 x i8]* %valueArray to i8*, !dbg !2221
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2221
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2221
  store i8* %7, i8** %"$array_ptr", !dbg !2221
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2221
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2221
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2221
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2221
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2221
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2221
  store i16 %10, i16* %WriteToArray.ret, !dbg !2221
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2222
  ret i16 %11, !dbg !2222
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i16 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2223 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i16
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [2 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2226, metadata !DIExpression()), !dbg !2227
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2228, metadata !DIExpression()), !dbg !2229
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2230, metadata !DIExpression()), !dbg !2231
  call void @llvm.dbg.declare(metadata [2 x i8]* %valueArray, metadata !2232, metadata !DIExpression()), !dbg !2233
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2234, metadata !DIExpression()), !dbg !2235
  %0 = alloca [2 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 1, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i16 %value, i16* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [2 x i8] zeroinitializer, [2 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i16, i16* %value.addr, !dbg !2236
  %4 = call [2 x i8] @"AxUnit.ToByteArray$I@V@UInt16@value"(i16 %3), !dbg !2236
  store [2 x i8] %4, [2 x i8]* %0, !dbg !2236
  %5 = load [2 x i8], [2 x i8]* %0, !dbg !2236
  store [2 x i8] %5, [2 x i8]* %valueArray, !dbg !2236
  %6 = load i16, i16* %offset.addr, !dbg !2237
  %7 = bitcast [2 x i8]* %valueArray to i8*, !dbg !2237
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2237
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2237
  store i8* %7, i8** %"$array_ptr", !dbg !2237
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2237
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2237
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2237
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2237
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2237
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2237
  store i16 %10, i16* %WriteToArray.ret, !dbg !2237
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2238
  ret i16 %11, !dbg !2238
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt32@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i32 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2239 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i32
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [4 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2242, metadata !DIExpression()), !dbg !2243
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2244, metadata !DIExpression()), !dbg !2245
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2246, metadata !DIExpression()), !dbg !2247
  call void @llvm.dbg.declare(metadata [4 x i8]* %valueArray, metadata !2248, metadata !DIExpression()), !dbg !2249
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2250, metadata !DIExpression()), !dbg !2251
  %0 = alloca [4 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 3, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i32 %value, i32* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [4 x i8] zeroinitializer, [4 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i32, i32* %value.addr, !dbg !2252
  %4 = call [4 x i8] @"AxUnit.ToByteArray$I@V@UInt32@value"(i32 %3), !dbg !2252
  store [4 x i8] %4, [4 x i8]* %0, !dbg !2252
  %5 = load [4 x i8], [4 x i8]* %0, !dbg !2252
  store [4 x i8] %5, [4 x i8]* %valueArray, !dbg !2252
  %6 = load i16, i16* %offset.addr, !dbg !2253
  %7 = bitcast [4 x i8]* %valueArray to i8*, !dbg !2253
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2253
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2253
  store i8* %7, i8** %"$array_ptr", !dbg !2253
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2253
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2253
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2253
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2253
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2253
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2253
  store i16 %10, i16* %WriteToArray.ret, !dbg !2253
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2254
  ret i16 %11, !dbg !2254
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt64@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, i64 %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2255 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca i64
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [8 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2258, metadata !DIExpression()), !dbg !2259
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2260, metadata !DIExpression()), !dbg !2261
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2262, metadata !DIExpression()), !dbg !2263
  call void @llvm.dbg.declare(metadata [8 x i8]* %valueArray, metadata !2264, metadata !DIExpression()), !dbg !2265
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2266, metadata !DIExpression()), !dbg !2267
  %0 = alloca [8 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 7, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store i64 %value, i64* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [8 x i8] zeroinitializer, [8 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load i64, i64* %value.addr, !dbg !2268
  %4 = call [8 x i8] @"AxUnit.ToByteArray$I@V@UInt64@value"(i64 %3), !dbg !2268
  store [8 x i8] %4, [8 x i8]* %0, !dbg !2268
  %5 = load [8 x i8], [8 x i8]* %0, !dbg !2268
  store [8 x i8] %5, [8 x i8]* %valueArray, !dbg !2268
  %6 = load i16, i16* %offset.addr, !dbg !2269
  %7 = bitcast [8 x i8]* %valueArray to i8*, !dbg !2269
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2269
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2269
  store i8* %7, i8** %"$array_ptr", !dbg !2269
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2269
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2269
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2269
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2269
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2269
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2269
  store i16 %10, i16* %WriteToArray.ret, !dbg !2269
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2270
  ret i16 %11, !dbg !2270
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Float@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, float %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2271 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca float
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [4 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2276, metadata !DIExpression()), !dbg !2277
  call void @llvm.dbg.declare(metadata float* %value.addr, metadata !2278, metadata !DIExpression()), !dbg !2279
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2280, metadata !DIExpression()), !dbg !2281
  call void @llvm.dbg.declare(metadata [4 x i8]* %valueArray, metadata !2282, metadata !DIExpression()), !dbg !2283
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2284, metadata !DIExpression()), !dbg !2285
  %0 = alloca [4 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 3, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store float %value, float* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [4 x i8] zeroinitializer, [4 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load float, float* %value.addr, !dbg !2286
  %4 = call [4 x i8] @"AxUnit.ToByteArray$I@V@Float@value"(float %3), !dbg !2286
  store [4 x i8] %4, [4 x i8]* %0, !dbg !2286
  %5 = load [4 x i8], [4 x i8]* %0, !dbg !2286
  store [4 x i8] %5, [4 x i8]* %valueArray, !dbg !2286
  %6 = load i16, i16* %offset.addr, !dbg !2287
  %7 = bitcast [4 x i8]* %valueArray to i8*, !dbg !2287
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2287
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2287
  store i8* %7, i8** %"$array_ptr", !dbg !2287
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2287
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2287
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2287
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2287
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2287
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2287
  store i16 %10, i16* %WriteToArray.ret, !dbg !2287
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2288
  ret i16 %11, !dbg !2288
}

define i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Double@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %offset, double %value, %"$ax.ArrayWithBound"* %buffer) !dbg !2289 {
Entry:
  %WriteToArray.ret = alloca i16
  %offset.addr = alloca i16
  %value.addr = alloca double
  %buffer.addr = alloca %"$ax.ArrayWithBound"*
  %valueArray = alloca [8 x i8]
  call void @llvm.dbg.declare(metadata i16* %offset.addr, metadata !2294, metadata !DIExpression()), !dbg !2295
  call void @llvm.dbg.declare(metadata double* %value.addr, metadata !2296, metadata !DIExpression()), !dbg !2297
  call void @llvm.dbg.declare(metadata %"$ax.ArrayWithBound"** %buffer.addr, metadata !2298, metadata !DIExpression()), !dbg !2299
  call void @llvm.dbg.declare(metadata [8 x i8]* %valueArray, metadata !2300, metadata !DIExpression()), !dbg !2301
  call void @llvm.dbg.declare(metadata i16* %WriteToArray.ret, metadata !2302, metadata !DIExpression()), !dbg !2303
  %0 = alloca [8 x i8]
  %1 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 7, i32 1 }], [1 x %"$ax.ArrayBounds"]* %1
  %2 = alloca %"$ax.ArrayWithBound"
  store i16 0, i16* %WriteToArray.ret
  store i16 %offset, i16* %offset.addr
  store double %value, double* %value.addr
  store %"$ax.ArrayWithBound"* %buffer, %"$ax.ArrayWithBound"** %buffer.addr
  store [8 x i8] zeroinitializer, [8 x i8]* %valueArray
  br label %bb1

bb1:                                              ; preds = %Entry
  %3 = load double, double* %value.addr, !dbg !2304
  %4 = call [8 x i8] @"AxUnit.ToByteArray$I@V@Double@value"(double %3), !dbg !2304
  store [8 x i8] %4, [8 x i8]* %0, !dbg !2304
  %5 = load [8 x i8], [8 x i8]* %0, !dbg !2304
  store [8 x i8] %5, [8 x i8]* %valueArray, !dbg !2304
  %6 = load i16, i16* %offset.addr, !dbg !2305
  %7 = bitcast [8 x i8]* %valueArray to i8*, !dbg !2305
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %2, !dbg !2305
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 0, !dbg !2305
  store i8* %7, i8** %"$array_ptr", !dbg !2305
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, i32 0, i32 2, !dbg !2305
  %8 = bitcast [1 x %"$ax.ArrayBounds"]* %1 to %"$ax.ArrayBounds"*, !dbg !2305
  store %"$ax.ArrayBounds"* %8, %"$ax.ArrayBounds"** %"$bounds", !dbg !2305
  %9 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %2, !dbg !2305
  %auto_deref_buffer.addr = load %"$ax.ArrayWithBound"*, %"$ax.ArrayWithBound"** %buffer.addr, !dbg !2305
  %10 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %6, %"$ax.ArrayWithBound" %9, %"$ax.ArrayWithBound"* %auto_deref_buffer.addr), !dbg !2305
  store i16 %10, i16* %WriteToArray.ret, !dbg !2305
  %11 = load i16, i16* %WriteToArray.ret, !dbg !2306
  ret i16 %11, !dbg !2306
}

define [1 x i8] @"AxUnit.ToByteArray$I@V@Int1@value"(i1 %value) !dbg !2307 {
Entry:
  %ToByteArray.ret = alloca [1 x i8]
  %value.addr = alloca i1
  call void @llvm.dbg.declare(metadata i1* %value.addr, metadata !2310, metadata !DIExpression()), !dbg !2311
  call void @llvm.dbg.declare(metadata [1 x i8]* %ToByteArray.ret, metadata !2312, metadata !DIExpression()), !dbg !2313
  store [1 x i8] zeroinitializer, [1 x i8]* %ToByteArray.ret
  store i1 %value, i1* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i1, i1* %value.addr, !dbg !2314
  %1 = zext i1 %0 to i8, !dbg !2314
  call void @"AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr"(i8 %1, [1 x i8]* %ToByteArray.ret), !dbg !2314
  %2 = load [1 x i8], [1 x i8]* %ToByteArray.ret, !dbg !2315
  ret [1 x i8] %2, !dbg !2315
}

define [1 x i8] @"AxUnit.ToByteArray$I@V@Byte8@value"(i8 %value) !dbg !2316 {
Entry:
  %ToByteArray.ret = alloca [1 x i8]
  %value.addr = alloca i8
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2319, metadata !DIExpression()), !dbg !2320
  call void @llvm.dbg.declare(metadata [1 x i8]* %ToByteArray.ret, metadata !2321, metadata !DIExpression()), !dbg !2322
  store [1 x i8] zeroinitializer, [1 x i8]* %ToByteArray.ret
  store i8 %value, i8* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr, !dbg !2323
  call void @"AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr"(i8 %0, [1 x i8]* %ToByteArray.ret), !dbg !2323
  %1 = load [1 x i8], [1 x i8]* %ToByteArray.ret, !dbg !2324
  ret [1 x i8] %1, !dbg !2324
}

define [1 x i8] @"AxUnit.ToByteArray$I@V@Int8@value"(i8 %value) !dbg !2325 {
Entry:
  %ToByteArray.ret = alloca [1 x i8]
  %value.addr = alloca i8
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2328, metadata !DIExpression()), !dbg !2329
  call void @llvm.dbg.declare(metadata [1 x i8]* %ToByteArray.ret, metadata !2330, metadata !DIExpression()), !dbg !2331
  store [1 x i8] zeroinitializer, [1 x i8]* %ToByteArray.ret
  store i8 %value, i8* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr, !dbg !2332
  call void @"AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr"(i8 %0, [1 x i8]* %ToByteArray.ret), !dbg !2332
  %1 = load [1 x i8], [1 x i8]* %ToByteArray.ret, !dbg !2333
  ret [1 x i8] %1, !dbg !2333
}

define [1 x i8] @"AxUnit.ToByteArray$I@V@UInt8@value"(i8 %value) !dbg !2334 {
Entry:
  %ToByteArray.ret = alloca [1 x i8]
  %value.addr = alloca i8
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2337, metadata !DIExpression()), !dbg !2338
  call void @llvm.dbg.declare(metadata [1 x i8]* %ToByteArray.ret, metadata !2339, metadata !DIExpression()), !dbg !2340
  store [1 x i8] zeroinitializer, [1 x i8]* %ToByteArray.ret
  store i8 %value, i8* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr, !dbg !2341
  call void @"AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr"(i8 %0, [1 x i8]* %ToByteArray.ret), !dbg !2341
  %1 = load [1 x i8], [1 x i8]* %ToByteArray.ret, !dbg !2342
  ret [1 x i8] %1, !dbg !2342
}

define [2 x i8] @"AxUnit.ToByteArray$I@V@Byte16@value"(i16 %value) !dbg !2343 {
Entry:
  %ToByteArray.ret = alloca [2 x i8]
  %value.addr = alloca i16
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2346, metadata !DIExpression()), !dbg !2347
  call void @llvm.dbg.declare(metadata [2 x i8]* %ToByteArray.ret, metadata !2348, metadata !DIExpression()), !dbg !2349
  store [2 x i8] zeroinitializer, [2 x i8]* %ToByteArray.ret
  store i16 %value, i16* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr, !dbg !2350
  call void @"AxUnit.ToByteArray16$I@V@Byte16@value?I@R@ARRAY [0..1] OF BYTE@arr"(i16 %0, [2 x i8]* %ToByteArray.ret), !dbg !2350
  %1 = load [2 x i8], [2 x i8]* %ToByteArray.ret, !dbg !2351
  ret [2 x i8] %1, !dbg !2351
}

define [4 x i8] @"AxUnit.ToByteArray$I@V@Byte32@value"(i32 %value) !dbg !2352 {
Entry:
  %ToByteArray.ret = alloca [4 x i8]
  %value.addr = alloca i32
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2355, metadata !DIExpression()), !dbg !2356
  call void @llvm.dbg.declare(metadata [4 x i8]* %ToByteArray.ret, metadata !2357, metadata !DIExpression()), !dbg !2358
  store [4 x i8] zeroinitializer, [4 x i8]* %ToByteArray.ret
  store i32 %value, i32* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr, !dbg !2359
  call void @"AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr"(i32 %0, [4 x i8]* %ToByteArray.ret), !dbg !2359
  %1 = load [4 x i8], [4 x i8]* %ToByteArray.ret, !dbg !2360
  ret [4 x i8] %1, !dbg !2360
}

define [4 x i8] @"AxUnit.ToByteArray$I@V@UInt32@value"(i32 %value) !dbg !2361 {
Entry:
  %ToByteArray.ret = alloca [4 x i8]
  %value.addr = alloca i32
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2364, metadata !DIExpression()), !dbg !2365
  call void @llvm.dbg.declare(metadata [4 x i8]* %ToByteArray.ret, metadata !2366, metadata !DIExpression()), !dbg !2367
  store [4 x i8] zeroinitializer, [4 x i8]* %ToByteArray.ret
  store i32 %value, i32* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr, !dbg !2368
  call void @"AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr"(i32 %0, [4 x i8]* %ToByteArray.ret), !dbg !2368
  %1 = load [4 x i8], [4 x i8]* %ToByteArray.ret, !dbg !2369
  ret [4 x i8] %1, !dbg !2369
}

define [2 x i8] @"AxUnit.ToByteArray$I@V@Int16@value"(i16 %value) !dbg !2370 {
Entry:
  %ToByteArray.ret = alloca [2 x i8]
  %value.addr = alloca i16
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2373, metadata !DIExpression()), !dbg !2374
  call void @llvm.dbg.declare(metadata [2 x i8]* %ToByteArray.ret, metadata !2375, metadata !DIExpression()), !dbg !2376
  store [2 x i8] zeroinitializer, [2 x i8]* %ToByteArray.ret
  store i16 %value, i16* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr, !dbg !2377
  call void @"AxUnit.ToByteArray16$I@V@Byte16@value?I@R@ARRAY [0..1] OF BYTE@arr"(i16 %0, [2 x i8]* %ToByteArray.ret), !dbg !2377
  %1 = load [2 x i8], [2 x i8]* %ToByteArray.ret, !dbg !2378
  ret [2 x i8] %1, !dbg !2378
}

define [2 x i8] @"AxUnit.ToByteArray$I@V@UInt16@value"(i16 %value) !dbg !2379 {
Entry:
  %ToByteArray.ret = alloca [2 x i8]
  %value.addr = alloca i16
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2382, metadata !DIExpression()), !dbg !2383
  call void @llvm.dbg.declare(metadata [2 x i8]* %ToByteArray.ret, metadata !2384, metadata !DIExpression()), !dbg !2385
  store [2 x i8] zeroinitializer, [2 x i8]* %ToByteArray.ret
  store i16 %value, i16* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr, !dbg !2386
  call void @"AxUnit.ToByteArray16$I@V@Byte16@value?I@R@ARRAY [0..1] OF BYTE@arr"(i16 %0, [2 x i8]* %ToByteArray.ret), !dbg !2386
  %1 = load [2 x i8], [2 x i8]* %ToByteArray.ret, !dbg !2387
  ret [2 x i8] %1, !dbg !2387
}

define [4 x i8] @"AxUnit.ToByteArray$I@V@Int32@value"(i32 %value) !dbg !2388 {
Entry:
  %ToByteArray.ret = alloca [4 x i8]
  %value.addr = alloca i32
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2391, metadata !DIExpression()), !dbg !2392
  call void @llvm.dbg.declare(metadata [4 x i8]* %ToByteArray.ret, metadata !2393, metadata !DIExpression()), !dbg !2394
  store [4 x i8] zeroinitializer, [4 x i8]* %ToByteArray.ret
  store i32 %value, i32* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr, !dbg !2395
  call void @"AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr"(i32 %0, [4 x i8]* %ToByteArray.ret), !dbg !2395
  %1 = load [4 x i8], [4 x i8]* %ToByteArray.ret, !dbg !2396
  ret [4 x i8] %1, !dbg !2396
}

define [8 x i8] @"AxUnit.ToByteArray$I@V@Int64@value"(i64 %value) !dbg !2397 {
Entry:
  %ToByteArray.ret = alloca [8 x i8]
  %value.addr = alloca i64
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2400, metadata !DIExpression()), !dbg !2401
  call void @llvm.dbg.declare(metadata [8 x i8]* %ToByteArray.ret, metadata !2402, metadata !DIExpression()), !dbg !2403
  store [8 x i8] zeroinitializer, [8 x i8]* %ToByteArray.ret
  store i64 %value, i64* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr, !dbg !2404
  call void @"AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr"(i64 %0, [8 x i8]* %ToByteArray.ret), !dbg !2404
  %1 = load [8 x i8], [8 x i8]* %ToByteArray.ret, !dbg !2405
  ret [8 x i8] %1, !dbg !2405
}

define [4 x i8] @"AxUnit.ToByteArray$I@V@Float@value"(float %value) !dbg !2406 {
Entry:
  %ToByteArray.ret = alloca [4 x i8]
  %value.addr = alloca float
  call void @llvm.dbg.declare(metadata float* %value.addr, metadata !2409, metadata !DIExpression()), !dbg !2410
  call void @llvm.dbg.declare(metadata [4 x i8]* %ToByteArray.ret, metadata !2411, metadata !DIExpression()), !dbg !2412
  store [4 x i8] zeroinitializer, [4 x i8]* %ToByteArray.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr, !dbg !2413
  %1 = bitcast float %0 to i32, !dbg !2413
  call void @"AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr"(i32 %1, [4 x i8]* %ToByteArray.ret), !dbg !2413
  %2 = load [4 x i8], [4 x i8]* %ToByteArray.ret, !dbg !2414
  ret [4 x i8] %2, !dbg !2414
}

define [8 x i8] @"AxUnit.ToByteArray$I@V@Byte64@value"(i64 %value) !dbg !2415 {
Entry:
  %ToByteArray.ret = alloca [8 x i8]
  %value.addr = alloca i64
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2418, metadata !DIExpression()), !dbg !2419
  call void @llvm.dbg.declare(metadata [8 x i8]* %ToByteArray.ret, metadata !2420, metadata !DIExpression()), !dbg !2421
  store [8 x i8] zeroinitializer, [8 x i8]* %ToByteArray.ret
  store i64 %value, i64* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr, !dbg !2422
  call void @"AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr"(i64 %0, [8 x i8]* %ToByteArray.ret), !dbg !2422
  %1 = load [8 x i8], [8 x i8]* %ToByteArray.ret, !dbg !2423
  ret [8 x i8] %1, !dbg !2423
}

define [8 x i8] @"AxUnit.ToByteArray$I@V@UInt64@value"(i64 %value) !dbg !2424 {
Entry:
  %ToByteArray.ret = alloca [8 x i8]
  %value.addr = alloca i64
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2427, metadata !DIExpression()), !dbg !2428
  call void @llvm.dbg.declare(metadata [8 x i8]* %ToByteArray.ret, metadata !2429, metadata !DIExpression()), !dbg !2430
  store [8 x i8] zeroinitializer, [8 x i8]* %ToByteArray.ret
  store i64 %value, i64* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr, !dbg !2431
  call void @"AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr"(i64 %0, [8 x i8]* %ToByteArray.ret), !dbg !2431
  %1 = load [8 x i8], [8 x i8]* %ToByteArray.ret, !dbg !2432
  ret [8 x i8] %1, !dbg !2432
}

define [8 x i8] @"AxUnit.ToByteArray$I@V@Double@value"(double %value) !dbg !2433 {
Entry:
  %ToByteArray.ret = alloca [8 x i8]
  %value.addr = alloca double
  call void @llvm.dbg.declare(metadata double* %value.addr, metadata !2436, metadata !DIExpression()), !dbg !2437
  call void @llvm.dbg.declare(metadata [8 x i8]* %ToByteArray.ret, metadata !2438, metadata !DIExpression()), !dbg !2439
  store [8 x i8] zeroinitializer, [8 x i8]* %ToByteArray.ret
  store double %value, double* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr, !dbg !2440
  %1 = bitcast double %0 to i64, !dbg !2440
  call void @"AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr"(i64 %1, [8 x i8]* %ToByteArray.ret), !dbg !2440
  %2 = load [8 x i8], [8 x i8]* %ToByteArray.ret, !dbg !2441
  ret [8 x i8] %2, !dbg !2441
}

define void @"AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr"(i64 %value, [8 x i8]* %arr) !dbg !2442 {
Entry:
  %value.addr = alloca i64
  %arr.addr = alloca [8 x i8]*
  call void @llvm.dbg.declare(metadata i64* %value.addr, metadata !2446, metadata !DIExpression()), !dbg !2447
  call void @llvm.dbg.declare(metadata [8 x i8]** %arr.addr, metadata !2448, metadata !DIExpression()), !dbg !2449
  store i64 %value, i64* %value.addr
  store [8 x i8]* %arr, [8 x i8]** %arr.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr, !dbg !2450
  %1 = lshr i64 %0, 56, !dbg !2450
  %2 = trunc i64 %1 to i8, !dbg !2450
  %auto_deref_arr.addr = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2450
  %3 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr, i32 0, i32 0, !dbg !2450
  store i8 %2, i8* %3, !dbg !2450
  %4 = load i64, i64* %value.addr, !dbg !2451
  %5 = lshr i64 %4, 48, !dbg !2451
  %6 = trunc i64 %5 to i8, !dbg !2451
  %auto_deref_arr.addr1 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2451
  %7 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr1, i32 0, i32 1, !dbg !2451
  store i8 %6, i8* %7, !dbg !2451
  %8 = load i64, i64* %value.addr, !dbg !2452
  %9 = lshr i64 %8, 40, !dbg !2452
  %10 = trunc i64 %9 to i8, !dbg !2452
  %auto_deref_arr.addr2 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2452
  %11 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr2, i32 0, i32 2, !dbg !2452
  store i8 %10, i8* %11, !dbg !2452
  %12 = load i64, i64* %value.addr, !dbg !2453
  %13 = lshr i64 %12, 32, !dbg !2453
  %14 = trunc i64 %13 to i8, !dbg !2453
  %auto_deref_arr.addr3 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2453
  %15 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr3, i32 0, i32 3, !dbg !2453
  store i8 %14, i8* %15, !dbg !2453
  %16 = load i64, i64* %value.addr, !dbg !2454
  %17 = lshr i64 %16, 24, !dbg !2454
  %18 = trunc i64 %17 to i8, !dbg !2454
  %auto_deref_arr.addr4 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2454
  %19 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr4, i32 0, i32 4, !dbg !2454
  store i8 %18, i8* %19, !dbg !2454
  %20 = load i64, i64* %value.addr, !dbg !2455
  %21 = lshr i64 %20, 16, !dbg !2455
  %22 = trunc i64 %21 to i8, !dbg !2455
  %auto_deref_arr.addr5 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2455
  %23 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr5, i32 0, i32 5, !dbg !2455
  store i8 %22, i8* %23, !dbg !2455
  %24 = load i64, i64* %value.addr, !dbg !2456
  %25 = lshr i64 %24, 8, !dbg !2456
  %26 = trunc i64 %25 to i8, !dbg !2456
  %auto_deref_arr.addr6 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2456
  %27 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr6, i32 0, i32 6, !dbg !2456
  store i8 %26, i8* %27, !dbg !2456
  %28 = load i64, i64* %value.addr, !dbg !2457
  %29 = trunc i64 %28 to i8, !dbg !2457
  %auto_deref_arr.addr7 = load [8 x i8]*, [8 x i8]** %arr.addr, !dbg !2457
  %30 = getelementptr inbounds [8 x i8], [8 x i8]* %auto_deref_arr.addr7, i32 0, i32 7, !dbg !2457
  store i8 %29, i8* %30, !dbg !2457
  ret void, !dbg !2458
}

define void @"AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr"(i32 %value, [4 x i8]* %arr) !dbg !2459 {
Entry:
  %value.addr = alloca i32
  %arr.addr = alloca [4 x i8]*
  call void @llvm.dbg.declare(metadata i32* %value.addr, metadata !2463, metadata !DIExpression()), !dbg !2464
  call void @llvm.dbg.declare(metadata [4 x i8]** %arr.addr, metadata !2465, metadata !DIExpression()), !dbg !2466
  store i32 %value, i32* %value.addr
  store [4 x i8]* %arr, [4 x i8]** %arr.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr, !dbg !2467
  %1 = lshr i32 %0, 24, !dbg !2467
  %2 = trunc i32 %1 to i8, !dbg !2467
  %auto_deref_arr.addr = load [4 x i8]*, [4 x i8]** %arr.addr, !dbg !2467
  %3 = getelementptr inbounds [4 x i8], [4 x i8]* %auto_deref_arr.addr, i32 0, i32 0, !dbg !2467
  store i8 %2, i8* %3, !dbg !2467
  %4 = load i32, i32* %value.addr, !dbg !2468
  %5 = lshr i32 %4, 16, !dbg !2468
  %6 = trunc i32 %5 to i8, !dbg !2468
  %auto_deref_arr.addr1 = load [4 x i8]*, [4 x i8]** %arr.addr, !dbg !2468
  %7 = getelementptr inbounds [4 x i8], [4 x i8]* %auto_deref_arr.addr1, i32 0, i32 1, !dbg !2468
  store i8 %6, i8* %7, !dbg !2468
  %8 = load i32, i32* %value.addr, !dbg !2469
  %9 = lshr i32 %8, 8, !dbg !2469
  %10 = trunc i32 %9 to i8, !dbg !2469
  %auto_deref_arr.addr2 = load [4 x i8]*, [4 x i8]** %arr.addr, !dbg !2469
  %11 = getelementptr inbounds [4 x i8], [4 x i8]* %auto_deref_arr.addr2, i32 0, i32 2, !dbg !2469
  store i8 %10, i8* %11, !dbg !2469
  %12 = load i32, i32* %value.addr, !dbg !2470
  %13 = trunc i32 %12 to i8, !dbg !2470
  %auto_deref_arr.addr3 = load [4 x i8]*, [4 x i8]** %arr.addr, !dbg !2470
  %14 = getelementptr inbounds [4 x i8], [4 x i8]* %auto_deref_arr.addr3, i32 0, i32 3, !dbg !2470
  store i8 %13, i8* %14, !dbg !2470
  ret void, !dbg !2471
}

define void @"AxUnit.ToByteArray16$I@V@Byte16@value?I@R@ARRAY [0..1] OF BYTE@arr"(i16 %value, [2 x i8]* %arr) !dbg !2472 {
Entry:
  %value.addr = alloca i16
  %arr.addr = alloca [2 x i8]*
  call void @llvm.dbg.declare(metadata i16* %value.addr, metadata !2476, metadata !DIExpression()), !dbg !2477
  call void @llvm.dbg.declare(metadata [2 x i8]** %arr.addr, metadata !2478, metadata !DIExpression()), !dbg !2479
  store i16 %value, i16* %value.addr
  store [2 x i8]* %arr, [2 x i8]** %arr.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr, !dbg !2480
  %1 = lshr i16 %0, 8, !dbg !2480
  %2 = trunc i16 %1 to i8, !dbg !2480
  %auto_deref_arr.addr = load [2 x i8]*, [2 x i8]** %arr.addr, !dbg !2480
  %3 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_deref_arr.addr, i32 0, i32 0, !dbg !2480
  store i8 %2, i8* %3, !dbg !2480
  %4 = load i16, i16* %value.addr, !dbg !2481
  %5 = trunc i16 %4 to i8, !dbg !2481
  %auto_deref_arr.addr1 = load [2 x i8]*, [2 x i8]** %arr.addr, !dbg !2481
  %6 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_deref_arr.addr1, i32 0, i32 1, !dbg !2481
  store i8 %5, i8* %6, !dbg !2481
  ret void, !dbg !2482
}

define void @"AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr"(i8 %value, [1 x i8]* %arr) !dbg !2483 {
Entry:
  %value.addr = alloca i8
  %arr.addr = alloca [1 x i8]*
  call void @llvm.dbg.declare(metadata i8* %value.addr, metadata !2487, metadata !DIExpression()), !dbg !2488
  call void @llvm.dbg.declare(metadata [1 x i8]** %arr.addr, metadata !2489, metadata !DIExpression()), !dbg !2490
  store i8 %value, i8* %value.addr
  store [1 x i8]* %arr, [1 x i8]** %arr.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %auto_deref_arr.addr = load [1 x i8]*, [1 x i8]** %arr.addr, !dbg !2491
  %0 = getelementptr inbounds [1 x i8], [1 x i8]* %auto_deref_arr.addr, i32 0, i32 0, !dbg !2491
  %1 = load i8, i8* %value.addr, !dbg !2491
  store i8 %1, i8* %0, !dbg !2491
  ret void, !dbg !2492
}

; Function Attrs: nounwind readnone speculatable willreturn
declare void @llvm.dbg.declare(metadata, metadata, metadata) #0

define void @axunit_TestEnvironment() {
Entry:
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %4
  %5 = alloca %"$ax.ArrayWithBound"
  %6 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %6
  %7 = alloca %"$ax.ArrayWithBound"
  %8 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %8
  %9 = alloca %"$ax.ArrayWithBound"
  %10 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %10
  %11 = alloca %"$ax.ArrayWithBound"
  %12 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %12
  %13 = alloca %"$ax.ArrayWithBound"
  %14 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %14
  %15 = alloca %"$ax.ArrayWithBound"
  %16 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %16
  %17 = alloca %"$ax.ArrayWithBound"
  %18 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %18
  %19 = alloca %"$ax.ArrayWithBound"
  %20 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %20
  %21 = alloca %"$ax.ArrayWithBound"
  %22 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %22
  %23 = alloca %"$ax.ArrayWithBound"
  %24 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %24
  %25 = alloca %"$ax.ArrayWithBound"
  %26 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %26
  %27 = alloca %"$ax.ArrayWithBound"
  %28 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %28
  %29 = alloca %"$ax.ArrayWithBound"
  %30 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %30
  %31 = alloca %"$ax.ArrayWithBound"
  br label %bb1

bb1:                                              ; preds = %Entry
  store i1 true, i1* @GlobalAssertValue
  %32 = load i16, i16* @axunit_TestsExecuted
  %33 = icmp eq i16 %32, 0
  br i1 %33, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  store i16 300, i16* @axunit_assertionData_Size
  %34 = load i16, i16* @axunit_globalTestIdPos
  %35 = add i16 %34, 7
  store i16 %35, i16* @axunit_globalSectionPosName
  br label %bb4

bb3:                                              ; preds = %bb1
  br label %bb4

bb4:                                              ; preds = %bb3, %bb2
  %36 = load i16, i16* @axunit_TestsExecuted
  %37 = icmp sge i16 %36, 4
  br i1 %37, label %bb5, label %bb6

bb5:                                              ; preds = %bb4
  ret void

bb6:                                              ; preds = %bb4
  %38 = load i8, i8* @axunit_Test_0_Result
  %39 = icmp eq i8 0, %38
  br i1 %39, label %bb9, label %bb10

bb7:                                              ; No predecessors!
  ret void

bb8:                                              ; preds = %bb38, %bb44, %bb35, %bb26, %bb17
  %40 = load i16, i16* @axunit_TestsExecuted
  %41 = add i16 %40, 1
  store i16 %41, i16* @axunit_TestsExecuted
  ret void

bb9:                                              ; preds = %bb6
  %42 = load %UsingDeserializer, %UsingDeserializer* @axunit_testfixture_instance_default_valuesUsingDeserializer
  store %UsingDeserializer %42, %UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer
  call void @"UsingDeserializer.GetValue_BASIC_DATA_TYPES$I@R@UsingDeserializer@this"(%UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer)
  %43 = load i16, i16* @axunit_globalTestIdPos
  %44 = add i16 7, %43
  %45 = load i16, i16* @axunit_globalSectionPosName
  %46 = icmp ne i16 %45, %44
  br i1 %46, label %bb12, label %bb13

bb10:                                             ; preds = %bb6
  br label %bb11

bb11:                                             ; preds = %bb10
  %47 = load i8, i8* @axunit_Test_1_Result
  %48 = icmp eq i8 0, %47
  br i1 %48, label %bb18, label %bb19

bb12:                                             ; preds = %bb9
  %49 = load i16, i16* @axunit_globalSectionPosName
  %50 = load i16, i16* @axunit_globalTestIdPos
  %51 = sub i16 %49, %50
  %52 = sub i16 %51, 4
  %53 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr"
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2
  %54 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %54, %"$ax.ArrayBounds"** %"$bounds"
  %55 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %53, i16 %51, %"$ax.ArrayWithBound"* %1)
  store i16 %55, i16* @axunit_globalTestIdPos
  %56 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3
  %"$array_ptr1" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr1"
  %"$bounds2" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2
  %57 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %57, %"$ax.ArrayBounds"** %"$bounds2"
  %58 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %56, i16 0, %"$ax.ArrayWithBound"* %3)
  store i16 %58, i16* @axunit_globalTestIdPos
  %59 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %5
  %"$array_ptr3" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr3"
  %"$bounds4" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 2
  %60 = bitcast [1 x %"$ax.ArrayBounds"]* %4 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %60, %"$ax.ArrayBounds"** %"$bounds4"
  %61 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %59, i8 1, %"$ax.ArrayWithBound"* %5)
  store i16 %61, i16* @axunit_globalTestIdPos
  %62 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %7
  %"$array_ptr5" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %7, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr5"
  %"$bounds6" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %7, i32 0, i32 2
  %63 = bitcast [1 x %"$ax.ArrayBounds"]* %6 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %63, %"$ax.ArrayBounds"** %"$bounds6"
  %64 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %62, i16 %52, %"$ax.ArrayWithBound"* %7)
  store i16 %64, i16* @axunit_globalTestIdPos
  %65 = load i16, i16* @axunit_globalSectionPosName
  store i16 %65, i16* @axunit_globalTestIdPos
  %66 = load i16, i16* @axunit_globalSectionPosName
  %67 = add i16 %66, 7
  store i16 %67, i16* @axunit_globalSectionPosName
  br label %bb14

bb13:                                             ; preds = %bb9
  br label %bb14

bb14:                                             ; preds = %bb13, %bb12
  %68 = load i1, i1* @GlobalAssertValue
  %69 = icmp eq i1 true, %68
  br i1 %69, label %bb15, label %bb16

bb15:                                             ; preds = %bb14
  store i8 1, i8* @axunit_Test_0_Result
  br label %bb17

bb16:                                             ; preds = %bb14
  store i8 2, i8* @axunit_Test_0_Result
  br label %bb17

bb17:                                             ; preds = %bb16, %bb15
  br label %bb8

bb18:                                             ; preds = %bb11
  %70 = load %UsingDeserializer, %UsingDeserializer* @axunit_testfixture_instance_default_valuesUsingDeserializer
  store %UsingDeserializer %70, %UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer
  call void @"UsingDeserializer.GetValue_ARRAY$I@R@UsingDeserializer@this"(%UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer)
  %71 = load i16, i16* @axunit_globalTestIdPos
  %72 = add i16 7, %71
  %73 = load i16, i16* @axunit_globalSectionPosName
  %74 = icmp ne i16 %73, %72
  br i1 %74, label %bb21, label %bb22

bb19:                                             ; preds = %bb11
  br label %bb20

bb20:                                             ; preds = %bb19
  %75 = load i8, i8* @axunit_Test_2_Result
  %76 = icmp eq i8 0, %75
  br i1 %76, label %bb27, label %bb28

bb21:                                             ; preds = %bb18
  %77 = load i16, i16* @axunit_globalSectionPosName
  %78 = load i16, i16* @axunit_globalTestIdPos
  %79 = sub i16 %77, %78
  %80 = sub i16 %79, 4
  %81 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %9
  %"$array_ptr7" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %9, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr7"
  %"$bounds8" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %9, i32 0, i32 2
  %82 = bitcast [1 x %"$ax.ArrayBounds"]* %8 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %82, %"$ax.ArrayBounds"** %"$bounds8"
  %83 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %81, i16 %79, %"$ax.ArrayWithBound"* %9)
  store i16 %83, i16* @axunit_globalTestIdPos
  %84 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %11
  %"$array_ptr9" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %11, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr9"
  %"$bounds10" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %11, i32 0, i32 2
  %85 = bitcast [1 x %"$ax.ArrayBounds"]* %10 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %85, %"$ax.ArrayBounds"** %"$bounds10"
  %86 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %84, i16 1, %"$ax.ArrayWithBound"* %11)
  store i16 %86, i16* @axunit_globalTestIdPos
  %87 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %13
  %"$array_ptr11" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %13, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr11"
  %"$bounds12" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %13, i32 0, i32 2
  %88 = bitcast [1 x %"$ax.ArrayBounds"]* %12 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %88, %"$ax.ArrayBounds"** %"$bounds12"
  %89 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %87, i8 1, %"$ax.ArrayWithBound"* %13)
  store i16 %89, i16* @axunit_globalTestIdPos
  %90 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %15
  %"$array_ptr13" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %15, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr13"
  %"$bounds14" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %15, i32 0, i32 2
  %91 = bitcast [1 x %"$ax.ArrayBounds"]* %14 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %91, %"$ax.ArrayBounds"** %"$bounds14"
  %92 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %90, i16 %80, %"$ax.ArrayWithBound"* %15)
  store i16 %92, i16* @axunit_globalTestIdPos
  %93 = load i16, i16* @axunit_globalSectionPosName
  store i16 %93, i16* @axunit_globalTestIdPos
  %94 = load i16, i16* @axunit_globalSectionPosName
  %95 = add i16 %94, 7
  store i16 %95, i16* @axunit_globalSectionPosName
  br label %bb23

bb22:                                             ; preds = %bb18
  br label %bb23

bb23:                                             ; preds = %bb22, %bb21
  %96 = load i1, i1* @GlobalAssertValue
  %97 = icmp eq i1 true, %96
  br i1 %97, label %bb24, label %bb25

bb24:                                             ; preds = %bb23
  store i8 1, i8* @axunit_Test_1_Result
  br label %bb26

bb25:                                             ; preds = %bb23
  store i8 2, i8* @axunit_Test_1_Result
  br label %bb26

bb26:                                             ; preds = %bb25, %bb24
  br label %bb8

bb27:                                             ; preds = %bb20
  %98 = load %UsingDeserializer, %UsingDeserializer* @axunit_testfixture_instance_default_valuesUsingDeserializer
  store %UsingDeserializer %98, %UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer
  call void @"UsingDeserializer.GetValue_Nested$I@R@UsingDeserializer@this"(%UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer)
  %99 = load i16, i16* @axunit_globalTestIdPos
  %100 = add i16 7, %99
  %101 = load i16, i16* @axunit_globalSectionPosName
  %102 = icmp ne i16 %101, %100
  br i1 %102, label %bb30, label %bb31

bb28:                                             ; preds = %bb20
  br label %bb29

bb29:                                             ; preds = %bb28
  %103 = load i8, i8* @axunit_Test_3_Result
  %104 = icmp eq i8 0, %103
  br i1 %104, label %bb36, label %bb37

bb30:                                             ; preds = %bb27
  %105 = load i16, i16* @axunit_globalSectionPosName
  %106 = load i16, i16* @axunit_globalTestIdPos
  %107 = sub i16 %105, %106
  %108 = sub i16 %107, 4
  %109 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %17
  %"$array_ptr15" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %17, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr15"
  %"$bounds16" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %17, i32 0, i32 2
  %110 = bitcast [1 x %"$ax.ArrayBounds"]* %16 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %110, %"$ax.ArrayBounds"** %"$bounds16"
  %111 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %109, i16 %107, %"$ax.ArrayWithBound"* %17)
  store i16 %111, i16* @axunit_globalTestIdPos
  %112 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %19
  %"$array_ptr17" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr17"
  %"$bounds18" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %19, i32 0, i32 2
  %113 = bitcast [1 x %"$ax.ArrayBounds"]* %18 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %113, %"$ax.ArrayBounds"** %"$bounds18"
  %114 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %112, i16 2, %"$ax.ArrayWithBound"* %19)
  store i16 %114, i16* @axunit_globalTestIdPos
  %115 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %21
  %"$array_ptr19" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %21, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr19"
  %"$bounds20" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %21, i32 0, i32 2
  %116 = bitcast [1 x %"$ax.ArrayBounds"]* %20 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %116, %"$ax.ArrayBounds"** %"$bounds20"
  %117 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %115, i8 1, %"$ax.ArrayWithBound"* %21)
  store i16 %117, i16* @axunit_globalTestIdPos
  %118 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %23
  %"$array_ptr21" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %23, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr21"
  %"$bounds22" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %23, i32 0, i32 2
  %119 = bitcast [1 x %"$ax.ArrayBounds"]* %22 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %119, %"$ax.ArrayBounds"** %"$bounds22"
  %120 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %118, i16 %108, %"$ax.ArrayWithBound"* %23)
  store i16 %120, i16* @axunit_globalTestIdPos
  %121 = load i16, i16* @axunit_globalSectionPosName
  store i16 %121, i16* @axunit_globalTestIdPos
  %122 = load i16, i16* @axunit_globalSectionPosName
  %123 = add i16 %122, 7
  store i16 %123, i16* @axunit_globalSectionPosName
  br label %bb32

bb31:                                             ; preds = %bb27
  br label %bb32

bb32:                                             ; preds = %bb31, %bb30
  %124 = load i1, i1* @GlobalAssertValue
  %125 = icmp eq i1 true, %124
  br i1 %125, label %bb33, label %bb34

bb33:                                             ; preds = %bb32
  store i8 1, i8* @axunit_Test_2_Result
  br label %bb35

bb34:                                             ; preds = %bb32
  store i8 2, i8* @axunit_Test_2_Result
  br label %bb35

bb35:                                             ; preds = %bb34, %bb33
  br label %bb8

bb36:                                             ; preds = %bb29
  %126 = load %UsingDeserializer, %UsingDeserializer* @axunit_testfixture_instance_default_valuesUsingDeserializer
  store %UsingDeserializer %126, %UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer
  call void @"UsingDeserializer.GetValue_Nested_in_Nested$I@R@UsingDeserializer@this"(%UsingDeserializer* @axunit_testfixture_instance_UsingDeserializer)
  %127 = load i16, i16* @axunit_globalTestIdPos
  %128 = add i16 7, %127
  %129 = load i16, i16* @axunit_globalSectionPosName
  %130 = icmp ne i16 %129, %128
  br i1 %130, label %bb39, label %bb40

bb37:                                             ; preds = %bb29
  br label %bb38

bb38:                                             ; preds = %bb37
  br label %bb8

bb39:                                             ; preds = %bb36
  %131 = load i16, i16* @axunit_globalSectionPosName
  %132 = load i16, i16* @axunit_globalTestIdPos
  %133 = sub i16 %131, %132
  %134 = sub i16 %133, 4
  %135 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %25
  %"$array_ptr23" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %25, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr23"
  %"$bounds24" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %25, i32 0, i32 2
  %136 = bitcast [1 x %"$ax.ArrayBounds"]* %24 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %136, %"$ax.ArrayBounds"** %"$bounds24"
  %137 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %135, i16 %133, %"$ax.ArrayWithBound"* %25)
  store i16 %137, i16* @axunit_globalTestIdPos
  %138 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %27
  %"$array_ptr25" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %27, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr25"
  %"$bounds26" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %27, i32 0, i32 2
  %139 = bitcast [1 x %"$ax.ArrayBounds"]* %26 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %139, %"$ax.ArrayBounds"** %"$bounds26"
  %140 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %138, i16 3, %"$ax.ArrayWithBound"* %27)
  store i16 %140, i16* @axunit_globalTestIdPos
  %141 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %29
  %"$array_ptr27" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %29, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr27"
  %"$bounds28" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %29, i32 0, i32 2
  %142 = bitcast [1 x %"$ax.ArrayBounds"]* %28 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %142, %"$ax.ArrayBounds"** %"$bounds28"
  %143 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %141, i8 1, %"$ax.ArrayWithBound"* %29)
  store i16 %143, i16* @axunit_globalTestIdPos
  %144 = load i16, i16* @axunit_globalTestIdPos
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %31
  %"$array_ptr29" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %31, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr29"
  %"$bounds30" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %31, i32 0, i32 2
  %145 = bitcast [1 x %"$ax.ArrayBounds"]* %30 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %145, %"$ax.ArrayBounds"** %"$bounds30"
  %146 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %144, i16 %134, %"$ax.ArrayWithBound"* %31)
  store i16 %146, i16* @axunit_globalTestIdPos
  %147 = load i16, i16* @axunit_globalSectionPosName
  store i16 %147, i16* @axunit_globalTestIdPos
  %148 = load i16, i16* @axunit_globalSectionPosName
  %149 = add i16 %148, 7
  store i16 %149, i16* @axunit_globalSectionPosName
  br label %bb41

bb40:                                             ; preds = %bb36
  br label %bb41

bb41:                                             ; preds = %bb40, %bb39
  %150 = load i1, i1* @GlobalAssertValue
  %151 = icmp eq i1 true, %150
  br i1 %151, label %bb42, label %bb43

bb42:                                             ; preds = %bb41
  store i8 1, i8* @axunit_Test_3_Result
  br label %bb44

bb43:                                             ; preds = %bb41
  store i8 2, i8* @axunit_Test_3_Result
  br label %bb44

bb44:                                             ; preds = %bb43, %bb42
  br label %bb8
}

define void @axunit_TestEnvironmentOB() {
Entry:
  br label %bb1

bb1:                                              ; preds = %Entry
  call void @axunit_TestEnvironment()
  ret void
}

define void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType?I@V@axunit_assertData@assertDataLeft?I@V@axunit_assertData@assertDataRight?I@V@UInt16@lengthOfValueArray"(i1 %assertResult, i16 %assertLocationId, i8 %comparerTypeId, i8 %assertDataType, %"$ax.ArrayWithBound" %assertDataLeft, %"$ax.ArrayWithBound" %assertDataRight, i16 %lengthOfValueArray) {
Entry:
  %assertResult.addr = alloca i1
  %assertLocationId.addr = alloca i16
  %comparerTypeId.addr = alloca i8
  %assertDataType.addr = alloca i8
  %assertDataLeft.addr = alloca %"$ax.ArrayWithBound"
  %assertDataRight.addr = alloca %"$ax.ArrayWithBound"
  %lengthOfValueArray.addr = alloca i16
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %4
  %5 = alloca %"$ax.ArrayWithBound"
  %6 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %6
  %7 = alloca %"$ax.ArrayWithBound"
  %8 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %8
  %9 = alloca %"$ax.ArrayWithBound"
  store i1 %assertResult, i1* %assertResult.addr
  store i16 %assertLocationId, i16* %assertLocationId.addr
  store i8 %comparerTypeId, i8* %comparerTypeId.addr
  store i8 %assertDataType, i8* %assertDataType.addr
  store %"$ax.ArrayWithBound" %assertDataLeft, %"$ax.ArrayWithBound"* %assertDataLeft.addr
  store %"$ax.ArrayWithBound" %assertDataRight, %"$ax.ArrayWithBound"* %assertDataRight.addr
  store i16 %lengthOfValueArray, i16* %lengthOfValueArray.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %10 = load i1, i1* %assertResult.addr
  %11 = xor i1 %10, true
  %12 = load i16, i16* %lengthOfValueArray.addr
  %13 = add i16 4, %12
  %14 = load i16, i16* %lengthOfValueArray.addr
  %15 = add i16 %13, %14
  %16 = load i16, i16* @axunit_globalSectionPosName
  %17 = add i16 %15, %16
  %18 = load i16, i16* @axunit_assertionData_Size
  %19 = icmp uge i16 %18, %17
  br i1 %11, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  br i1 %19, label %bb5, label %bb6

bb3:                                              ; preds = %bb1
  br label %bb4

bb4:                                              ; preds = %bb3, %bb7
  ret void

bb5:                                              ; preds = %bb2
  %20 = load i16, i16* @axunit_globalSectionPosName
  %21 = load i16, i16* %assertLocationId.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr"
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2
  %22 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %22, %"$ax.ArrayBounds"** %"$bounds"
  %23 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %20, i16 %21, %"$ax.ArrayWithBound"* %1)
  store i16 %23, i16* @axunit_globalSectionPosName
  %24 = load i16, i16* @axunit_globalSectionPosName
  %25 = load i8, i8* %comparerTypeId.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3
  %"$array_ptr1" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr1"
  %"$bounds2" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2
  %26 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %26, %"$ax.ArrayBounds"** %"$bounds2"
  %27 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %24, i8 %25, %"$ax.ArrayWithBound"* %3)
  store i16 %27, i16* @axunit_globalSectionPosName
  %28 = load i16, i16* @axunit_globalSectionPosName
  %29 = load i8, i8* %assertDataType.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %5
  %"$array_ptr3" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr3"
  %"$bounds4" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 2
  %30 = bitcast [1 x %"$ax.ArrayBounds"]* %4 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %30, %"$ax.ArrayBounds"** %"$bounds4"
  %31 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %28, i8 %29, %"$ax.ArrayWithBound"* %5)
  store i16 %31, i16* @axunit_globalSectionPosName
  %32 = load i16, i16* @axunit_globalSectionPosName
  %33 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %assertDataLeft.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %7
  %"$array_ptr5" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %7, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr5"
  %"$bounds6" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %7, i32 0, i32 2
  %34 = bitcast [1 x %"$ax.ArrayBounds"]* %6 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %34, %"$ax.ArrayBounds"** %"$bounds6"
  %35 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %32, %"$ax.ArrayWithBound" %33, %"$ax.ArrayWithBound"* %7)
  store i16 %35, i16* @axunit_globalSectionPosName
  %36 = load i16, i16* @axunit_globalSectionPosName
  %37 = load %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %assertDataRight.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %9
  %"$array_ptr7" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %9, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr7"
  %"$bounds8" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %9, i32 0, i32 2
  %38 = bitcast [1 x %"$ax.ArrayBounds"]* %8 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %38, %"$ax.ArrayBounds"** %"$bounds8"
  %39 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %36, %"$ax.ArrayWithBound" %37, %"$ax.ArrayWithBound"* %9)
  store i16 %39, i16* @axunit_globalSectionPosName
  br label %bb7

bb6:                                              ; preds = %bb2
  br label %bb7

bb7:                                              ; preds = %bb6, %bb5
  br label %bb4
}

define void @"axunit_AssertLocationWriter$I@V@Int1@assertResult?I@V@UInt16@assertLocationId?I@V@Byte8@comparerTypeId?I@V@Byte8@assertDataType"(i1 %assertResult, i16 %assertLocationId, i8 %comparerTypeId, i8 %assertDataType) {
Entry:
  %assertResult.addr = alloca i1
  %assertLocationId.addr = alloca i16
  %comparerTypeId.addr = alloca i8
  %assertDataType.addr = alloca i8
  %0 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %0
  %1 = alloca %"$ax.ArrayWithBound"
  %2 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %2
  %3 = alloca %"$ax.ArrayWithBound"
  %4 = alloca [1 x %"$ax.ArrayBounds"]
  store [1 x %"$ax.ArrayBounds"] [%"$ax.ArrayBounds" { i32 0, i32 299, i32 1 }], [1 x %"$ax.ArrayBounds"]* %4
  %5 = alloca %"$ax.ArrayWithBound"
  store i1 %assertResult, i1* %assertResult.addr
  store i16 %assertLocationId, i16* %assertLocationId.addr
  store i8 %comparerTypeId, i8* %comparerTypeId.addr
  store i8 %assertDataType, i8* %assertDataType.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %6 = load i1, i1* %assertResult.addr
  %7 = xor i1 %6, true
  %8 = load i16, i16* @axunit_assertionData_Size
  %9 = icmp uge i16 %8, 4
  br i1 %7, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  br i1 %9, label %bb5, label %bb6

bb3:                                              ; preds = %bb1
  br label %bb4

bb4:                                              ; preds = %bb3, %bb7
  ret void

bb5:                                              ; preds = %bb2
  %10 = load i16, i16* @axunit_globalSectionPosName
  %11 = load i16, i16* %assertLocationId.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %1
  %"$array_ptr" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr"
  %"$bounds" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %1, i32 0, i32 2
  %12 = bitcast [1 x %"$ax.ArrayBounds"]* %0 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %12, %"$ax.ArrayBounds"** %"$bounds"
  %13 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %10, i16 %11, %"$ax.ArrayWithBound"* %1)
  store i16 %13, i16* @axunit_globalSectionPosName
  %14 = load i16, i16* @axunit_globalSectionPosName
  %15 = load i8, i8* %comparerTypeId.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %3
  %"$array_ptr1" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr1"
  %"$bounds2" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %3, i32 0, i32 2
  %16 = bitcast [1 x %"$ax.ArrayBounds"]* %2 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %16, %"$ax.ArrayBounds"** %"$bounds2"
  %17 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %14, i8 %15, %"$ax.ArrayWithBound"* %3)
  store i16 %17, i16* @axunit_globalSectionPosName
  %18 = load i16, i16* @axunit_globalSectionPosName
  %19 = load i8, i8* %assertDataType.addr
  store %"$ax.ArrayWithBound" { i8* null, i32 1, %"$ax.ArrayBounds"* null }, %"$ax.ArrayWithBound"* %5
  %"$array_ptr3" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 0
  store i8* getelementptr inbounds ([300 x i8], [300 x i8]* @axunit_assertionData, i32 0, i32 0), i8** %"$array_ptr3"
  %"$bounds4" = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %5, i32 0, i32 2
  %20 = bitcast [1 x %"$ax.ArrayBounds"]* %4 to %"$ax.ArrayBounds"*
  store %"$ax.ArrayBounds"* %20, %"$ax.ArrayBounds"** %"$bounds4"
  %21 = call i16 @"AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer"(i16 %18, i8 %19, %"$ax.ArrayWithBound"* %5)
  store i16 %21, i16* @axunit_globalSectionPosName
  br label %bb7

bb6:                                              ; preds = %bb2
  br label %bb7

bb7:                                              ; preds = %bb6, %bb5
  br label %bb4
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2493 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.AbstractJsonElement*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.AbstractJsonElement* null, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2494
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2494
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2494
  %3 = icmp ne i16 %2, 1, !dbg !2494
  br i1 %3, label %bb2, label %bb3, !dbg !2494

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2494
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2494
  %6 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %5, i32 0, i32 1, !dbg !2494
  %7 = ptrtoint %Simatic.Ax.Json.AbstractJsonElement* %5 to i64, !dbg !2494
  %8 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %6 to i64, !dbg !2494
  %9 = sub i64 %7, %8, !dbg !2494
  %10 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2494
  %11 = getelementptr i8, i8* %10, i64 %9, !dbg !2494
  %12 = bitcast i8* %11 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2494
  store %Simatic.Ax.Json.AbstractJsonElement* %12, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2494
  br label %bb4, !dbg !2494

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2494

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2494
  %13 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2494
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %"auto_deref_$castedItf", %Simatic.Ax.Json.IJsonElement* %13), !dbg !2494
  ret void, !dbg !2494
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2495 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.AbstractJsonElement*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.AbstractJsonElement* null, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2498
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2498
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2498
  %3 = icmp ne i16 %2, 1, !dbg !2498
  br i1 %3, label %bb2, label %bb3, !dbg !2498

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2498
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2498
  %6 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %5, i32 0, i32 1, !dbg !2498
  %7 = ptrtoint %Simatic.Ax.Json.AbstractJsonElement* %5 to i64, !dbg !2498
  %8 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %6 to i64, !dbg !2498
  %9 = sub i64 %7, %8, !dbg !2498
  %10 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2498
  %11 = getelementptr i8, i8* %10, i64 %9, !dbg !2498
  %12 = bitcast i8* %11 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2498
  store %Simatic.Ax.Json.AbstractJsonElement* %12, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2498
  br label %bb4, !dbg !2498

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2498

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2498
  %13 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %"auto_deref_$castedItf"), !dbg !2498
  store %Simatic.Ax.Json.IJsonElementMuteable* %13, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2498
  %14 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2498
  ret %Simatic.Ax.Json.IJsonElementMuteable* %14, !dbg !2498
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2499 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.AbstractJsonElement*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.AbstractJsonElement* null, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2502
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2502
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2502
  %3 = icmp ne i16 %2, 1, !dbg !2502
  br i1 %3, label %bb2, label %bb3, !dbg !2502

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2502
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2502
  %6 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %5, i32 0, i32 1, !dbg !2502
  %7 = ptrtoint %Simatic.Ax.Json.AbstractJsonElement* %5 to i64, !dbg !2502
  %8 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %6 to i64, !dbg !2502
  %9 = sub i64 %7, %8, !dbg !2502
  %10 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2502
  %11 = getelementptr i8, i8* %10, i64 %9, !dbg !2502
  %12 = bitcast i8* %11 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2502
  store %Simatic.Ax.Json.AbstractJsonElement* %12, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2502
  br label %bb4, !dbg !2502

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2502

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2502
  %13 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %"auto_deref_$castedItf"), !dbg !2502
  store i1 %13, i1* %HasNext.ret, !dbg !2502
  %14 = load i1, i1* %HasNext.ret, !dbg !2502
  ret i1 %14, !dbg !2502
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2503 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.AbstractJsonElement*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.AbstractJsonElement* null, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2504
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2504
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2504
  %3 = icmp ne i16 %2, 1, !dbg !2504
  br i1 %3, label %bb2, label %bb3, !dbg !2504

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2504
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2504
  %6 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %5, i32 0, i32 2, !dbg !2504
  %7 = ptrtoint %Simatic.Ax.Json.AbstractJsonElement* %5 to i64, !dbg !2504
  %8 = ptrtoint %Simatic.Ax.Json.IJsonElement** %6 to i64, !dbg !2504
  %9 = sub i64 %7, %8, !dbg !2504
  %10 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2504
  %11 = getelementptr i8, i8* %10, i64 %9, !dbg !2504
  %12 = bitcast i8* %11 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2504
  store %Simatic.Ax.Json.AbstractJsonElement* %12, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2504
  br label %bb4, !dbg !2504

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2504

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2504
  %13 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2504
  %14 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.Serialize$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.AbstractJsonElement* %"auto_deref_$castedItf", %Simatic.Ax.Json.JsonDocument* %13), !dbg !2504
  store i1 %14, i1* %Serialize.ret, !dbg !2504
  %15 = load i1, i1* %Serialize.ret, !dbg !2504
  ret i1 %15, !dbg !2504
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2505 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.AbstractJsonElement*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.AbstractJsonElement* null, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2508
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2508
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2508
  %4 = icmp ne i16 %3, 1, !dbg !2508
  br i1 %4, label %bb2, label %bb3, !dbg !2508

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2508
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2508
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 2, !dbg !2508
  %8 = ptrtoint %Simatic.Ax.Json.AbstractJsonElement* %6 to i64, !dbg !2508
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElement** %7 to i64, !dbg !2508
  %10 = sub i64 %8, %9, !dbg !2508
  %11 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2508
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2508
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2508
  store %Simatic.Ax.Json.AbstractJsonElement* %13, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2508
  br label %bb4, !dbg !2508

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2508

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.AbstractJsonElement*, %Simatic.Ax.Json.AbstractJsonElement** %"$castedItf", !dbg !2508
  %14 = call %STRING.0 @"Simatic.Ax.Json.AbstractJsonElement.ToString$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %"auto_deref_$castedItf"), !dbg !2508
  store %STRING.0 %14, %STRING.0* %0, !dbg !2508
  %15 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2508
  %16 = bitcast %STRING.0* %0 to i8*, !dbg !2508
  call void @"$ax.AssignST_String"(i8* %15, i8* %16), !dbg !2508
  %17 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2508
  ret %STRING.0 %17, !dbg !2508
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2509 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.BaseJsonNumber*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.BaseJsonNumber* null, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2510
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2510
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2510
  %3 = icmp ne i16 %2, 1, !dbg !2510
  br i1 %3, label %bb2, label %bb3, !dbg !2510

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2510
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2510
  %6 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %5, i32 0, i32 0, !dbg !2510
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2510
  %8 = ptrtoint %Simatic.Ax.Json.BaseJsonNumber* %5 to i64, !dbg !2510
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2510
  %10 = sub i64 %8, %9, !dbg !2510
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2510
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2510
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2510
  store %Simatic.Ax.Json.BaseJsonNumber* %13, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2510
  br label %bb4, !dbg !2510

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2510

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2510
  %14 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2510
  %15 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2510
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %14, %Simatic.Ax.Json.IJsonElement* %15), !dbg !2510
  ret void, !dbg !2510
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2511 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.BaseJsonNumber*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.BaseJsonNumber* null, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2512
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2512
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2512
  %3 = icmp ne i16 %2, 1, !dbg !2512
  br i1 %3, label %bb2, label %bb3, !dbg !2512

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2512
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2512
  %6 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %5, i32 0, i32 0, !dbg !2512
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2512
  %8 = ptrtoint %Simatic.Ax.Json.BaseJsonNumber* %5 to i64, !dbg !2512
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2512
  %10 = sub i64 %8, %9, !dbg !2512
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2512
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2512
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2512
  store %Simatic.Ax.Json.BaseJsonNumber* %13, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2512
  br label %bb4, !dbg !2512

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2512

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2512
  %14 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2512
  %15 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2512
  store %Simatic.Ax.Json.IJsonElementMuteable* %15, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2512
  %16 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2512
  ret %Simatic.Ax.Json.IJsonElementMuteable* %16, !dbg !2512
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2513 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.BaseJsonNumber*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.BaseJsonNumber* null, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2514
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2514
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2514
  %3 = icmp ne i16 %2, 1, !dbg !2514
  br i1 %3, label %bb2, label %bb3, !dbg !2514

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2514
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2514
  %6 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %5, i32 0, i32 0, !dbg !2514
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2514
  %8 = ptrtoint %Simatic.Ax.Json.BaseJsonNumber* %5 to i64, !dbg !2514
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2514
  %10 = sub i64 %8, %9, !dbg !2514
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2514
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2514
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2514
  store %Simatic.Ax.Json.BaseJsonNumber* %13, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2514
  br label %bb4, !dbg !2514

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2514

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2514
  %14 = bitcast %Simatic.Ax.Json.BaseJsonNumber* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2514
  %15 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2514
  store i1 %15, i1* %HasNext.ret, !dbg !2514
  %16 = load i1, i1* %HasNext.ret, !dbg !2514
  ret i1 %16, !dbg !2514
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2515 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.BaseJsonNumber*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.BaseJsonNumber* null, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2516
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2516
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2516
  %3 = icmp ne i16 %2, 1, !dbg !2516
  br i1 %3, label %bb2, label %bb3, !dbg !2516

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2516
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2516
  %6 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %5, i32 0, i32 0, !dbg !2516
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 2, !dbg !2516
  %8 = ptrtoint %Simatic.Ax.Json.BaseJsonNumber* %5 to i64, !dbg !2516
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElement** %7 to i64, !dbg !2516
  %10 = sub i64 %8, %9, !dbg !2516
  %11 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2516
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2516
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2516
  store %Simatic.Ax.Json.BaseJsonNumber* %13, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2516
  br label %bb4, !dbg !2516

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2516

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2516
  %14 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2516
  %15 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %"auto_deref_$castedItf", %Simatic.Ax.Json.JsonDocument* %14), !dbg !2516
  store i1 %15, i1* %Serialize.ret, !dbg !2516
  %16 = load i1, i1* %Serialize.ret, !dbg !2516
  ret i1 %16, !dbg !2516
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2517 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.BaseJsonNumber*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.BaseJsonNumber* null, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2518
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2518
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2518
  %4 = icmp ne i16 %3, 1, !dbg !2518
  br i1 %4, label %bb2, label %bb3, !dbg !2518

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2518
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2518
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2518
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2518
  %9 = ptrtoint %Simatic.Ax.Json.BaseJsonNumber* %6 to i64, !dbg !2518
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2518
  %11 = sub i64 %9, %10, !dbg !2518
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2518
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2518
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2518
  store %Simatic.Ax.Json.BaseJsonNumber* %14, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2518
  br label %bb4, !dbg !2518

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2518

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.BaseJsonNumber*, %Simatic.Ax.Json.BaseJsonNumber** %"$castedItf", !dbg !2518
  %15 = call %STRING.0 @"Simatic.Ax.Json.BaseJsonNumber.ToString$I@R@Simatic.Ax.Json.BaseJsonNumber@this"(%Simatic.Ax.Json.BaseJsonNumber* %"auto_deref_$castedItf"), !dbg !2518
  store %STRING.0 %15, %STRING.0* %0, !dbg !2518
  %16 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2518
  %17 = bitcast %STRING.0* %0 to i8*, !dbg !2518
  call void @"$ax.AssignST_String"(i8* %16, i8* %17), !dbg !2518
  %18 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2518
  ret %STRING.0 %18, !dbg !2518
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2519 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonBoolean*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonBoolean* null, %Simatic.Ax.Json.JsonBoolean** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2520
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2520
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2520
  %3 = icmp ne i16 %2, 1, !dbg !2520
  br i1 %3, label %bb2, label %bb3, !dbg !2520

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2520
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2520
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %5, i32 0, i32 0, !dbg !2520
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2520
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2520
  %9 = ptrtoint %Simatic.Ax.Json.JsonBoolean* %5 to i64, !dbg !2520
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2520
  %11 = sub i64 %9, %10, !dbg !2520
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2520
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2520
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2520
  store %Simatic.Ax.Json.JsonBoolean* %14, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2520
  br label %bb4, !dbg !2520

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2520

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2520
  %15 = bitcast %Simatic.Ax.Json.JsonBoolean* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2520
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2520
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2520
  ret void, !dbg !2520
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2521 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonBoolean*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonBoolean* null, %Simatic.Ax.Json.JsonBoolean** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2522
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2522
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2522
  %3 = icmp ne i16 %2, 1, !dbg !2522
  br i1 %3, label %bb2, label %bb3, !dbg !2522

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2522
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2522
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %5, i32 0, i32 0, !dbg !2522
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2522
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2522
  %9 = ptrtoint %Simatic.Ax.Json.JsonBoolean* %5 to i64, !dbg !2522
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2522
  %11 = sub i64 %9, %10, !dbg !2522
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2522
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2522
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2522
  store %Simatic.Ax.Json.JsonBoolean* %14, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2522
  br label %bb4, !dbg !2522

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2522

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2522
  %15 = bitcast %Simatic.Ax.Json.JsonBoolean* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2522
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2522
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2522
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2522
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2522
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2523 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonBoolean*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonBoolean* null, %Simatic.Ax.Json.JsonBoolean** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2524
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2524
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2524
  %3 = icmp ne i16 %2, 1, !dbg !2524
  br i1 %3, label %bb2, label %bb3, !dbg !2524

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2524
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2524
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %5, i32 0, i32 0, !dbg !2524
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2524
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2524
  %9 = ptrtoint %Simatic.Ax.Json.JsonBoolean* %5 to i64, !dbg !2524
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2524
  %11 = sub i64 %9, %10, !dbg !2524
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2524
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2524
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2524
  store %Simatic.Ax.Json.JsonBoolean* %14, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2524
  br label %bb4, !dbg !2524

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2524

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2524
  %15 = bitcast %Simatic.Ax.Json.JsonBoolean* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2524
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2524
  store i1 %16, i1* %HasNext.ret, !dbg !2524
  %17 = load i1, i1* %HasNext.ret, !dbg !2524
  ret i1 %17, !dbg !2524
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2525 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonBoolean*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonBoolean* null, %Simatic.Ax.Json.JsonBoolean** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2526
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2526
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2526
  %3 = icmp ne i16 %2, 1, !dbg !2526
  br i1 %3, label %bb2, label %bb3, !dbg !2526

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2526
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2526
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %5, i32 0, i32 0, !dbg !2526
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2526
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2526
  %9 = ptrtoint %Simatic.Ax.Json.JsonBoolean* %5 to i64, !dbg !2526
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2526
  %11 = sub i64 %9, %10, !dbg !2526
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2526
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2526
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2526
  store %Simatic.Ax.Json.JsonBoolean* %14, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2526
  br label %bb4, !dbg !2526

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2526

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2526
  %15 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2526
  %16 = call i1 @"Simatic.Ax.Json.JsonBoolean.Serialize$I@R@Simatic.Ax.Json.JsonBoolean@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonBoolean* %"auto_deref_$castedItf", %Simatic.Ax.Json.JsonDocument* %15), !dbg !2526
  store i1 %16, i1* %Serialize.ret, !dbg !2526
  %17 = load i1, i1* %Serialize.ret, !dbg !2526
  ret i1 %17, !dbg !2526
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2527 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonBoolean*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonBoolean* null, %Simatic.Ax.Json.JsonBoolean** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2528
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2528
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2528
  %4 = icmp ne i16 %3, 1, !dbg !2528
  br i1 %4, label %bb2, label %bb3, !dbg !2528

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2528
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2528
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonBoolean, %Simatic.Ax.Json.JsonBoolean* %6, i32 0, i32 0, !dbg !2528
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2528
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2528
  %10 = ptrtoint %Simatic.Ax.Json.JsonBoolean* %6 to i64, !dbg !2528
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2528
  %12 = sub i64 %10, %11, !dbg !2528
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2528
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2528
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonBoolean*, !dbg !2528
  store %Simatic.Ax.Json.JsonBoolean* %15, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2528
  br label %bb4, !dbg !2528

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2528

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonBoolean*, %Simatic.Ax.Json.JsonBoolean** %"$castedItf", !dbg !2528
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonBoolean.ToString$I@R@Simatic.Ax.Json.JsonBoolean@this"(%Simatic.Ax.Json.JsonBoolean* %"auto_deref_$castedItf"), !dbg !2528
  store %STRING.0 %16, %STRING.0* %0, !dbg !2528
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2528
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2528
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2528
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2528
  ret %STRING.0 %19, !dbg !2528
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2529 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonString*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonString* null, %Simatic.Ax.Json.JsonString** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2530
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2530
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2530
  %3 = icmp ne i16 %2, 1, !dbg !2530
  br i1 %3, label %bb2, label %bb3, !dbg !2530

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2530
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonString*, !dbg !2530
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %5, i32 0, i32 0, !dbg !2530
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2530
  %8 = ptrtoint %Simatic.Ax.Json.JsonString* %5 to i64, !dbg !2530
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2530
  %10 = sub i64 %8, %9, !dbg !2530
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2530
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2530
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonString*, !dbg !2530
  store %Simatic.Ax.Json.JsonString* %13, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2530
  br label %bb4, !dbg !2530

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2530

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2530
  %14 = bitcast %Simatic.Ax.Json.JsonString* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2530
  %15 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2530
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %14, %Simatic.Ax.Json.IJsonElement* %15), !dbg !2530
  ret void, !dbg !2530
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2531 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonString*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonString* null, %Simatic.Ax.Json.JsonString** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2532
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2532
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2532
  %3 = icmp ne i16 %2, 1, !dbg !2532
  br i1 %3, label %bb2, label %bb3, !dbg !2532

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2532
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonString*, !dbg !2532
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %5, i32 0, i32 0, !dbg !2532
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2532
  %8 = ptrtoint %Simatic.Ax.Json.JsonString* %5 to i64, !dbg !2532
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2532
  %10 = sub i64 %8, %9, !dbg !2532
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2532
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2532
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonString*, !dbg !2532
  store %Simatic.Ax.Json.JsonString* %13, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2532
  br label %bb4, !dbg !2532

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2532

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2532
  %14 = bitcast %Simatic.Ax.Json.JsonString* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2532
  %15 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2532
  store %Simatic.Ax.Json.IJsonElementMuteable* %15, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2532
  %16 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2532
  ret %Simatic.Ax.Json.IJsonElementMuteable* %16, !dbg !2532
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2533 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonString*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonString* null, %Simatic.Ax.Json.JsonString** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2534
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2534
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2534
  %3 = icmp ne i16 %2, 1, !dbg !2534
  br i1 %3, label %bb2, label %bb3, !dbg !2534

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2534
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonString*, !dbg !2534
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %5, i32 0, i32 0, !dbg !2534
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2534
  %8 = ptrtoint %Simatic.Ax.Json.JsonString* %5 to i64, !dbg !2534
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2534
  %10 = sub i64 %8, %9, !dbg !2534
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2534
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2534
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonString*, !dbg !2534
  store %Simatic.Ax.Json.JsonString* %13, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2534
  br label %bb4, !dbg !2534

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2534

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2534
  %14 = bitcast %Simatic.Ax.Json.JsonString* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2534
  %15 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2534
  store i1 %15, i1* %HasNext.ret, !dbg !2534
  %16 = load i1, i1* %HasNext.ret, !dbg !2534
  ret i1 %16, !dbg !2534
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2535 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonString*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonString* null, %Simatic.Ax.Json.JsonString** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2536
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2536
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2536
  %3 = icmp ne i16 %2, 1, !dbg !2536
  br i1 %3, label %bb2, label %bb3, !dbg !2536

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2536
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonString*, !dbg !2536
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %5, i32 0, i32 0, !dbg !2536
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 2, !dbg !2536
  %8 = ptrtoint %Simatic.Ax.Json.JsonString* %5 to i64, !dbg !2536
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElement** %7 to i64, !dbg !2536
  %10 = sub i64 %8, %9, !dbg !2536
  %11 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2536
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2536
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonString*, !dbg !2536
  store %Simatic.Ax.Json.JsonString* %13, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2536
  br label %bb4, !dbg !2536

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2536

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2536
  %14 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2536
  %15 = call i1 @"Simatic.Ax.Json.JsonString.Serialize$I@R@Simatic.Ax.Json.JsonString@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonString* %"auto_deref_$castedItf", %Simatic.Ax.Json.JsonDocument* %14), !dbg !2536
  store i1 %15, i1* %Serialize.ret, !dbg !2536
  %16 = load i1, i1* %Serialize.ret, !dbg !2536
  ret i1 %16, !dbg !2536
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2537 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonString*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonString* null, %Simatic.Ax.Json.JsonString** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2538
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2538
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2538
  %4 = icmp ne i16 %3, 1, !dbg !2538
  br i1 %4, label %bb2, label %bb3, !dbg !2538

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2538
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonString*, !dbg !2538
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonString, %Simatic.Ax.Json.JsonString* %6, i32 0, i32 0, !dbg !2538
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2538
  %9 = ptrtoint %Simatic.Ax.Json.JsonString* %6 to i64, !dbg !2538
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2538
  %11 = sub i64 %9, %10, !dbg !2538
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2538
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2538
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonString*, !dbg !2538
  store %Simatic.Ax.Json.JsonString* %14, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2538
  br label %bb4, !dbg !2538

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2538

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonString*, %Simatic.Ax.Json.JsonString** %"$castedItf", !dbg !2538
  %15 = call %STRING.0 @"Simatic.Ax.Json.JsonString.ToString$I@R@Simatic.Ax.Json.JsonString@this"(%Simatic.Ax.Json.JsonString* %"auto_deref_$castedItf"), !dbg !2538
  store %STRING.0 %15, %STRING.0* %0, !dbg !2538
  %16 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2538
  %17 = bitcast %STRING.0* %0 to i8*, !dbg !2538
  call void @"$ax.AssignST_String"(i8* %16, i8* %17), !dbg !2538
  %18 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2538
  ret %STRING.0 %18, !dbg !2538
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2539 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonDInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonDInt* null, %Simatic.Ax.Json.JsonDInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2540
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2540
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2540
  %3 = icmp ne i16 %2, 1, !dbg !2540
  br i1 %3, label %bb2, label %bb3, !dbg !2540

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2540
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonDInt*, !dbg !2540
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %5, i32 0, i32 0, !dbg !2540
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2540
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2540
  %9 = ptrtoint %Simatic.Ax.Json.JsonDInt* %5 to i64, !dbg !2540
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2540
  %11 = sub i64 %9, %10, !dbg !2540
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2540
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2540
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonDInt*, !dbg !2540
  store %Simatic.Ax.Json.JsonDInt* %14, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2540
  br label %bb4, !dbg !2540

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2540

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2540
  %15 = bitcast %Simatic.Ax.Json.JsonDInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2540
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2540
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2540
  ret void, !dbg !2540
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2541 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonDInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonDInt* null, %Simatic.Ax.Json.JsonDInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2542
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2542
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2542
  %3 = icmp ne i16 %2, 1, !dbg !2542
  br i1 %3, label %bb2, label %bb3, !dbg !2542

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2542
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonDInt*, !dbg !2542
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %5, i32 0, i32 0, !dbg !2542
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2542
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2542
  %9 = ptrtoint %Simatic.Ax.Json.JsonDInt* %5 to i64, !dbg !2542
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2542
  %11 = sub i64 %9, %10, !dbg !2542
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2542
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2542
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonDInt*, !dbg !2542
  store %Simatic.Ax.Json.JsonDInt* %14, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2542
  br label %bb4, !dbg !2542

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2542

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2542
  %15 = bitcast %Simatic.Ax.Json.JsonDInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2542
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2542
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2542
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2542
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2542
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2543 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonDInt*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonDInt* null, %Simatic.Ax.Json.JsonDInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2544
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2544
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2544
  %3 = icmp ne i16 %2, 1, !dbg !2544
  br i1 %3, label %bb2, label %bb3, !dbg !2544

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2544
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonDInt*, !dbg !2544
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %5, i32 0, i32 0, !dbg !2544
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2544
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2544
  %9 = ptrtoint %Simatic.Ax.Json.JsonDInt* %5 to i64, !dbg !2544
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2544
  %11 = sub i64 %9, %10, !dbg !2544
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2544
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2544
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonDInt*, !dbg !2544
  store %Simatic.Ax.Json.JsonDInt* %14, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2544
  br label %bb4, !dbg !2544

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2544

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2544
  %15 = bitcast %Simatic.Ax.Json.JsonDInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2544
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2544
  store i1 %16, i1* %HasNext.ret, !dbg !2544
  %17 = load i1, i1* %HasNext.ret, !dbg !2544
  ret i1 %17, !dbg !2544
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2545 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonDInt*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonDInt* null, %Simatic.Ax.Json.JsonDInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2546
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2546
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2546
  %3 = icmp ne i16 %2, 1, !dbg !2546
  br i1 %3, label %bb2, label %bb3, !dbg !2546

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2546
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonDInt*, !dbg !2546
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %5, i32 0, i32 0, !dbg !2546
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2546
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2546
  %9 = ptrtoint %Simatic.Ax.Json.JsonDInt* %5 to i64, !dbg !2546
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2546
  %11 = sub i64 %9, %10, !dbg !2546
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2546
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2546
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonDInt*, !dbg !2546
  store %Simatic.Ax.Json.JsonDInt* %14, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2546
  br label %bb4, !dbg !2546

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2546

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2546
  %15 = bitcast %Simatic.Ax.Json.JsonDInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2546
  %16 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2546
  %17 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %15, %Simatic.Ax.Json.JsonDocument* %16), !dbg !2546
  store i1 %17, i1* %Serialize.ret, !dbg !2546
  %18 = load i1, i1* %Serialize.ret, !dbg !2546
  ret i1 %18, !dbg !2546
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2547 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonDInt*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDInt* null, %Simatic.Ax.Json.JsonDInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2548
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2548
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2548
  %4 = icmp ne i16 %3, 1, !dbg !2548
  br i1 %4, label %bb2, label %bb3, !dbg !2548

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2548
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonDInt*, !dbg !2548
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonDInt, %Simatic.Ax.Json.JsonDInt* %6, i32 0, i32 0, !dbg !2548
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2548
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2548
  %10 = ptrtoint %Simatic.Ax.Json.JsonDInt* %6 to i64, !dbg !2548
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2548
  %12 = sub i64 %10, %11, !dbg !2548
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2548
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2548
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonDInt*, !dbg !2548
  store %Simatic.Ax.Json.JsonDInt* %15, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2548
  br label %bb4, !dbg !2548

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2548

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonDInt*, %Simatic.Ax.Json.JsonDInt** %"$castedItf", !dbg !2548
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonDInt.ToString$I@R@Simatic.Ax.Json.JsonDInt@this"(%Simatic.Ax.Json.JsonDInt* %"auto_deref_$castedItf"), !dbg !2548
  store %STRING.0 %16, %STRING.0* %0, !dbg !2548
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2548
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2548
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2548
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2548
  ret %STRING.0 %19, !dbg !2548
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2549 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonInt* null, %Simatic.Ax.Json.JsonInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2550
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2550
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2550
  %3 = icmp ne i16 %2, 1, !dbg !2550
  br i1 %3, label %bb2, label %bb3, !dbg !2550

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2550
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonInt*, !dbg !2550
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %5, i32 0, i32 0, !dbg !2550
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2550
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2550
  %9 = ptrtoint %Simatic.Ax.Json.JsonInt* %5 to i64, !dbg !2550
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2550
  %11 = sub i64 %9, %10, !dbg !2550
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2550
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2550
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonInt*, !dbg !2550
  store %Simatic.Ax.Json.JsonInt* %14, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2550
  br label %bb4, !dbg !2550

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2550

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2550
  %15 = bitcast %Simatic.Ax.Json.JsonInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2550
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2550
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2550
  ret void, !dbg !2550
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2551 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonInt* null, %Simatic.Ax.Json.JsonInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2552
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2552
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2552
  %3 = icmp ne i16 %2, 1, !dbg !2552
  br i1 %3, label %bb2, label %bb3, !dbg !2552

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2552
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonInt*, !dbg !2552
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %5, i32 0, i32 0, !dbg !2552
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2552
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2552
  %9 = ptrtoint %Simatic.Ax.Json.JsonInt* %5 to i64, !dbg !2552
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2552
  %11 = sub i64 %9, %10, !dbg !2552
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2552
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2552
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonInt*, !dbg !2552
  store %Simatic.Ax.Json.JsonInt* %14, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2552
  br label %bb4, !dbg !2552

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2552

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2552
  %15 = bitcast %Simatic.Ax.Json.JsonInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2552
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2552
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2552
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2552
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2552
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2553 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonInt*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonInt* null, %Simatic.Ax.Json.JsonInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2554
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2554
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2554
  %3 = icmp ne i16 %2, 1, !dbg !2554
  br i1 %3, label %bb2, label %bb3, !dbg !2554

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2554
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonInt*, !dbg !2554
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %5, i32 0, i32 0, !dbg !2554
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2554
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2554
  %9 = ptrtoint %Simatic.Ax.Json.JsonInt* %5 to i64, !dbg !2554
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2554
  %11 = sub i64 %9, %10, !dbg !2554
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2554
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2554
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonInt*, !dbg !2554
  store %Simatic.Ax.Json.JsonInt* %14, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2554
  br label %bb4, !dbg !2554

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2554

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2554
  %15 = bitcast %Simatic.Ax.Json.JsonInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2554
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2554
  store i1 %16, i1* %HasNext.ret, !dbg !2554
  %17 = load i1, i1* %HasNext.ret, !dbg !2554
  ret i1 %17, !dbg !2554
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2555 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonInt*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonInt* null, %Simatic.Ax.Json.JsonInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2556
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2556
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2556
  %3 = icmp ne i16 %2, 1, !dbg !2556
  br i1 %3, label %bb2, label %bb3, !dbg !2556

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2556
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonInt*, !dbg !2556
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %5, i32 0, i32 0, !dbg !2556
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2556
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2556
  %9 = ptrtoint %Simatic.Ax.Json.JsonInt* %5 to i64, !dbg !2556
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2556
  %11 = sub i64 %9, %10, !dbg !2556
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2556
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2556
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonInt*, !dbg !2556
  store %Simatic.Ax.Json.JsonInt* %14, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2556
  br label %bb4, !dbg !2556

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2556

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2556
  %15 = bitcast %Simatic.Ax.Json.JsonInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2556
  %16 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2556
  %17 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %15, %Simatic.Ax.Json.JsonDocument* %16), !dbg !2556
  store i1 %17, i1* %Serialize.ret, !dbg !2556
  %18 = load i1, i1* %Serialize.ret, !dbg !2556
  ret i1 %18, !dbg !2556
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2557 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonInt*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonInt* null, %Simatic.Ax.Json.JsonInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2558
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2558
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2558
  %4 = icmp ne i16 %3, 1, !dbg !2558
  br i1 %4, label %bb2, label %bb3, !dbg !2558

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2558
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonInt*, !dbg !2558
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonInt, %Simatic.Ax.Json.JsonInt* %6, i32 0, i32 0, !dbg !2558
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2558
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2558
  %10 = ptrtoint %Simatic.Ax.Json.JsonInt* %6 to i64, !dbg !2558
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2558
  %12 = sub i64 %10, %11, !dbg !2558
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2558
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2558
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonInt*, !dbg !2558
  store %Simatic.Ax.Json.JsonInt* %15, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2558
  br label %bb4, !dbg !2558

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2558

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonInt*, %Simatic.Ax.Json.JsonInt** %"$castedItf", !dbg !2558
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonInt.ToString$I@R@Simatic.Ax.Json.JsonInt@this"(%Simatic.Ax.Json.JsonInt* %"auto_deref_$castedItf"), !dbg !2558
  store %STRING.0 %16, %STRING.0* %0, !dbg !2558
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2558
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2558
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2558
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2558
  ret %STRING.0 %19, !dbg !2558
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2559 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonLInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonLInt* null, %Simatic.Ax.Json.JsonLInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2560
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2560
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2560
  %3 = icmp ne i16 %2, 1, !dbg !2560
  br i1 %3, label %bb2, label %bb3, !dbg !2560

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2560
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonLInt*, !dbg !2560
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %5, i32 0, i32 0, !dbg !2560
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2560
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2560
  %9 = ptrtoint %Simatic.Ax.Json.JsonLInt* %5 to i64, !dbg !2560
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2560
  %11 = sub i64 %9, %10, !dbg !2560
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2560
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2560
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonLInt*, !dbg !2560
  store %Simatic.Ax.Json.JsonLInt* %14, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2560
  br label %bb4, !dbg !2560

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2560

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2560
  %15 = bitcast %Simatic.Ax.Json.JsonLInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2560
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2560
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2560
  ret void, !dbg !2560
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2561 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonLInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonLInt* null, %Simatic.Ax.Json.JsonLInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2562
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2562
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2562
  %3 = icmp ne i16 %2, 1, !dbg !2562
  br i1 %3, label %bb2, label %bb3, !dbg !2562

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2562
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonLInt*, !dbg !2562
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %5, i32 0, i32 0, !dbg !2562
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2562
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2562
  %9 = ptrtoint %Simatic.Ax.Json.JsonLInt* %5 to i64, !dbg !2562
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2562
  %11 = sub i64 %9, %10, !dbg !2562
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2562
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2562
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonLInt*, !dbg !2562
  store %Simatic.Ax.Json.JsonLInt* %14, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2562
  br label %bb4, !dbg !2562

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2562

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2562
  %15 = bitcast %Simatic.Ax.Json.JsonLInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2562
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2562
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2562
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2562
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2562
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2563 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonLInt*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonLInt* null, %Simatic.Ax.Json.JsonLInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2564
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2564
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2564
  %3 = icmp ne i16 %2, 1, !dbg !2564
  br i1 %3, label %bb2, label %bb3, !dbg !2564

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2564
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonLInt*, !dbg !2564
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %5, i32 0, i32 0, !dbg !2564
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2564
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2564
  %9 = ptrtoint %Simatic.Ax.Json.JsonLInt* %5 to i64, !dbg !2564
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2564
  %11 = sub i64 %9, %10, !dbg !2564
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2564
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2564
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonLInt*, !dbg !2564
  store %Simatic.Ax.Json.JsonLInt* %14, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2564
  br label %bb4, !dbg !2564

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2564

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2564
  %15 = bitcast %Simatic.Ax.Json.JsonLInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2564
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2564
  store i1 %16, i1* %HasNext.ret, !dbg !2564
  %17 = load i1, i1* %HasNext.ret, !dbg !2564
  ret i1 %17, !dbg !2564
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2565 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonLInt*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonLInt* null, %Simatic.Ax.Json.JsonLInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2566
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2566
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2566
  %3 = icmp ne i16 %2, 1, !dbg !2566
  br i1 %3, label %bb2, label %bb3, !dbg !2566

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2566
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonLInt*, !dbg !2566
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %5, i32 0, i32 0, !dbg !2566
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2566
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2566
  %9 = ptrtoint %Simatic.Ax.Json.JsonLInt* %5 to i64, !dbg !2566
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2566
  %11 = sub i64 %9, %10, !dbg !2566
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2566
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2566
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonLInt*, !dbg !2566
  store %Simatic.Ax.Json.JsonLInt* %14, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2566
  br label %bb4, !dbg !2566

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2566

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2566
  %15 = bitcast %Simatic.Ax.Json.JsonLInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2566
  %16 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2566
  %17 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %15, %Simatic.Ax.Json.JsonDocument* %16), !dbg !2566
  store i1 %17, i1* %Serialize.ret, !dbg !2566
  %18 = load i1, i1* %Serialize.ret, !dbg !2566
  ret i1 %18, !dbg !2566
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2567 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonLInt*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonLInt* null, %Simatic.Ax.Json.JsonLInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2568
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2568
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2568
  %4 = icmp ne i16 %3, 1, !dbg !2568
  br i1 %4, label %bb2, label %bb3, !dbg !2568

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2568
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonLInt*, !dbg !2568
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonLInt, %Simatic.Ax.Json.JsonLInt* %6, i32 0, i32 0, !dbg !2568
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2568
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2568
  %10 = ptrtoint %Simatic.Ax.Json.JsonLInt* %6 to i64, !dbg !2568
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2568
  %12 = sub i64 %10, %11, !dbg !2568
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2568
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2568
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonLInt*, !dbg !2568
  store %Simatic.Ax.Json.JsonLInt* %15, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2568
  br label %bb4, !dbg !2568

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2568

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonLInt*, %Simatic.Ax.Json.JsonLInt** %"$castedItf", !dbg !2568
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonLInt.ToString$I@R@Simatic.Ax.Json.JsonLInt@this"(%Simatic.Ax.Json.JsonLInt* %"auto_deref_$castedItf"), !dbg !2568
  store %STRING.0 %16, %STRING.0* %0, !dbg !2568
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2568
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2568
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2568
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2568
  ret %STRING.0 %19, !dbg !2568
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2569 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonUSInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonUSInt* null, %Simatic.Ax.Json.JsonUSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2570
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2570
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2570
  %3 = icmp ne i16 %2, 1, !dbg !2570
  br i1 %3, label %bb2, label %bb3, !dbg !2570

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2570
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2570
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %5, i32 0, i32 0, !dbg !2570
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2570
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2570
  %9 = ptrtoint %Simatic.Ax.Json.JsonUSInt* %5 to i64, !dbg !2570
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2570
  %11 = sub i64 %9, %10, !dbg !2570
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2570
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2570
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2570
  store %Simatic.Ax.Json.JsonUSInt* %14, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2570
  br label %bb4, !dbg !2570

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2570

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2570
  %15 = bitcast %Simatic.Ax.Json.JsonUSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2570
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2570
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2570
  ret void, !dbg !2570
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2571 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonUSInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonUSInt* null, %Simatic.Ax.Json.JsonUSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2572
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2572
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2572
  %3 = icmp ne i16 %2, 1, !dbg !2572
  br i1 %3, label %bb2, label %bb3, !dbg !2572

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2572
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2572
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %5, i32 0, i32 0, !dbg !2572
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2572
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2572
  %9 = ptrtoint %Simatic.Ax.Json.JsonUSInt* %5 to i64, !dbg !2572
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2572
  %11 = sub i64 %9, %10, !dbg !2572
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2572
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2572
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2572
  store %Simatic.Ax.Json.JsonUSInt* %14, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2572
  br label %bb4, !dbg !2572

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2572

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2572
  %15 = bitcast %Simatic.Ax.Json.JsonUSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2572
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2572
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2572
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2572
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2572
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2573 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonUSInt*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonUSInt* null, %Simatic.Ax.Json.JsonUSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2574
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2574
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2574
  %3 = icmp ne i16 %2, 1, !dbg !2574
  br i1 %3, label %bb2, label %bb3, !dbg !2574

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2574
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2574
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %5, i32 0, i32 0, !dbg !2574
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2574
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2574
  %9 = ptrtoint %Simatic.Ax.Json.JsonUSInt* %5 to i64, !dbg !2574
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2574
  %11 = sub i64 %9, %10, !dbg !2574
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2574
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2574
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2574
  store %Simatic.Ax.Json.JsonUSInt* %14, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2574
  br label %bb4, !dbg !2574

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2574

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2574
  %15 = bitcast %Simatic.Ax.Json.JsonUSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2574
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2574
  store i1 %16, i1* %HasNext.ret, !dbg !2574
  %17 = load i1, i1* %HasNext.ret, !dbg !2574
  ret i1 %17, !dbg !2574
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2575 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonUSInt*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonUSInt* null, %Simatic.Ax.Json.JsonUSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2576
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2576
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2576
  %3 = icmp ne i16 %2, 1, !dbg !2576
  br i1 %3, label %bb2, label %bb3, !dbg !2576

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2576
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2576
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %5, i32 0, i32 0, !dbg !2576
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2576
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2576
  %9 = ptrtoint %Simatic.Ax.Json.JsonUSInt* %5 to i64, !dbg !2576
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2576
  %11 = sub i64 %9, %10, !dbg !2576
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2576
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2576
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2576
  store %Simatic.Ax.Json.JsonUSInt* %14, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2576
  br label %bb4, !dbg !2576

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2576

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2576
  %15 = bitcast %Simatic.Ax.Json.JsonUSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2576
  %16 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2576
  %17 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %15, %Simatic.Ax.Json.JsonDocument* %16), !dbg !2576
  store i1 %17, i1* %Serialize.ret, !dbg !2576
  %18 = load i1, i1* %Serialize.ret, !dbg !2576
  ret i1 %18, !dbg !2576
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2577 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonUSInt*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonUSInt* null, %Simatic.Ax.Json.JsonUSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2578
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2578
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2578
  %4 = icmp ne i16 %3, 1, !dbg !2578
  br i1 %4, label %bb2, label %bb3, !dbg !2578

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2578
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2578
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonUSInt, %Simatic.Ax.Json.JsonUSInt* %6, i32 0, i32 0, !dbg !2578
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2578
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2578
  %10 = ptrtoint %Simatic.Ax.Json.JsonUSInt* %6 to i64, !dbg !2578
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2578
  %12 = sub i64 %10, %11, !dbg !2578
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2578
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2578
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonUSInt*, !dbg !2578
  store %Simatic.Ax.Json.JsonUSInt* %15, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2578
  br label %bb4, !dbg !2578

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2578

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonUSInt*, %Simatic.Ax.Json.JsonUSInt** %"$castedItf", !dbg !2578
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonUSInt.ToString$I@R@Simatic.Ax.Json.JsonUSInt@this"(%Simatic.Ax.Json.JsonUSInt* %"auto_deref_$castedItf"), !dbg !2578
  store %STRING.0 %16, %STRING.0* %0, !dbg !2578
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2578
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2578
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2578
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2578
  ret %STRING.0 %19, !dbg !2578
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2579 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonSInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonSInt* null, %Simatic.Ax.Json.JsonSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2580
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2580
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2580
  %3 = icmp ne i16 %2, 1, !dbg !2580
  br i1 %3, label %bb2, label %bb3, !dbg !2580

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2580
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonSInt*, !dbg !2580
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %5, i32 0, i32 0, !dbg !2580
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2580
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2580
  %9 = ptrtoint %Simatic.Ax.Json.JsonSInt* %5 to i64, !dbg !2580
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2580
  %11 = sub i64 %9, %10, !dbg !2580
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2580
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2580
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonSInt*, !dbg !2580
  store %Simatic.Ax.Json.JsonSInt* %14, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2580
  br label %bb4, !dbg !2580

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2580

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2580
  %15 = bitcast %Simatic.Ax.Json.JsonSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2580
  %16 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2580
  call void @"Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.AbstractJsonElement* %15, %Simatic.Ax.Json.IJsonElement* %16), !dbg !2580
  ret void, !dbg !2580
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2581 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonSInt*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonSInt* null, %Simatic.Ax.Json.JsonSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2582
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2582
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2582
  %3 = icmp ne i16 %2, 1, !dbg !2582
  br i1 %3, label %bb2, label %bb3, !dbg !2582

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2582
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonSInt*, !dbg !2582
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %5, i32 0, i32 0, !dbg !2582
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2582
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2582
  %9 = ptrtoint %Simatic.Ax.Json.JsonSInt* %5 to i64, !dbg !2582
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2582
  %11 = sub i64 %9, %10, !dbg !2582
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2582
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2582
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonSInt*, !dbg !2582
  store %Simatic.Ax.Json.JsonSInt* %14, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2582
  br label %bb4, !dbg !2582

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2582

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2582
  %15 = bitcast %Simatic.Ax.Json.JsonSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2582
  %16 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2582
  store %Simatic.Ax.Json.IJsonElementMuteable* %16, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2582
  %17 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2582
  ret %Simatic.Ax.Json.IJsonElementMuteable* %17, !dbg !2582
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2583 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonSInt*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonSInt* null, %Simatic.Ax.Json.JsonSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2584
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2584
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2584
  %3 = icmp ne i16 %2, 1, !dbg !2584
  br i1 %3, label %bb2, label %bb3, !dbg !2584

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2584
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonSInt*, !dbg !2584
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %5, i32 0, i32 0, !dbg !2584
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2584
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 1, !dbg !2584
  %9 = ptrtoint %Simatic.Ax.Json.JsonSInt* %5 to i64, !dbg !2584
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %8 to i64, !dbg !2584
  %11 = sub i64 %9, %10, !dbg !2584
  %12 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2584
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2584
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonSInt*, !dbg !2584
  store %Simatic.Ax.Json.JsonSInt* %14, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2584
  br label %bb4, !dbg !2584

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2584

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2584
  %15 = bitcast %Simatic.Ax.Json.JsonSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2584
  %16 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %15), !dbg !2584
  store i1 %16, i1* %HasNext.ret, !dbg !2584
  %17 = load i1, i1* %HasNext.ret, !dbg !2584
  ret i1 %17, !dbg !2584
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2585 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonSInt*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonSInt* null, %Simatic.Ax.Json.JsonSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2586
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2586
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2586
  %3 = icmp ne i16 %2, 1, !dbg !2586
  br i1 %3, label %bb2, label %bb3, !dbg !2586

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2586
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonSInt*, !dbg !2586
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %5, i32 0, i32 0, !dbg !2586
  %7 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %6, i32 0, i32 0, !dbg !2586
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2586
  %9 = ptrtoint %Simatic.Ax.Json.JsonSInt* %5 to i64, !dbg !2586
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2586
  %11 = sub i64 %9, %10, !dbg !2586
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2586
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2586
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonSInt*, !dbg !2586
  store %Simatic.Ax.Json.JsonSInt* %14, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2586
  br label %bb4, !dbg !2586

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2586

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2586
  %15 = bitcast %Simatic.Ax.Json.JsonSInt* %"auto_deref_$castedItf" to %Simatic.Ax.Json.BaseJsonNumber*, !dbg !2586
  %16 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2586
  %17 = call i1 @"Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.BaseJsonNumber* %15, %Simatic.Ax.Json.JsonDocument* %16), !dbg !2586
  store i1 %17, i1* %Serialize.ret, !dbg !2586
  %18 = load i1, i1* %Serialize.ret, !dbg !2586
  ret i1 %18, !dbg !2586
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2587 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonSInt*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonSInt* null, %Simatic.Ax.Json.JsonSInt** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2588
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2588
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2588
  %4 = icmp ne i16 %3, 1, !dbg !2588
  br i1 %4, label %bb2, label %bb3, !dbg !2588

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2588
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonSInt*, !dbg !2588
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonSInt, %Simatic.Ax.Json.JsonSInt* %6, i32 0, i32 0, !dbg !2588
  %8 = getelementptr inbounds %Simatic.Ax.Json.BaseJsonNumber, %Simatic.Ax.Json.BaseJsonNumber* %7, i32 0, i32 0, !dbg !2588
  %9 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %8, i32 0, i32 2, !dbg !2588
  %10 = ptrtoint %Simatic.Ax.Json.JsonSInt* %6 to i64, !dbg !2588
  %11 = ptrtoint %Simatic.Ax.Json.IJsonElement** %9 to i64, !dbg !2588
  %12 = sub i64 %10, %11, !dbg !2588
  %13 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2588
  %14 = getelementptr i8, i8* %13, i64 %12, !dbg !2588
  %15 = bitcast i8* %14 to %Simatic.Ax.Json.JsonSInt*, !dbg !2588
  store %Simatic.Ax.Json.JsonSInt* %15, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2588
  br label %bb4, !dbg !2588

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2588

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonSInt*, %Simatic.Ax.Json.JsonSInt** %"$castedItf", !dbg !2588
  %16 = call %STRING.0 @"Simatic.Ax.Json.JsonSInt.ToString$I@R@Simatic.Ax.Json.JsonSInt@this"(%Simatic.Ax.Json.JsonSInt* %"auto_deref_$castedItf"), !dbg !2588
  store %STRING.0 %16, %STRING.0* %0, !dbg !2588
  %17 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2588
  %18 = bitcast %STRING.0* %0 to i8*, !dbg !2588
  call void @"$ax.AssignST_String"(i8* %17, i8* %18), !dbg !2588
  %19 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2588
  ret %STRING.0 %19, !dbg !2588
}

define linkonce_odr void @"$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElement* %elem) !dbg !2589 {
Entry:
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %elem.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonObject*
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.IJsonElement* %elem, %Simatic.Ax.Json.IJsonElement** %elem.addr
  store %Simatic.Ax.Json.JsonObject* null, %Simatic.Ax.Json.JsonObject** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2590
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2590
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2590
  %3 = icmp ne i16 %2, 1, !dbg !2590
  br i1 %3, label %bb2, label %bb3, !dbg !2590

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2590
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonObject*, !dbg !2590
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %5, i32 0, i32 0, !dbg !2590
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2590
  %8 = ptrtoint %Simatic.Ax.Json.JsonObject* %5 to i64, !dbg !2590
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2590
  %10 = sub i64 %8, %9, !dbg !2590
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2590
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2590
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonObject*, !dbg !2590
  store %Simatic.Ax.Json.JsonObject* %13, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2590
  br label %bb4, !dbg !2590

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2590

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2590
  %14 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %elem.addr, !dbg !2590
  call void @"Simatic.Ax.Json.JsonObject.AddElement$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem"(%Simatic.Ax.Json.JsonObject* %"auto_deref_$castedItf", %Simatic.Ax.Json.IJsonElement* %14), !dbg !2590
  ret void, !dbg !2590
}

define linkonce_odr %Simatic.Ax.Json.IJsonElementMuteable* @"$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2591 {
Entry:
  %GetNext.ret = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonObject*
  store %Simatic.Ax.Json.IJsonElementMuteable* null, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonObject* null, %Simatic.Ax.Json.JsonObject** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2592
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2592
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2592
  %3 = icmp ne i16 %2, 1, !dbg !2592
  br i1 %3, label %bb2, label %bb3, !dbg !2592

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2592
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonObject*, !dbg !2592
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %5, i32 0, i32 0, !dbg !2592
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2592
  %8 = ptrtoint %Simatic.Ax.Json.JsonObject* %5 to i64, !dbg !2592
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2592
  %10 = sub i64 %8, %9, !dbg !2592
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2592
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2592
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonObject*, !dbg !2592
  store %Simatic.Ax.Json.JsonObject* %13, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2592
  br label %bb4, !dbg !2592

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2592

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2592
  %14 = bitcast %Simatic.Ax.Json.JsonObject* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2592
  %15 = call %Simatic.Ax.Json.IJsonElementMuteable* @"Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2592
  store %Simatic.Ax.Json.IJsonElementMuteable* %15, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2592
  %16 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %GetNext.ret, !dbg !2592
  ret %Simatic.Ax.Json.IJsonElementMuteable* %16, !dbg !2592
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this"(%Simatic.Ax.Json.IJsonElementMuteable* %this) !dbg !2593 {
Entry:
  %HasNext.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElementMuteable*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonObject*
  store i1 false, i1* %HasNext.ret
  store %Simatic.Ax.Json.IJsonElementMuteable* %this, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr
  store %Simatic.Ax.Json.JsonObject* null, %Simatic.Ax.Json.JsonObject** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2594
  %1 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %0 to i8**, !dbg !2594
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2594
  %3 = icmp ne i16 %2, 1, !dbg !2594
  br i1 %3, label %bb2, label %bb3, !dbg !2594

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElementMuteable*, %Simatic.Ax.Json.IJsonElementMuteable** %this.addr, !dbg !2594
  %5 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to %Simatic.Ax.Json.JsonObject*, !dbg !2594
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %5, i32 0, i32 0, !dbg !2594
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 1, !dbg !2594
  %8 = ptrtoint %Simatic.Ax.Json.JsonObject* %5 to i64, !dbg !2594
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElementMuteable** %7 to i64, !dbg !2594
  %10 = sub i64 %8, %9, !dbg !2594
  %11 = bitcast %Simatic.Ax.Json.IJsonElementMuteable* %4 to i8*, !dbg !2594
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2594
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonObject*, !dbg !2594
  store %Simatic.Ax.Json.JsonObject* %13, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2594
  br label %bb4, !dbg !2594

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2594

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2594
  %14 = bitcast %Simatic.Ax.Json.JsonObject* %"auto_deref_$castedItf" to %Simatic.Ax.Json.AbstractJsonElement*, !dbg !2594
  %15 = call i1 @"Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this"(%Simatic.Ax.Json.AbstractJsonElement* %14), !dbg !2594
  store i1 %15, i1* %HasNext.ret, !dbg !2594
  %16 = load i1, i1* %HasNext.ret, !dbg !2594
  ret i1 %16, !dbg !2594
}

define linkonce_odr i1 @"$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.JsonDocument* %doc) !dbg !2595 {
Entry:
  %Serialize.ret = alloca i1
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %doc.addr = alloca %Simatic.Ax.Json.JsonDocument*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonObject*
  store i1 false, i1* %Serialize.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonDocument* %doc, %Simatic.Ax.Json.JsonDocument** %doc.addr
  store %Simatic.Ax.Json.JsonObject* null, %Simatic.Ax.Json.JsonObject** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2596
  %1 = bitcast %Simatic.Ax.Json.IJsonElement* %0 to i8**, !dbg !2596
  %2 = call i16 @"$ax.ref_equals_interfaces"(i8** %1, i8** null), !dbg !2596
  %3 = icmp ne i16 %2, 1, !dbg !2596
  br i1 %3, label %bb2, label %bb3, !dbg !2596

bb2:                                              ; preds = %bb1
  %4 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2596
  %5 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to %Simatic.Ax.Json.JsonObject*, !dbg !2596
  %6 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %5, i32 0, i32 0, !dbg !2596
  %7 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %6, i32 0, i32 2, !dbg !2596
  %8 = ptrtoint %Simatic.Ax.Json.JsonObject* %5 to i64, !dbg !2596
  %9 = ptrtoint %Simatic.Ax.Json.IJsonElement** %7 to i64, !dbg !2596
  %10 = sub i64 %8, %9, !dbg !2596
  %11 = bitcast %Simatic.Ax.Json.IJsonElement* %4 to i8*, !dbg !2596
  %12 = getelementptr i8, i8* %11, i64 %10, !dbg !2596
  %13 = bitcast i8* %12 to %Simatic.Ax.Json.JsonObject*, !dbg !2596
  store %Simatic.Ax.Json.JsonObject* %13, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2596
  br label %bb4, !dbg !2596

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2596

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2596
  %14 = load %Simatic.Ax.Json.JsonDocument*, %Simatic.Ax.Json.JsonDocument** %doc.addr, !dbg !2596
  %15 = call i1 @"Simatic.Ax.Json.JsonObject.Serialize$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc"(%Simatic.Ax.Json.JsonObject* %"auto_deref_$castedItf", %Simatic.Ax.Json.JsonDocument* %14), !dbg !2596
  store i1 %15, i1* %Serialize.ret, !dbg !2596
  %16 = load i1, i1* %Serialize.ret, !dbg !2596
  ret i1 %16, !dbg !2596
}

define linkonce_odr %STRING.0 @"$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this"(%Simatic.Ax.Json.IJsonElement* %this) !dbg !2597 {
Entry:
  %ToString.ret = alloca %STRING.0
  %this.addr = alloca %Simatic.Ax.Json.IJsonElement*
  %"$castedItf" = alloca %Simatic.Ax.Json.JsonObject*
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %ToString.ret
  store %Simatic.Ax.Json.IJsonElement* %this, %Simatic.Ax.Json.IJsonElement** %this.addr
  store %Simatic.Ax.Json.JsonObject* null, %Simatic.Ax.Json.JsonObject** %"$castedItf"
  br label %bb1

bb1:                                              ; preds = %Entry
  %1 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2598
  %2 = bitcast %Simatic.Ax.Json.IJsonElement* %1 to i8**, !dbg !2598
  %3 = call i16 @"$ax.ref_equals_interfaces"(i8** %2, i8** null), !dbg !2598
  %4 = icmp ne i16 %3, 1, !dbg !2598
  br i1 %4, label %bb2, label %bb3, !dbg !2598

bb2:                                              ; preds = %bb1
  %5 = load %Simatic.Ax.Json.IJsonElement*, %Simatic.Ax.Json.IJsonElement** %this.addr, !dbg !2598
  %6 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to %Simatic.Ax.Json.JsonObject*, !dbg !2598
  %7 = getelementptr inbounds %Simatic.Ax.Json.JsonObject, %Simatic.Ax.Json.JsonObject* %6, i32 0, i32 0, !dbg !2598
  %8 = getelementptr inbounds %Simatic.Ax.Json.AbstractJsonElement, %Simatic.Ax.Json.AbstractJsonElement* %7, i32 0, i32 2, !dbg !2598
  %9 = ptrtoint %Simatic.Ax.Json.JsonObject* %6 to i64, !dbg !2598
  %10 = ptrtoint %Simatic.Ax.Json.IJsonElement** %8 to i64, !dbg !2598
  %11 = sub i64 %9, %10, !dbg !2598
  %12 = bitcast %Simatic.Ax.Json.IJsonElement* %5 to i8*, !dbg !2598
  %13 = getelementptr i8, i8* %12, i64 %11, !dbg !2598
  %14 = bitcast i8* %13 to %Simatic.Ax.Json.JsonObject*, !dbg !2598
  store %Simatic.Ax.Json.JsonObject* %14, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2598
  br label %bb4, !dbg !2598

bb3:                                              ; preds = %bb1
  br label %bb4, !dbg !2598

bb4:                                              ; preds = %bb3, %bb2
  %"auto_deref_$castedItf" = load %Simatic.Ax.Json.JsonObject*, %Simatic.Ax.Json.JsonObject** %"$castedItf", !dbg !2598
  %15 = call %STRING.0 @"Simatic.Ax.Json.JsonObject.ToString$I@R@Simatic.Ax.Json.JsonObject@this"(%Simatic.Ax.Json.JsonObject* %"auto_deref_$castedItf"), !dbg !2598
  store %STRING.0 %15, %STRING.0* %0, !dbg !2598
  %16 = bitcast %STRING.0* %ToString.ret to i8*, !dbg !2598
  %17 = bitcast %STRING.0* %0 to i8*, !dbg !2598
  call void @"$ax.AssignST_String"(i8* %16, i8* %17), !dbg !2598
  %18 = load %STRING.0, %STRING.0* %ToString.ret, !dbg !2598
  ret %STRING.0 %18, !dbg !2598
}

; Function Attrs: noreturn uwtable
define dso_local void @"?$ax.stderr@@YAXPEBD@Z"(i8* %0) #1 {
  %2 = tail call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @"??_C@_03OFAPEBGM@?$CFs?6?$AA@", i64 0, i64 0), i8* %0)
  tail call void @exit(i32 1) #15
  unreachable
}

; Function Attrs: inlinehint nobuiltin uwtable
define linkonce_odr dso_local i32 @printf(i8* %0, ...) #2 comdat {
  %2 = alloca i8*, align 8
  %3 = bitcast i8** %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #5
  call void @llvm.va_start(i8* nonnull %3)
  %4 = load i8*, i8** %2, align 8, !tbaa !2599
  %5 = call %struct._iobuf* @__acrt_iob_func(i32 1)
  %6 = call i64* @__local_stdio_printf_options()
  %7 = load i64, i64* %6, align 8, !tbaa !2603
  %8 = call i32 @__stdio_common_vfprintf(i64 %7, %struct._iobuf* %5, i8* %0, %struct.__crt_locale_pointers* null, i8* %4)
  call void @llvm.va_end(i8* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #5
  ret i32 %8
}

; Function Attrs: noreturn
declare dso_local void @exit(i32) local_unnamed_addr #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #4

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #5

declare dso_local %struct._iobuf* @__acrt_iob_func(i32) #6

; Function Attrs: noinline nounwind uwtable
define linkonce_odr dso_local i64* @__local_stdio_printf_options() #7 comdat {
  ret i64* @"?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA"
}

declare dso_local i32 @__stdio_common_vfprintf(i64, %struct._iobuf*, i8*, %struct.__crt_locale_pointers*, i8*) #6

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #5

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #4

; Function Attrs: uwtable
define dso_local i32 @"$ax.LowerBound"(%"$ax.ArrayWithBound"* nocapture readonly %0, i32 %1) #8 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %15, label %4

4:                                                ; preds = %2
  %5 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %0, i64 0, i32 1
  %6 = load i32, i32* %5, align 8, !tbaa !2605
  %7 = icmp ult i32 %6, %1
  br i1 %7, label %15, label %8

8:                                                ; preds = %4
  %9 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %0, i64 0, i32 2
  %10 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %9, align 8, !tbaa !2608
  %11 = add i32 %1, -1
  %12 = zext i32 %11 to i64
  %13 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %10, i64 %12, i32 0
  %14 = load i32, i32* %13, align 4, !tbaa !2609
  br label %17

15:                                               ; preds = %4, %2
  %16 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  tail call void %16(i8* getelementptr inbounds ([84 x i8], [84 x i8]* @"??_C@_0FE@HKMFAKJH@The?5dimension?5for?5lower_bound?5is@", i64 0, i64 0))
  br label %17

17:                                               ; preds = %15, %8
  %18 = phi i32 [ %14, %8 ], [ -2147483648, %15 ]
  ret i32 %18
}

; Function Attrs: uwtable
define dso_local i32 @"$ax.UpperBound"(%"$ax.ArrayWithBound"* nocapture readonly %0, i32 %1) #8 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %15, label %4

4:                                                ; preds = %2
  %5 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %0, i64 0, i32 1
  %6 = load i32, i32* %5, align 8, !tbaa !2605
  %7 = icmp ult i32 %6, %1
  br i1 %7, label %15, label %8

8:                                                ; preds = %4
  %9 = getelementptr inbounds %"$ax.ArrayWithBound", %"$ax.ArrayWithBound"* %0, i64 0, i32 2
  %10 = load %"$ax.ArrayBounds"*, %"$ax.ArrayBounds"** %9, align 8, !tbaa !2608
  %11 = add i32 %1, -1
  %12 = zext i32 %11 to i64
  %13 = getelementptr inbounds %"$ax.ArrayBounds", %"$ax.ArrayBounds"* %10, i64 %12, i32 1
  %14 = load i32, i32* %13, align 4, !tbaa !2611
  br label %17

15:                                               ; preds = %4, %2
  %16 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  tail call void %16(i8* getelementptr inbounds ([84 x i8], [84 x i8]* @"??_C@_0FE@MELOPMAH@The?5dimension?5for?5upper_bound?5is@", i64 0, i64 0))
  br label %17

17:                                               ; preds = %15, %8
  %18 = phi i32 [ %14, %8 ], [ -2147483648, %15 ]
  ret i32 %18
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i8** @"$ax.dyn_cast_class_itf"(i64 %0, i8* readonly %1) local_unnamed_addr #9 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %27, label %4

4:                                                ; preds = %2
  %5 = bitcast i8* %1 to %struct._ClassDescriptorStub**
  %6 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %5, align 8, !tbaa !2599
  %7 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %6, i64 0, i32 2
  %8 = load i16, i16* %7, align 8, !tbaa !2612
  %9 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %6, i64 0, i32 3
  %10 = load %struct._InterfaceTableEntry*, %struct._InterfaceTableEntry** %9, align 8, !tbaa !2615
  %11 = icmp sgt i16 %8, 0
  br i1 %11, label %12, label %27

12:                                               ; preds = %4
  %13 = zext i16 %8 to i64
  br label %16

14:                                               ; preds = %16
  %15 = icmp eq i64 %21, %13
  br i1 %15, label %27, label %16

16:                                               ; preds = %14, %12
  %17 = phi i64 [ 0, %12 ], [ %21, %14 ]
  %18 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %10, i64 %17, i32 1
  %19 = load i64, i64* %18, align 8, !tbaa !2616
  %20 = icmp eq i64 %19, %0
  %21 = add nuw nsw i64 %17, 1
  br i1 %20, label %22, label %14

22:                                               ; preds = %16
  %23 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %10, i64 %17, i32 0
  %24 = load i64, i64* %23, align 8, !tbaa !2618
  %25 = getelementptr inbounds i8, i8* %1, i64 %24
  %26 = bitcast i8* %25 to i8**
  br label %27

27:                                               ; preds = %22, %14, %4, %2
  %28 = phi i8** [ null, %2 ], [ %26, %22 ], [ null, %4 ], [ null, %14 ]
  ret i8** %28
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i8* @"$ax.dyn_cast_itf_class"(i8* readnone %0, i8** readonly %1) local_unnamed_addr #9 {
  %3 = icmp eq i8** %1, null
  br i1 %3, label %45, label %4

4:                                                ; preds = %2
  %5 = bitcast i8** %1 to %struct._InterfaceDescriptorStub**
  %6 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %5, align 8, !tbaa !2599
  %7 = getelementptr inbounds %struct._InterfaceDescriptorStub, %struct._InterfaceDescriptorStub* %6, i64 0, i32 0
  %8 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %7, align 8, !tbaa !2619
  %9 = icmp ne %struct._ClassDescriptorStub* %8, null
  %10 = bitcast %struct._ClassDescriptorStub* %8 to i8*
  %11 = icmp ne i8* %10, %0
  %12 = and i1 %9, %11
  br i1 %12, label %13, label %21

13:                                               ; preds = %13, %4
  %14 = phi %struct._ClassDescriptorStub* [ %16, %13 ], [ %8, %4 ]
  %15 = getelementptr inbounds %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %14, i64 0, i32 0
  %16 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %15, align 8, !tbaa !2621
  %17 = icmp ne %struct._ClassDescriptorStub* %16, null
  %18 = bitcast %struct._ClassDescriptorStub* %16 to i8*
  %19 = icmp ne i8* %18, %0
  %20 = and i1 %17, %19
  br i1 %20, label %13, label %21

21:                                               ; preds = %13, %4
  %22 = phi i1 [ %9, %4 ], [ %17, %13 ]
  br i1 %22, label %23, label %45

23:                                               ; preds = %21
  %24 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %8, i64 0, i32 2
  %25 = load i16, i16* %24, align 8, !tbaa !2612
  %26 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %8, i64 0, i32 3
  %27 = load %struct._InterfaceTableEntry*, %struct._InterfaceTableEntry** %26, align 8, !tbaa !2615
  %28 = icmp sgt i16 %25, 0
  br i1 %28, label %29, label %45

29:                                               ; preds = %23
  %30 = zext i16 %25 to i64
  br label %33

31:                                               ; preds = %33
  %32 = icmp eq i64 %38, %30
  br i1 %32, label %45, label %33

33:                                               ; preds = %31, %29
  %34 = phi i64 [ 0, %29 ], [ %38, %31 ]
  %35 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %27, i64 %34, i32 2
  %36 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %35, align 8, !tbaa !2622
  %37 = icmp eq %struct._InterfaceDescriptorStub* %36, %6
  %38 = add nuw nsw i64 %34, 1
  br i1 %37, label %39, label %31

39:                                               ; preds = %33
  %40 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %27, i64 %34, i32 0
  %41 = load i64, i64* %40, align 8, !tbaa !2618
  %42 = bitcast i8** %1 to i8*
  %43 = sub i64 0, %41
  %44 = getelementptr inbounds i8, i8* %42, i64 %43
  br label %45

45:                                               ; preds = %39, %31, %23, %21, %2
  %46 = phi i8* [ null, %2 ], [ %44, %39 ], [ null, %21 ], [ null, %23 ], [ null, %31 ]
  ret i8* %46
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i8** @"$ax.dyn_cast_itf_itf"(i64 %0, i8** readonly %1) #9 {
  %3 = icmp eq i8** %1, null
  br i1 %3, label %40, label %4

4:                                                ; preds = %2
  %5 = bitcast i8** %1 to %struct._InterfaceDescriptorStub**
  %6 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %5, align 8, !tbaa !2599
  %7 = getelementptr inbounds %struct._InterfaceDescriptorStub, %struct._InterfaceDescriptorStub* %6, i64 0, i32 0
  %8 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %7, align 8, !tbaa !2619
  %9 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %8, i64 0, i32 2
  %10 = load i16, i16* %9, align 8, !tbaa !2612
  %11 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %8, i64 0, i32 3
  %12 = load %struct._InterfaceTableEntry*, %struct._InterfaceTableEntry** %11, align 8, !tbaa !2615
  %13 = icmp sgt i16 %10, 0
  br i1 %13, label %14, label %40

14:                                               ; preds = %4
  %15 = zext i16 %10 to i64
  br label %18

16:                                               ; preds = %18
  %17 = icmp eq i64 %23, %15
  br i1 %17, label %40, label %18

18:                                               ; preds = %16, %14
  %19 = phi i64 [ 0, %14 ], [ %23, %16 ]
  %20 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %12, i64 %19, i32 1
  %21 = load i64, i64* %20, align 8, !tbaa !2616
  %22 = icmp eq i64 %21, %0
  %23 = add nuw nsw i64 %19, 1
  br i1 %22, label %24, label %16

24:                                               ; preds = %24, %18
  %25 = phi i64 [ %29, %24 ], [ 0, %18 ]
  %26 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %12, i64 %25, i32 2
  %27 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %26, align 8, !tbaa !2622
  %28 = icmp eq %struct._InterfaceDescriptorStub* %27, %6
  %29 = add nuw nsw i64 %25, 1
  br i1 %28, label %30, label %24

30:                                               ; preds = %24
  %31 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %12, i64 %25, i32 0
  %32 = load i64, i64* %31, align 8, !tbaa !2618
  %33 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %12, i64 %19, i32 0
  %34 = load i64, i64* %33, align 8, !tbaa !2618
  %35 = bitcast i8** %1 to i8*
  %36 = sub i64 0, %32
  %37 = getelementptr inbounds i8, i8* %35, i64 %36
  %38 = getelementptr inbounds i8, i8* %37, i64 %34
  %39 = bitcast i8* %38 to i8**
  br label %40

40:                                               ; preds = %30, %16, %4, %2
  %41 = phi i8** [ null, %2 ], [ %39, %30 ], [ null, %4 ], [ null, %16 ]
  ret i8** %41
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i8* @"$ax.dyn_cast_class_class"(i8* readnone %0, i8* readonly %1) local_unnamed_addr #9 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %16, label %4

4:                                                ; preds = %2
  %5 = bitcast i8* %1 to %struct._ClassDescriptorStub**
  br label %6

6:                                                ; preds = %6, %4
  %7 = phi %struct._ClassDescriptorStub** [ %5, %4 ], [ %13, %6 ]
  %8 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %7, align 8, !tbaa !2599
  %9 = icmp ne %struct._ClassDescriptorStub* %8, null
  %10 = bitcast %struct._ClassDescriptorStub* %8 to i8*
  %11 = icmp ne i8* %10, %0
  %12 = and i1 %9, %11
  %13 = getelementptr inbounds %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %8, i64 0, i32 0
  br i1 %12, label %6, label %14

14:                                               ; preds = %6
  %15 = select i1 %9, i8* %1, i8* null
  br label %16

16:                                               ; preds = %14, %2
  %17 = phi i8* [ %15, %14 ], [ null, %2 ]
  ret i8* %17
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i16 @"$ax.ref_equals_interfaces"(i8** readonly %0, i8** readonly %1) #9 {
  %3 = icmp eq i8** %0, null
  %4 = icmp eq i8** %1, null
  %5 = and i1 %3, %4
  br i1 %5, label %61, label %6

6:                                                ; preds = %2
  %7 = icmp ne i8** %0, null
  %8 = and i1 %7, %4
  %9 = icmp ne i8** %1, null
  %10 = and i1 %3, %9
  %11 = or i1 %8, %10
  br i1 %11, label %61, label %12

12:                                               ; preds = %6
  %13 = bitcast i8** %0 to %struct._InterfaceDescriptorStub**
  %14 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %13, align 8, !tbaa !2599
  %15 = getelementptr inbounds %struct._InterfaceDescriptorStub, %struct._InterfaceDescriptorStub* %14, i64 0, i32 0
  %16 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %15, align 8, !tbaa !2619
  %17 = bitcast i8** %1 to %struct._InterfaceDescriptorStub**
  %18 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %17, align 8, !tbaa !2599
  %19 = getelementptr inbounds %struct._InterfaceDescriptorStub, %struct._InterfaceDescriptorStub* %18, i64 0, i32 0
  %20 = load %struct._ClassDescriptorStub*, %struct._ClassDescriptorStub** %19, align 8, !tbaa !2619
  %21 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %16, i64 0, i32 2
  %22 = load i16, i16* %21, align 8, !tbaa !2612
  %23 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %16, i64 0, i32 3
  %24 = load %struct._InterfaceTableEntry*, %struct._InterfaceTableEntry** %23, align 8, !tbaa !2615
  %25 = icmp sgt i16 %22, 0
  br i1 %25, label %26, label %38

26:                                               ; preds = %12
  %27 = zext i16 %22 to i64
  br label %30

28:                                               ; preds = %30
  %29 = icmp eq i64 %35, %27
  br i1 %29, label %38, label %30

30:                                               ; preds = %28, %26
  %31 = phi i64 [ 0, %26 ], [ %35, %28 ]
  %32 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %24, i64 %31, i32 2
  %33 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %32, align 8, !tbaa !2622
  %34 = icmp eq %struct._InterfaceDescriptorStub* %33, %14
  %35 = add nuw nsw i64 %31, 1
  br i1 %34, label %36, label %28

36:                                               ; preds = %30
  %37 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %24, i64 %31
  br label %38

38:                                               ; preds = %36, %28, %12
  %39 = phi %struct._InterfaceTableEntry* [ null, %12 ], [ %37, %36 ], [ null, %28 ]
  %40 = getelementptr %struct._ClassDescriptorStub, %struct._ClassDescriptorStub* %20, i64 0, i32 3
  %41 = load %struct._InterfaceTableEntry*, %struct._InterfaceTableEntry** %40, align 8, !tbaa !2615
  br label %42

42:                                               ; preds = %42, %38
  %43 = phi i64 [ 0, %38 ], [ %47, %42 ]
  %44 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %41, i64 %43, i32 2
  %45 = load %struct._InterfaceDescriptorStub*, %struct._InterfaceDescriptorStub** %44, align 8, !tbaa !2622
  %46 = icmp eq %struct._InterfaceDescriptorStub* %45, %18
  %47 = add nuw nsw i64 %43, 1
  br i1 %46, label %48, label %42

48:                                               ; preds = %42
  %49 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %39, i64 0, i32 0
  %50 = load i64, i64* %49, align 8, !tbaa !2618
  %51 = getelementptr inbounds %struct._InterfaceTableEntry, %struct._InterfaceTableEntry* %41, i64 %43, i32 0
  %52 = load i64, i64* %51, align 8, !tbaa !2618
  %53 = bitcast i8** %0 to i8*
  %54 = bitcast i8** %1 to i8*
  %55 = sub i64 0, %50
  %56 = getelementptr inbounds i8, i8* %53, i64 %55
  %57 = sub i64 0, %52
  %58 = getelementptr inbounds i8, i8* %54, i64 %57
  %59 = icmp eq i8* %56, %58
  %60 = zext i1 %59 to i16
  br label %61

61:                                               ; preds = %48, %6, %2
  %62 = phi i16 [ %60, %48 ], [ 1, %2 ], [ 0, %6 ]
  ret i16 %62
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @"$ax.CmpST_String"(i8* nocapture readonly %0, i8* nocapture readonly %1) #9 {
  %3 = getelementptr inbounds i8, i8* %1, i64 1
  %4 = load i8, i8* %3, align 1, !tbaa !2623
  %5 = getelementptr inbounds i8, i8* %0, i64 1
  %6 = load i8, i8* %5, align 1, !tbaa !2623
  %7 = icmp ult i8 %6, %4
  %8 = select i1 %7, i8 %6, i8 %4
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %26, label %10

10:                                               ; preds = %2
  %11 = getelementptr inbounds i8, i8* %0, i64 2
  %12 = getelementptr inbounds i8, i8* %1, i64 2
  %13 = zext i8 %8 to i64
  br label %16

14:                                               ; preds = %23
  %15 = icmp ult i64 %25, %13
  br i1 %15, label %16, label %26

16:                                               ; preds = %14, %10
  %17 = phi i64 [ 0, %10 ], [ %25, %14 ]
  %18 = getelementptr inbounds i8, i8* %11, i64 %17
  %19 = load i8, i8* %18, align 1, !tbaa !2625
  %20 = getelementptr inbounds i8, i8* %12, i64 %17
  %21 = load i8, i8* %20, align 1, !tbaa !2625
  %22 = icmp slt i8 %19, %21
  br i1 %22, label %30, label %23

23:                                               ; preds = %16
  %24 = icmp sgt i8 %19, %21
  %25 = add nuw nsw i64 %17, 1
  br i1 %24, label %30, label %14

26:                                               ; preds = %14, %2
  br i1 %7, label %30, label %27

27:                                               ; preds = %26
  %28 = icmp ugt i8 %6, %4
  %29 = zext i1 %28 to i32
  br label %30

30:                                               ; preds = %27, %26, %23, %16
  %31 = phi i32 [ -1, %26 ], [ %29, %27 ], [ 1, %23 ], [ -1, %16 ]
  ret i32 %31
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @"$ax.CmpST_WString"(i16* nocapture readonly %0, i16* nocapture readonly %1) local_unnamed_addr #9 {
  %3 = getelementptr inbounds i16, i16* %1, i64 1
  %4 = load i16, i16* %3, align 2, !tbaa !2626
  %5 = getelementptr inbounds i16, i16* %0, i64 1
  %6 = load i16, i16* %5, align 2, !tbaa !2626
  %7 = icmp ult i16 %6, %4
  %8 = select i1 %7, i16 %6, i16 %4
  %9 = icmp eq i16 %8, 0
  br i1 %9, label %26, label %10

10:                                               ; preds = %2
  %11 = getelementptr inbounds i16, i16* %0, i64 2
  %12 = getelementptr inbounds i16, i16* %1, i64 2
  %13 = zext i16 %8 to i64
  br label %16

14:                                               ; preds = %23
  %15 = icmp ult i64 %25, %13
  br i1 %15, label %16, label %26

16:                                               ; preds = %14, %10
  %17 = phi i64 [ 0, %10 ], [ %25, %14 ]
  %18 = getelementptr inbounds i16, i16* %11, i64 %17
  %19 = load i16, i16* %18, align 2, !tbaa !2628
  %20 = getelementptr inbounds i16, i16* %12, i64 %17
  %21 = load i16, i16* %20, align 2, !tbaa !2628
  %22 = icmp slt i16 %19, %21
  br i1 %22, label %30, label %23

23:                                               ; preds = %16
  %24 = icmp sgt i16 %19, %21
  %25 = add nuw nsw i64 %17, 1
  br i1 %24, label %30, label %14

26:                                               ; preds = %14, %2
  br i1 %7, label %30, label %27

27:                                               ; preds = %26
  %28 = icmp ugt i16 %6, %4
  %29 = zext i1 %28 to i32
  br label %30

30:                                               ; preds = %27, %26, %23, %16
  %31 = phi i32 [ -1, %26 ], [ %29, %27 ], [ 1, %23 ], [ -1, %16 ]
  ret i32 %31
}

; Function Attrs: uwtable
define dso_local void @"$ax.AssignST_String"(i8* %0, i8* %1) #8 {
  tail call void @"??$$ax.Assign_String@DU$ax.ST_STRING@@@@YAXPEADPEBD@Z"(i8* %0, i8* %1)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr dso_local void @"??$$ax.Assign_String@DU$ax.ST_STRING@@@@YAXPEADPEBD@Z"(i8* %0, i8* %1) local_unnamed_addr #8 comdat {
  %3 = alloca [256 x i8], align 16
  %4 = getelementptr inbounds i8, i8* %1, i64 1
  %5 = load i8, i8* %4, align 1, !tbaa !2623
  %6 = load i8, i8* %1, align 1, !tbaa !2629
  %7 = icmp ugt i8 %5, %6
  br i1 %7, label %8, label %14

8:                                                ; preds = %2
  %9 = zext i8 %5 to i32
  %10 = zext i8 %6 to i32
  %11 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %11) #5
  %12 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %11, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %10, i32 %9, i32 75)
  %13 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %13(i8* nonnull %11)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %11) #5
  br label %14

14:                                               ; preds = %8, %2
  %15 = getelementptr inbounds i8, i8* %0, i64 1
  %16 = load i8, i8* %15, align 1, !tbaa !2623
  %17 = load i8, i8* %0, align 1, !tbaa !2629
  %18 = icmp ugt i8 %16, %17
  br i1 %18, label %19, label %26

19:                                               ; preds = %14
  %20 = zext i8 %16 to i32
  %21 = zext i8 %17 to i32
  %22 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %22) #5
  %23 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %22, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %21, i32 %20, i32 76)
  %24 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %24(i8* nonnull %22)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %22) #5
  %25 = load i8, i8* %0, align 1, !tbaa !2629
  br label %26

26:                                               ; preds = %19, %14
  %27 = phi i8 [ %17, %14 ], [ %25, %19 ]
  %28 = load i8, i8* %4, align 1, !tbaa !2623
  %29 = icmp ult i8 %27, %28
  %30 = select i1 %29, i8 %27, i8 %28
  %31 = getelementptr inbounds i8, i8* %0, i64 2
  %32 = getelementptr inbounds i8, i8* %1, i64 2
  %33 = icmp eq i8 %30, 0
  br i1 %33, label %125, label %34

34:                                               ; preds = %26
  %35 = zext i8 %30 to i64
  %36 = icmp ult i8 %30, 32
  br i1 %36, label %37, label %39

37:                                               ; preds = %123, %39, %34
  %38 = phi i64 [ 0, %39 ], [ 0, %34 ], [ %47, %123 ]
  br label %147

39:                                               ; preds = %34
  %40 = add nuw nsw i64 %35, 2
  %41 = getelementptr i8, i8* %0, i64 %40
  %42 = getelementptr i8, i8* %1, i64 %40
  %43 = icmp ult i8* %31, %42
  %44 = icmp ult i8* %32, %41
  %45 = and i1 %43, %44
  br i1 %45, label %37, label %46

46:                                               ; preds = %39
  %47 = and i64 %35, 224
  %48 = add nsw i64 %47, -32
  %49 = lshr exact i64 %48, 5
  %50 = add nuw nsw i64 %49, 1
  %51 = and i64 %50, 3
  %52 = icmp ult i64 %48, 96
  br i1 %52, label %104, label %53

53:                                               ; preds = %46
  %54 = sub nsw i64 %50, %51
  br label %55

55:                                               ; preds = %55, %53
  %56 = phi i64 [ 0, %53 ], [ %101, %55 ]
  %57 = phi i64 [ %54, %53 ], [ %102, %55 ]
  %58 = getelementptr inbounds i8, i8* %32, i64 %56
  %59 = bitcast i8* %58 to <16 x i8>*
  %60 = load <16 x i8>, <16 x i8>* %59, align 1, !tbaa !2625, !alias.scope !2630
  %61 = getelementptr inbounds i8, i8* %58, i64 16
  %62 = bitcast i8* %61 to <16 x i8>*
  %63 = load <16 x i8>, <16 x i8>* %62, align 1, !tbaa !2625, !alias.scope !2630
  %64 = getelementptr inbounds i8, i8* %31, i64 %56
  %65 = bitcast i8* %64 to <16 x i8>*
  store <16 x i8> %60, <16 x i8>* %65, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %66 = getelementptr inbounds i8, i8* %64, i64 16
  %67 = bitcast i8* %66 to <16 x i8>*
  store <16 x i8> %63, <16 x i8>* %67, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %68 = or i64 %56, 32
  %69 = getelementptr inbounds i8, i8* %32, i64 %68
  %70 = bitcast i8* %69 to <16 x i8>*
  %71 = load <16 x i8>, <16 x i8>* %70, align 1, !tbaa !2625, !alias.scope !2630
  %72 = getelementptr inbounds i8, i8* %69, i64 16
  %73 = bitcast i8* %72 to <16 x i8>*
  %74 = load <16 x i8>, <16 x i8>* %73, align 1, !tbaa !2625, !alias.scope !2630
  %75 = getelementptr inbounds i8, i8* %31, i64 %68
  %76 = bitcast i8* %75 to <16 x i8>*
  store <16 x i8> %71, <16 x i8>* %76, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %77 = getelementptr inbounds i8, i8* %75, i64 16
  %78 = bitcast i8* %77 to <16 x i8>*
  store <16 x i8> %74, <16 x i8>* %78, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %79 = or i64 %56, 64
  %80 = getelementptr inbounds i8, i8* %32, i64 %79
  %81 = bitcast i8* %80 to <16 x i8>*
  %82 = load <16 x i8>, <16 x i8>* %81, align 1, !tbaa !2625, !alias.scope !2630
  %83 = getelementptr inbounds i8, i8* %80, i64 16
  %84 = bitcast i8* %83 to <16 x i8>*
  %85 = load <16 x i8>, <16 x i8>* %84, align 1, !tbaa !2625, !alias.scope !2630
  %86 = getelementptr inbounds i8, i8* %31, i64 %79
  %87 = bitcast i8* %86 to <16 x i8>*
  store <16 x i8> %82, <16 x i8>* %87, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %88 = getelementptr inbounds i8, i8* %86, i64 16
  %89 = bitcast i8* %88 to <16 x i8>*
  store <16 x i8> %85, <16 x i8>* %89, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %90 = or i64 %56, 96
  %91 = getelementptr inbounds i8, i8* %32, i64 %90
  %92 = bitcast i8* %91 to <16 x i8>*
  %93 = load <16 x i8>, <16 x i8>* %92, align 1, !tbaa !2625, !alias.scope !2630
  %94 = getelementptr inbounds i8, i8* %91, i64 16
  %95 = bitcast i8* %94 to <16 x i8>*
  %96 = load <16 x i8>, <16 x i8>* %95, align 1, !tbaa !2625, !alias.scope !2630
  %97 = getelementptr inbounds i8, i8* %31, i64 %90
  %98 = bitcast i8* %97 to <16 x i8>*
  store <16 x i8> %93, <16 x i8>* %98, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %99 = getelementptr inbounds i8, i8* %97, i64 16
  %100 = bitcast i8* %99 to <16 x i8>*
  store <16 x i8> %96, <16 x i8>* %100, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %101 = add i64 %56, 128
  %102 = add i64 %57, -4
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %104, label %55, !llvm.loop !2635

104:                                              ; preds = %55, %46
  %105 = phi i64 [ 0, %46 ], [ %101, %55 ]
  %106 = icmp eq i64 %51, 0
  br i1 %106, label %123, label %107

107:                                              ; preds = %107, %104
  %108 = phi i64 [ %120, %107 ], [ %105, %104 ]
  %109 = phi i64 [ %121, %107 ], [ %51, %104 ]
  %110 = getelementptr inbounds i8, i8* %32, i64 %108
  %111 = bitcast i8* %110 to <16 x i8>*
  %112 = load <16 x i8>, <16 x i8>* %111, align 1, !tbaa !2625, !alias.scope !2630
  %113 = getelementptr inbounds i8, i8* %110, i64 16
  %114 = bitcast i8* %113 to <16 x i8>*
  %115 = load <16 x i8>, <16 x i8>* %114, align 1, !tbaa !2625, !alias.scope !2630
  %116 = getelementptr inbounds i8, i8* %31, i64 %108
  %117 = bitcast i8* %116 to <16 x i8>*
  store <16 x i8> %112, <16 x i8>* %117, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %118 = getelementptr inbounds i8, i8* %116, i64 16
  %119 = bitcast i8* %118 to <16 x i8>*
  store <16 x i8> %115, <16 x i8>* %119, align 1, !tbaa !2625, !alias.scope !2633, !noalias !2630
  %120 = add i64 %108, 32
  %121 = add i64 %109, -1
  %122 = icmp eq i64 %121, 0
  br i1 %122, label %123, label %107, !llvm.loop !2637

123:                                              ; preds = %107, %104
  %124 = icmp eq i64 %47, %35
  br i1 %124, label %125, label %37

125:                                              ; preds = %147, %123, %26
  %126 = zext i8 %30 to i64
  %127 = getelementptr inbounds i8, i8* %31, i64 %126
  store i8 0, i8* %127, align 1, !tbaa !2625
  store i8 %30, i8* %15, align 1, !tbaa !2623
  %128 = load i8, i8* %4, align 1, !tbaa !2623
  %129 = load i8, i8* %1, align 1, !tbaa !2629
  %130 = icmp ugt i8 %128, %129
  br i1 %130, label %131, label %146

131:                                              ; preds = %125
  %132 = zext i8 %128 to i32
  %133 = zext i8 %129 to i32
  %134 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %134) #5
  %135 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %134, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %133, i32 %132, i32 90)
  %136 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %136(i8* nonnull %134)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %134) #5
  %137 = load i8, i8* %15, align 1, !tbaa !2623
  %138 = load i8, i8* %0, align 1, !tbaa !2629
  %139 = icmp ugt i8 %137, %138
  br i1 %139, label %140, label %146

140:                                              ; preds = %131
  %141 = zext i8 %137 to i32
  %142 = zext i8 %138 to i32
  %143 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %143) #5
  %144 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %143, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %142, i32 %141, i32 91)
  %145 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %145(i8* nonnull %143)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %143) #5
  br label %146

146:                                              ; preds = %140, %131, %125
  ret void

147:                                              ; preds = %147, %37
  %148 = phi i64 [ %152, %147 ], [ %38, %37 ]
  %149 = getelementptr inbounds i8, i8* %32, i64 %148
  %150 = load i8, i8* %149, align 1, !tbaa !2625
  %151 = getelementptr inbounds i8, i8* %31, i64 %148
  store i8 %150, i8* %151, align 1, !tbaa !2625
  %152 = add nuw nsw i64 %148, 1
  %153 = icmp ult i64 %152, %35
  br i1 %153, label %147, label %125, !llvm.loop !2639
}

; Function Attrs: inlinehint nobuiltin uwtable
define linkonce_odr dso_local i32 @snprintf(i8* %0, i64 %1, i8* %2, ...) local_unnamed_addr #2 comdat {
  %4 = alloca i8*, align 8
  %5 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #5
  call void @llvm.va_start(i8* nonnull %5)
  %6 = load i8*, i8** %4, align 8, !tbaa !2599
  %7 = call i64* @__local_stdio_printf_options()
  %8 = load i64, i64* %7, align 8, !tbaa !2603
  %9 = or i64 %8, 2
  %10 = call i32 @__stdio_common_vsprintf(i64 %9, i8* %0, i64 %1, i8* %2, %struct.__crt_locale_pointers* null, i8* %6)
  %11 = icmp sgt i32 %10, -1
  %12 = select i1 %11, i32 %10, i32 -1
  call void @llvm.va_end(i8* nonnull %5)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #5
  ret i32 %12
}

declare dso_local i32 @__stdio_common_vsprintf(i64, i8*, i64, i8*, %struct.__crt_locale_pointers*, i8*) local_unnamed_addr #6

; Function Attrs: uwtable
define dso_local void @"$ax.AssignST_WString"(i16* %0, i16* %1) #8 {
  tail call void @"??$$ax.Assign_String@FU$ax.ST_WSTRING@@@@YAXPEAFPEBF@Z"(i16* %0, i16* %1)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr dso_local void @"??$$ax.Assign_String@FU$ax.ST_WSTRING@@@@YAXPEAFPEBF@Z"(i16* %0, i16* %1) local_unnamed_addr #8 comdat {
  %3 = alloca [256 x i8], align 16
  %4 = getelementptr inbounds i16, i16* %1, i64 1
  %5 = load i16, i16* %4, align 2, !tbaa !2626
  %6 = load i16, i16* %1, align 2, !tbaa !2640
  %7 = icmp ugt i16 %5, %6
  br i1 %7, label %8, label %14

8:                                                ; preds = %2
  %9 = zext i16 %5 to i32
  %10 = zext i16 %6 to i32
  %11 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %11) #5
  %12 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %11, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %10, i32 %9, i32 75)
  %13 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %13(i8* nonnull %11)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %11) #5
  br label %14

14:                                               ; preds = %8, %2
  %15 = getelementptr inbounds i16, i16* %0, i64 1
  %16 = load i16, i16* %15, align 2, !tbaa !2626
  %17 = load i16, i16* %0, align 2, !tbaa !2640
  %18 = icmp ugt i16 %16, %17
  br i1 %18, label %19, label %26

19:                                               ; preds = %14
  %20 = zext i16 %16 to i32
  %21 = zext i16 %17 to i32
  %22 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %22) #5
  %23 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %22, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %21, i32 %20, i32 76)
  %24 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %24(i8* nonnull %22)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %22) #5
  %25 = load i16, i16* %0, align 2, !tbaa !2640
  br label %26

26:                                               ; preds = %19, %14
  %27 = phi i16 [ %17, %14 ], [ %25, %19 ]
  %28 = load i16, i16* %4, align 2, !tbaa !2626
  %29 = icmp ult i16 %27, %28
  %30 = select i1 %29, i16 %27, i16 %28
  %31 = getelementptr inbounds i16, i16* %0, i64 2
  %32 = getelementptr inbounds i16, i16* %1, i64 2
  %33 = icmp eq i16 %30, 0
  br i1 %33, label %125, label %34

34:                                               ; preds = %26
  %35 = zext i16 %30 to i64
  %36 = icmp ult i16 %30, 16
  br i1 %36, label %37, label %39

37:                                               ; preds = %123, %39, %34
  %38 = phi i64 [ 0, %39 ], [ 0, %34 ], [ %47, %123 ]
  br label %147

39:                                               ; preds = %34
  %40 = add nuw nsw i64 %35, 2
  %41 = getelementptr i16, i16* %0, i64 %40
  %42 = getelementptr i16, i16* %1, i64 %40
  %43 = icmp ult i16* %31, %42
  %44 = icmp ult i16* %32, %41
  %45 = and i1 %43, %44
  br i1 %45, label %37, label %46

46:                                               ; preds = %39
  %47 = and i64 %35, 65520
  %48 = add nsw i64 %47, -16
  %49 = lshr exact i64 %48, 4
  %50 = add nuw nsw i64 %49, 1
  %51 = and i64 %50, 3
  %52 = icmp ult i64 %48, 48
  br i1 %52, label %104, label %53

53:                                               ; preds = %46
  %54 = sub nsw i64 %50, %51
  br label %55

55:                                               ; preds = %55, %53
  %56 = phi i64 [ 0, %53 ], [ %101, %55 ]
  %57 = phi i64 [ %54, %53 ], [ %102, %55 ]
  %58 = getelementptr inbounds i16, i16* %32, i64 %56
  %59 = bitcast i16* %58 to <8 x i16>*
  %60 = load <8 x i16>, <8 x i16>* %59, align 2, !tbaa !2628, !alias.scope !2641
  %61 = getelementptr inbounds i16, i16* %58, i64 8
  %62 = bitcast i16* %61 to <8 x i16>*
  %63 = load <8 x i16>, <8 x i16>* %62, align 2, !tbaa !2628, !alias.scope !2641
  %64 = getelementptr inbounds i16, i16* %31, i64 %56
  %65 = bitcast i16* %64 to <8 x i16>*
  store <8 x i16> %60, <8 x i16>* %65, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %66 = getelementptr inbounds i16, i16* %64, i64 8
  %67 = bitcast i16* %66 to <8 x i16>*
  store <8 x i16> %63, <8 x i16>* %67, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %68 = or i64 %56, 16
  %69 = getelementptr inbounds i16, i16* %32, i64 %68
  %70 = bitcast i16* %69 to <8 x i16>*
  %71 = load <8 x i16>, <8 x i16>* %70, align 2, !tbaa !2628, !alias.scope !2641
  %72 = getelementptr inbounds i16, i16* %69, i64 8
  %73 = bitcast i16* %72 to <8 x i16>*
  %74 = load <8 x i16>, <8 x i16>* %73, align 2, !tbaa !2628, !alias.scope !2641
  %75 = getelementptr inbounds i16, i16* %31, i64 %68
  %76 = bitcast i16* %75 to <8 x i16>*
  store <8 x i16> %71, <8 x i16>* %76, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %77 = getelementptr inbounds i16, i16* %75, i64 8
  %78 = bitcast i16* %77 to <8 x i16>*
  store <8 x i16> %74, <8 x i16>* %78, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %79 = or i64 %56, 32
  %80 = getelementptr inbounds i16, i16* %32, i64 %79
  %81 = bitcast i16* %80 to <8 x i16>*
  %82 = load <8 x i16>, <8 x i16>* %81, align 2, !tbaa !2628, !alias.scope !2641
  %83 = getelementptr inbounds i16, i16* %80, i64 8
  %84 = bitcast i16* %83 to <8 x i16>*
  %85 = load <8 x i16>, <8 x i16>* %84, align 2, !tbaa !2628, !alias.scope !2641
  %86 = getelementptr inbounds i16, i16* %31, i64 %79
  %87 = bitcast i16* %86 to <8 x i16>*
  store <8 x i16> %82, <8 x i16>* %87, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %88 = getelementptr inbounds i16, i16* %86, i64 8
  %89 = bitcast i16* %88 to <8 x i16>*
  store <8 x i16> %85, <8 x i16>* %89, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %90 = or i64 %56, 48
  %91 = getelementptr inbounds i16, i16* %32, i64 %90
  %92 = bitcast i16* %91 to <8 x i16>*
  %93 = load <8 x i16>, <8 x i16>* %92, align 2, !tbaa !2628, !alias.scope !2641
  %94 = getelementptr inbounds i16, i16* %91, i64 8
  %95 = bitcast i16* %94 to <8 x i16>*
  %96 = load <8 x i16>, <8 x i16>* %95, align 2, !tbaa !2628, !alias.scope !2641
  %97 = getelementptr inbounds i16, i16* %31, i64 %90
  %98 = bitcast i16* %97 to <8 x i16>*
  store <8 x i16> %93, <8 x i16>* %98, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %99 = getelementptr inbounds i16, i16* %97, i64 8
  %100 = bitcast i16* %99 to <8 x i16>*
  store <8 x i16> %96, <8 x i16>* %100, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %101 = add i64 %56, 64
  %102 = add i64 %57, -4
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %104, label %55, !llvm.loop !2646

104:                                              ; preds = %55, %46
  %105 = phi i64 [ 0, %46 ], [ %101, %55 ]
  %106 = icmp eq i64 %51, 0
  br i1 %106, label %123, label %107

107:                                              ; preds = %107, %104
  %108 = phi i64 [ %120, %107 ], [ %105, %104 ]
  %109 = phi i64 [ %121, %107 ], [ %51, %104 ]
  %110 = getelementptr inbounds i16, i16* %32, i64 %108
  %111 = bitcast i16* %110 to <8 x i16>*
  %112 = load <8 x i16>, <8 x i16>* %111, align 2, !tbaa !2628, !alias.scope !2641
  %113 = getelementptr inbounds i16, i16* %110, i64 8
  %114 = bitcast i16* %113 to <8 x i16>*
  %115 = load <8 x i16>, <8 x i16>* %114, align 2, !tbaa !2628, !alias.scope !2641
  %116 = getelementptr inbounds i16, i16* %31, i64 %108
  %117 = bitcast i16* %116 to <8 x i16>*
  store <8 x i16> %112, <8 x i16>* %117, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %118 = getelementptr inbounds i16, i16* %116, i64 8
  %119 = bitcast i16* %118 to <8 x i16>*
  store <8 x i16> %115, <8 x i16>* %119, align 2, !tbaa !2628, !alias.scope !2644, !noalias !2641
  %120 = add i64 %108, 16
  %121 = add i64 %109, -1
  %122 = icmp eq i64 %121, 0
  br i1 %122, label %123, label %107, !llvm.loop !2647

123:                                              ; preds = %107, %104
  %124 = icmp eq i64 %47, %35
  br i1 %124, label %125, label %37

125:                                              ; preds = %147, %123, %26
  %126 = zext i16 %30 to i64
  %127 = getelementptr inbounds i16, i16* %31, i64 %126
  store i16 0, i16* %127, align 2, !tbaa !2628
  store i16 %30, i16* %15, align 2, !tbaa !2626
  %128 = load i16, i16* %4, align 2, !tbaa !2626
  %129 = load i16, i16* %1, align 2, !tbaa !2640
  %130 = icmp ugt i16 %128, %129
  br i1 %130, label %131, label %146

131:                                              ; preds = %125
  %132 = zext i16 %128 to i32
  %133 = zext i16 %129 to i32
  %134 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %134) #5
  %135 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %134, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %133, i32 %132, i32 90)
  %136 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %136(i8* nonnull %134)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %134) #5
  %137 = load i16, i16* %15, align 2, !tbaa !2626
  %138 = load i16, i16* %0, align 2, !tbaa !2640
  %139 = icmp ugt i16 %137, %138
  br i1 %139, label %140, label %146

140:                                              ; preds = %131
  %141 = zext i16 %137 to i32
  %142 = zext i16 %138 to i32
  %143 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %143) #5
  %144 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %143, i64 256, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @"??_C@_0FH@JGBLDNCE@String?5operation?5failed?3?5value?8s@", i64 0, i64 0), i32 %142, i32 %141, i32 91)
  %145 = load void (i8*)*, void (i8*)** @"$ax.throw_exception", align 8, !tbaa !2599
  call void %145(i8* nonnull %143)
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %143) #5
  br label %146

146:                                              ; preds = %140, %131, %125
  ret void

147:                                              ; preds = %147, %37
  %148 = phi i64 [ %152, %147 ], [ %38, %37 ]
  %149 = getelementptr inbounds i16, i16* %32, i64 %148
  %150 = load i16, i16* %149, align 2, !tbaa !2628
  %151 = getelementptr inbounds i16, i16* %31, i64 %148
  store i16 %150, i16* %151, align 2, !tbaa !2628
  %152 = add nuw nsw i64 %148, 1
  %153 = icmp ult i64 %152, %35
  br i1 %153, label %147, label %125, !llvm.loop !2648
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i8 @"$ax.GetAtST_String"(i8* nocapture readonly %0, i8 %1) #9 {
  %3 = zext i8 %1 to i64
  %4 = icmp eq i8 %1, 0
  br i1 %4, label %17, label %5

5:                                                ; preds = %2
  %6 = getelementptr inbounds i8, i8* %0, i64 1
  %7 = load i8, i8* %6, align 1, !tbaa !2623
  %8 = icmp ult i8 %7, %1
  br i1 %8, label %17, label %9

9:                                                ; preds = %5
  %10 = load i8, i8* %0, align 1, !tbaa !2629
  %11 = icmp ult i8 %10, %1
  br i1 %11, label %17, label %12

12:                                               ; preds = %9
  %13 = getelementptr inbounds i8, i8* %0, i64 2
  %14 = add nsw i64 %3, -1
  %15 = getelementptr inbounds i8, i8* %13, i64 %14
  %16 = load i8, i8* %15, align 1, !tbaa !2625
  br label %17

17:                                               ; preds = %12, %9, %5, %2
  %18 = phi i8 [ %16, %12 ], [ 0, %9 ], [ 0, %5 ], [ 0, %2 ]
  ret i8 %18
}

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i16 @"$ax.GetAtST_WString"(i16* nocapture readonly %0, i16 %1) local_unnamed_addr #9 {
  %3 = sext i16 %1 to i32
  %4 = icmp slt i16 %1, 1
  br i1 %4, label %20, label %5

5:                                                ; preds = %2
  %6 = getelementptr inbounds i16, i16* %0, i64 1
  %7 = load i16, i16* %6, align 2, !tbaa !2626
  %8 = zext i16 %7 to i32
  %9 = icmp sgt i32 %3, %8
  br i1 %9, label %20, label %10

10:                                               ; preds = %5
  %11 = load i16, i16* %0, align 2, !tbaa !2640
  %12 = zext i16 %11 to i32
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %20, label %14

14:                                               ; preds = %10
  %15 = getelementptr inbounds i16, i16* %0, i64 2
  %16 = add nsw i32 %3, -1
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i16, i16* %15, i64 %17
  %19 = load i16, i16* %18, align 2, !tbaa !2628
  br label %20

20:                                               ; preds = %14, %10, %5, %2
  %21 = phi i16 [ %19, %14 ], [ 0, %10 ], [ 0, %5 ], [ 0, %2 ]
  ret i16 %21
}

; Function Attrs: nofree norecurse nounwind uwtable
define dso_local void @"$ax.SetAtST_String"(i8* nocapture %0, i8 %1, i8 %2) #10 {
  %4 = zext i8 %1 to i32
  %5 = icmp eq i8 %1, 0
  br i1 %5, label %25, label %6

6:                                                ; preds = %3
  %7 = getelementptr inbounds i8, i8* %0, i64 1
  %8 = load i8, i8* %7, align 1, !tbaa !2623
  %9 = zext i8 %8 to i32
  %10 = add nuw nsw i32 %9, 1
  %11 = icmp ult i32 %10, %4
  br i1 %11, label %25, label %12

12:                                               ; preds = %6
  %13 = load i8, i8* %0, align 1, !tbaa !2629
  %14 = icmp ult i8 %13, %1
  br i1 %14, label %25, label %15

15:                                               ; preds = %12
  %16 = getelementptr inbounds i8, i8* %0, i64 2
  %17 = add nsw i32 %4, -1
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds i8, i8* %16, i64 %18
  store i8 %2, i8* %19, align 1, !tbaa !2625
  %20 = icmp eq i32 %17, %9
  br i1 %20, label %21, label %25

21:                                               ; preds = %15
  %22 = add i8 %8, 1
  store i8 %22, i8* %7, align 1, !tbaa !2623
  %23 = zext i8 %1 to i64
  %24 = getelementptr inbounds i8, i8* %16, i64 %23
  store i8 0, i8* %24, align 1, !tbaa !2625
  br label %25

25:                                               ; preds = %21, %15, %12, %6, %3
  ret void
}

; Function Attrs: nofree norecurse nounwind uwtable
define dso_local void @"$ax.SetAtST_WString"(i16* nocapture %0, i16 %1, i16 %2) local_unnamed_addr #10 {
  %4 = zext i16 %1 to i32
  %5 = icmp eq i16 %1, 0
  br i1 %5, label %25, label %6

6:                                                ; preds = %3
  %7 = getelementptr inbounds i16, i16* %0, i64 1
  %8 = load i16, i16* %7, align 2, !tbaa !2626
  %9 = zext i16 %8 to i32
  %10 = add nuw nsw i32 %9, 1
  %11 = icmp ult i32 %10, %4
  br i1 %11, label %25, label %12

12:                                               ; preds = %6
  %13 = load i16, i16* %0, align 2, !tbaa !2640
  %14 = icmp ult i16 %13, %1
  br i1 %14, label %25, label %15

15:                                               ; preds = %12
  %16 = getelementptr inbounds i16, i16* %0, i64 2
  %17 = add nsw i32 %4, -1
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds i16, i16* %16, i64 %18
  store i16 %2, i16* %19, align 2, !tbaa !2628
  %20 = icmp eq i32 %17, %9
  br i1 %20, label %21, label %25

21:                                               ; preds = %15
  %22 = add i16 %8, 1
  store i16 %22, i16* %7, align 2, !tbaa !2626
  %23 = zext i16 %1 to i64
  %24 = getelementptr inbounds i16, i16* %16, i64 %23
  store i16 0, i16* %24, align 2, !tbaa !2628
  br label %25

25:                                               ; preds = %21, %15, %12, %6, %3
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i8 @"$ax.umod_i8"(i8 %0, i8 %1) local_unnamed_addr #11 {
  %3 = icmp eq i8 %1, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %2
  %5 = urem i8 %0, %1
  br label %6

6:                                                ; preds = %4, %2
  %7 = phi i8 [ %5, %4 ], [ 0, %2 ]
  ret i8 %7
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i16 @"$ax.umod_i16"(i16 %0, i16 %1) local_unnamed_addr #11 {
  %3 = icmp eq i16 %1, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %2
  %5 = urem i16 %0, %1
  br label %6

6:                                                ; preds = %4, %2
  %7 = phi i16 [ %5, %4 ], [ 0, %2 ]
  ret i16 %7
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i32 @"$ax.umod_i32"(i32 %0, i32 %1) local_unnamed_addr #11 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %2
  %5 = urem i32 %0, %1
  br label %6

6:                                                ; preds = %4, %2
  %7 = phi i32 [ %5, %4 ], [ 0, %2 ]
  ret i32 %7
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i64 @"$ax.umod_i64"(i64 %0, i64 %1) #11 {
  %3 = icmp eq i64 %1, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %2
  %5 = urem i64 %0, %1
  br label %6

6:                                                ; preds = %4, %2
  %7 = phi i64 [ %5, %4 ], [ 0, %2 ]
  ret i64 %7
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i8 @"$ax.smod_i8"(i8 %0, i8 %1) local_unnamed_addr #11 {
  %3 = sext i8 %1 to i32
  switch i8 %1, label %6 [
    i8 0, label %10
    i8 -1, label %4
  ]

4:                                                ; preds = %2
  %5 = icmp eq i8 %0, -128
  br i1 %5, label %10, label %6

6:                                                ; preds = %4, %2
  %7 = sext i8 %0 to i32
  %8 = srem i32 %7, %3
  %9 = trunc i32 %8 to i8
  br label %10

10:                                               ; preds = %6, %4, %2
  %11 = phi i8 [ %9, %6 ], [ %1, %2 ], [ 0, %4 ]
  ret i8 %11
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i16 @"$ax.smod_i16"(i16 %0, i16 %1) local_unnamed_addr #11 {
  %3 = sext i16 %1 to i32
  switch i16 %1, label %6 [
    i16 0, label %10
    i16 -1, label %4
  ]

4:                                                ; preds = %2
  %5 = icmp eq i16 %0, -32768
  br i1 %5, label %10, label %6

6:                                                ; preds = %4, %2
  %7 = sext i16 %0 to i32
  %8 = srem i32 %7, %3
  %9 = trunc i32 %8 to i16
  br label %10

10:                                               ; preds = %6, %4, %2
  %11 = phi i16 [ %9, %6 ], [ %1, %2 ], [ 0, %4 ]
  ret i16 %11
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i32 @"$ax.smod_i32"(i32 %0, i32 %1) local_unnamed_addr #11 {
  switch i32 %1, label %5 [
    i32 0, label %7
    i32 -1, label %3
  ]

3:                                                ; preds = %2
  %4 = icmp eq i32 %0, -2147483648
  br i1 %4, label %7, label %5

5:                                                ; preds = %3, %2
  %6 = srem i32 %0, %1
  br label %7

7:                                                ; preds = %5, %3, %2
  %8 = phi i32 [ %6, %5 ], [ %1, %2 ], [ 0, %3 ]
  ret i32 %8
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i64 @"$ax.smod_i64"(i64 %0, i64 %1) #11 {
  switch i64 %1, label %5 [
    i64 0, label %7
    i64 -1, label %3
  ]

3:                                                ; preds = %2
  %4 = icmp eq i64 %0, -9223372036854775808
  br i1 %4, label %7, label %5

5:                                                ; preds = %3, %2
  %6 = srem i64 %0, %1
  br label %7

7:                                                ; preds = %5, %3, %2
  %8 = phi i64 [ %6, %5 ], [ %1, %2 ], [ 0, %3 ]
  ret i64 %8
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i8 @"$ax.sdiv_i8"(i8 %0, i8 %1) local_unnamed_addr #11 {
  %3 = icmp eq i8 %1, -1
  %4 = icmp eq i8 %0, -128
  %5 = and i1 %4, %3
  br i1 %5, label %11, label %6

6:                                                ; preds = %2
  %7 = sext i8 %1 to i32
  %8 = sext i8 %0 to i32
  %9 = sdiv i32 %8, %7
  %10 = trunc i32 %9 to i8
  br label %11

11:                                               ; preds = %6, %2
  %12 = phi i8 [ %10, %6 ], [ -128, %2 ]
  ret i8 %12
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i16 @"$ax.sdiv_i16"(i16 %0, i16 %1) local_unnamed_addr #11 {
  %3 = icmp eq i16 %1, -1
  %4 = icmp eq i16 %0, -32768
  %5 = and i1 %4, %3
  br i1 %5, label %11, label %6

6:                                                ; preds = %2
  %7 = sext i16 %1 to i32
  %8 = sext i16 %0 to i32
  %9 = sdiv i32 %8, %7
  %10 = trunc i32 %9 to i16
  br label %11

11:                                               ; preds = %6, %2
  %12 = phi i16 [ %10, %6 ], [ -32768, %2 ]
  ret i16 %12
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i32 @"$ax.sdiv_i32"(i32 %0, i32 %1) local_unnamed_addr #11 {
  %3 = icmp eq i32 %1, -1
  %4 = icmp eq i32 %0, -2147483648
  %5 = and i1 %4, %3
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = sdiv i32 %0, %1
  br label %8

8:                                                ; preds = %6, %2
  %9 = phi i32 [ %7, %6 ], [ -2147483648, %2 ]
  ret i32 %9
}

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local i64 @"$ax.sdiv_i64"(i64 %0, i64 %1) #11 {
  %3 = icmp eq i64 %1, -1
  %4 = icmp eq i64 %0, -9223372036854775808
  %5 = and i1 %4, %3
  br i1 %5, label %8, label %6

6:                                                ; preds = %2
  %7 = sdiv i64 %0, %1
  br label %8

8:                                                ; preds = %6, %2
  %9 = phi i64 [ %7, %6 ], [ -9223372036854775808, %2 ]
  ret i64 %9
}

; Function Attrs: nounwind readnone uwtable
define dso_local i8 @"$ax.uroundtoeven_f32_i8"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptoui float %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone speculatable willreturn
declare float @llvm.nearbyint.f32(float) #0

; Function Attrs: nounwind readnone uwtable
define dso_local i16 @"$ax.uroundtoeven_f32_i16"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptoui float %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i32 @"$ax.uroundtoeven_f32_i32"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptoui float %2 to i32
  ret i32 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i64 @"$ax.uroundtoeven_f32_i64"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptoui float %2 to i64
  ret i64 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i8 @"$ax.uroundtoeven_f64_i8"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptoui double %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.nearbyint.f64(double) #0

; Function Attrs: nounwind readnone uwtable
define dso_local i16 @"$ax.uroundtoeven_f64_i16"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptoui double %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i32 @"$ax.uroundtoeven_f64_i32"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptoui double %2 to i32
  ret i32 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i64 @"$ax.uroundtoeven_f64_i64"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptoui double %2 to i64
  ret i64 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i8 @"$ax.sroundtoeven_f32_i8"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptosi float %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i16 @"$ax.sroundtoeven_f32_i16"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptosi float %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i32 @"$ax.sroundtoeven_f32_i32"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptosi float %2 to i32
  ret i32 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i64 @"$ax.sroundtoeven_f32_i64"(float %0) local_unnamed_addr #12 {
  %2 = tail call float @llvm.nearbyint.f32(float %0) #5
  %3 = fptosi float %2 to i64
  ret i64 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i8 @"$ax.sroundtoeven_f64_i8"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptosi double %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i16 @"$ax.sroundtoeven_f64_i16"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptosi double %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i32 @"$ax.sroundtoeven_f64_i32"(double %0) #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptosi double %2 to i32
  ret i32 %3
}

; Function Attrs: nounwind readnone uwtable
define dso_local i64 @"$ax.sroundtoeven_f64_i64"(double %0) local_unnamed_addr #12 {
  %2 = tail call double @llvm.nearbyint.f64(double %0) #5
  %3 = fptosi double %2 to i64
  ret i64 %3
}

define float @"System.Math.Clamp$I@V@Float@value?I@V@Float@min?I@V@Float@max"(float %value, float %min, float %max) {
Entry:
  %Clamp.ret = alloca float
  %value.addr = alloca float
  %min.addr = alloca float
  %max.addr = alloca float
  store float 0.000000e+00, float* %Clamp.ret
  store float %value, float* %value.addr
  store float %min, float* %min.addr
  store float %max, float* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  store float %0, float* %Clamp.ret
  %1 = load float, float* %value.addr
  %2 = load float, float* %min.addr
  %3 = fcmp olt float %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load float, float* %value.addr
  %5 = load float, float* %max.addr
  %6 = fcmp ogt float %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load float, float* %Clamp.ret
  ret float %7

bb5:                                              ; preds = %bb1
  %8 = load float, float* %min.addr
  store float %8, float* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load float, float* %max.addr
  store float %9, float* %Clamp.ret
  br label %bb3
}

define double @"System.Math.Clamp$I@V@Double@value?I@V@Double@min?I@V@Double@max"(double %value, double %min, double %max) {
Entry:
  %Clamp.ret = alloca double
  %value.addr = alloca double
  %min.addr = alloca double
  %max.addr = alloca double
  store double 0.000000e+00, double* %Clamp.ret
  store double %value, double* %value.addr
  store double %min, double* %min.addr
  store double %max, double* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  store double %0, double* %Clamp.ret
  %1 = load double, double* %value.addr
  %2 = load double, double* %min.addr
  %3 = fcmp olt double %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load double, double* %value.addr
  %5 = load double, double* %max.addr
  %6 = fcmp ogt double %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load double, double* %Clamp.ret
  ret double %7

bb5:                                              ; preds = %bb1
  %8 = load double, double* %min.addr
  store double %8, double* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load double, double* %max.addr
  store double %9, double* %Clamp.ret
  br label %bb3
}

define i8 @"System.Math.Clamp$I@V@UInt8@value?I@V@UInt8@min?I@V@UInt8@max"(i8 %value, i8 %min, i8 %max) {
Entry:
  %Clamp.ret = alloca i8
  %value.addr = alloca i8
  %min.addr = alloca i8
  %max.addr = alloca i8
  store i8 0, i8* %Clamp.ret
  store i8 %value, i8* %value.addr
  store i8 %min, i8* %min.addr
  store i8 %max, i8* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr
  store i8 %0, i8* %Clamp.ret
  %1 = load i8, i8* %value.addr
  %2 = load i8, i8* %min.addr
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i8, i8* %value.addr
  %5 = load i8, i8* %max.addr
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i8, i8* %Clamp.ret
  ret i8 %7

bb5:                                              ; preds = %bb1
  %8 = load i8, i8* %min.addr
  store i8 %8, i8* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i8, i8* %max.addr
  store i8 %9, i8* %Clamp.ret
  br label %bb3
}

define i16 @"System.Math.Clamp$I@V@UInt16@value?I@V@UInt16@min?I@V@UInt16@max"(i16 %value, i16 %min, i16 %max) {
Entry:
  %Clamp.ret = alloca i16
  %value.addr = alloca i16
  %min.addr = alloca i16
  %max.addr = alloca i16
  store i16 0, i16* %Clamp.ret
  store i16 %value, i16* %value.addr
  store i16 %min, i16* %min.addr
  store i16 %max, i16* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr
  store i16 %0, i16* %Clamp.ret
  %1 = load i16, i16* %value.addr
  %2 = load i16, i16* %min.addr
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i16, i16* %value.addr
  %5 = load i16, i16* %max.addr
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i16, i16* %Clamp.ret
  ret i16 %7

bb5:                                              ; preds = %bb1
  %8 = load i16, i16* %min.addr
  store i16 %8, i16* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i16, i16* %max.addr
  store i16 %9, i16* %Clamp.ret
  br label %bb3
}

define i32 @"System.Math.Clamp$I@V@UInt32@value?I@V@UInt32@min?I@V@UInt32@max"(i32 %value, i32 %min, i32 %max) {
Entry:
  %Clamp.ret = alloca i32
  %value.addr = alloca i32
  %min.addr = alloca i32
  %max.addr = alloca i32
  store i32 0, i32* %Clamp.ret
  store i32 %value, i32* %value.addr
  store i32 %min, i32* %min.addr
  store i32 %max, i32* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr
  store i32 %0, i32* %Clamp.ret
  %1 = load i32, i32* %value.addr
  %2 = load i32, i32* %min.addr
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i32, i32* %value.addr
  %5 = load i32, i32* %max.addr
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i32, i32* %Clamp.ret
  ret i32 %7

bb5:                                              ; preds = %bb1
  %8 = load i32, i32* %min.addr
  store i32 %8, i32* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i32, i32* %max.addr
  store i32 %9, i32* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@UInt64@value?I@V@UInt64@min?I@V@UInt64@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i8 @"System.Math.Clamp$I@V@Int8@value?I@V@Int8@min?I@V@Int8@max"(i8 %value, i8 %min, i8 %max) {
Entry:
  %Clamp.ret = alloca i8
  %value.addr = alloca i8
  %min.addr = alloca i8
  %max.addr = alloca i8
  store i8 0, i8* %Clamp.ret
  store i8 %value, i8* %value.addr
  store i8 %min, i8* %min.addr
  store i8 %max, i8* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr
  store i8 %0, i8* %Clamp.ret
  %1 = load i8, i8* %value.addr
  %2 = load i8, i8* %min.addr
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i8, i8* %value.addr
  %5 = load i8, i8* %max.addr
  %6 = icmp sgt i8 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i8, i8* %Clamp.ret
  ret i8 %7

bb5:                                              ; preds = %bb1
  %8 = load i8, i8* %min.addr
  store i8 %8, i8* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i8, i8* %max.addr
  store i8 %9, i8* %Clamp.ret
  br label %bb3
}

define i16 @"System.Math.Clamp$I@V@Int16@value?I@V@Int16@min?I@V@Int16@max"(i16 %value, i16 %min, i16 %max) {
Entry:
  %Clamp.ret = alloca i16
  %value.addr = alloca i16
  %min.addr = alloca i16
  %max.addr = alloca i16
  store i16 0, i16* %Clamp.ret
  store i16 %value, i16* %value.addr
  store i16 %min, i16* %min.addr
  store i16 %max, i16* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr
  store i16 %0, i16* %Clamp.ret
  %1 = load i16, i16* %value.addr
  %2 = load i16, i16* %min.addr
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i16, i16* %value.addr
  %5 = load i16, i16* %max.addr
  %6 = icmp sgt i16 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i16, i16* %Clamp.ret
  ret i16 %7

bb5:                                              ; preds = %bb1
  %8 = load i16, i16* %min.addr
  store i16 %8, i16* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i16, i16* %max.addr
  store i16 %9, i16* %Clamp.ret
  br label %bb3
}

define i32 @"System.Math.Clamp$I@V@Int32@value?I@V@Int32@min?I@V@Int32@max"(i32 %value, i32 %min, i32 %max) {
Entry:
  %Clamp.ret = alloca i32
  %value.addr = alloca i32
  %min.addr = alloca i32
  %max.addr = alloca i32
  store i32 0, i32* %Clamp.ret
  store i32 %value, i32* %value.addr
  store i32 %min, i32* %min.addr
  store i32 %max, i32* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr
  store i32 %0, i32* %Clamp.ret
  %1 = load i32, i32* %value.addr
  %2 = load i32, i32* %min.addr
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i32, i32* %value.addr
  %5 = load i32, i32* %max.addr
  %6 = icmp sgt i32 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i32, i32* %Clamp.ret
  ret i32 %7

bb5:                                              ; preds = %bb1
  %8 = load i32, i32* %min.addr
  store i32 %8, i32* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i32, i32* %max.addr
  store i32 %9, i32* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@Int64@value?I@V@Int64@min?I@V@Int64@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@TIME@value?I@V@TIME@min?I@V@TIME@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@LTIME@value?I@V@LTIME@min?I@V@LTIME@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i8 @"System.Math.Clamp$I@V@Byte8@value?I@V@Byte8@min?I@V@Byte8@max"(i8 %value, i8 %min, i8 %max) {
Entry:
  %Clamp.ret = alloca i8
  %value.addr = alloca i8
  %min.addr = alloca i8
  %max.addr = alloca i8
  store i8 0, i8* %Clamp.ret
  store i8 %value, i8* %value.addr
  store i8 %min, i8* %min.addr
  store i8 %max, i8* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr
  store i8 %0, i8* %Clamp.ret
  %1 = load i8, i8* %value.addr
  %2 = load i8, i8* %min.addr
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i8, i8* %value.addr
  %5 = load i8, i8* %max.addr
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i8, i8* %Clamp.ret
  ret i8 %7

bb5:                                              ; preds = %bb1
  %8 = load i8, i8* %min.addr
  store i8 %8, i8* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i8, i8* %max.addr
  store i8 %9, i8* %Clamp.ret
  br label %bb3
}

define i16 @"System.Math.Clamp$I@V@Byte16@value?I@V@Byte16@min?I@V@Byte16@max"(i16 %value, i16 %min, i16 %max) {
Entry:
  %Clamp.ret = alloca i16
  %value.addr = alloca i16
  %min.addr = alloca i16
  %max.addr = alloca i16
  store i16 0, i16* %Clamp.ret
  store i16 %value, i16* %value.addr
  store i16 %min, i16* %min.addr
  store i16 %max, i16* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr
  store i16 %0, i16* %Clamp.ret
  %1 = load i16, i16* %value.addr
  %2 = load i16, i16* %min.addr
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i16, i16* %value.addr
  %5 = load i16, i16* %max.addr
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i16, i16* %Clamp.ret
  ret i16 %7

bb5:                                              ; preds = %bb1
  %8 = load i16, i16* %min.addr
  store i16 %8, i16* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i16, i16* %max.addr
  store i16 %9, i16* %Clamp.ret
  br label %bb3
}

define i32 @"System.Math.Clamp$I@V@Byte32@value?I@V@Byte32@min?I@V@Byte32@max"(i32 %value, i32 %min, i32 %max) {
Entry:
  %Clamp.ret = alloca i32
  %value.addr = alloca i32
  %min.addr = alloca i32
  %max.addr = alloca i32
  store i32 0, i32* %Clamp.ret
  store i32 %value, i32* %value.addr
  store i32 %min, i32* %min.addr
  store i32 %max, i32* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr
  store i32 %0, i32* %Clamp.ret
  %1 = load i32, i32* %value.addr
  %2 = load i32, i32* %min.addr
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i32, i32* %value.addr
  %5 = load i32, i32* %max.addr
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i32, i32* %Clamp.ret
  ret i32 %7

bb5:                                              ; preds = %bb1
  %8 = load i32, i32* %min.addr
  store i32 %8, i32* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i32, i32* %max.addr
  store i32 %9, i32* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@Byte64@value?I@V@Byte64@min?I@V@Byte64@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@DATE@value?I@V@DATE@min?I@V@DATE@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@LDATE@value?I@V@LDATE@min?I@V@LDATE@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@TIME_OF_DAY@value?I@V@TIME_OF_DAY@min?I@V@TIME_OF_DAY@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@LTIME_OF_DAY@value?I@V@LTIME_OF_DAY@min?I@V@LTIME_OF_DAY@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@DATE_AND_TIME@value?I@V@DATE_AND_TIME@min?I@V@DATE_AND_TIME@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define i64 @"System.Math.Clamp$I@V@LDATE_AND_TIME@value?I@V@LDATE_AND_TIME@min?I@V@LDATE_AND_TIME@max"(i64 %value, i64 %min, i64 %max) {
Entry:
  %Clamp.ret = alloca i64
  %value.addr = alloca i64
  %min.addr = alloca i64
  %max.addr = alloca i64
  store i64 0, i64* %Clamp.ret
  store i64 %value, i64* %value.addr
  store i64 %min, i64* %min.addr
  store i64 %max, i64* %max.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  store i64 %0, i64* %Clamp.ret
  %1 = load i64, i64* %value.addr
  %2 = load i64, i64* %min.addr
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = load i64, i64* %max.addr
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb6, label %bb3

bb3:                                              ; preds = %bb6, %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %7 = load i64, i64* %Clamp.ret
  ret i64 %7

bb5:                                              ; preds = %bb1
  %8 = load i64, i64* %min.addr
  store i64 %8, i64* %Clamp.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load i64, i64* %max.addr
  store i64 %9, i64* %Clamp.ret
  br label %bb3
}

define float @"System.Math.Max$I@V@Float@value1?I@V@Float@value2"(float %value1, float %value2) {
Entry:
  %Max.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Max.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp ogt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %cur
  store float %4, float* %Max.ret
  %5 = load float, float* %Max.ret
  ret float %5

bb4:                                              ; preds = %bb1
  %6 = load float, float* %value2.addr
  store float %6, float* %cur
  br label %bb2
}

define float @"System.Math.Max$I@V@Float@value1?I@V@Float@value2?I@V@Float@value3"(float %value1, float %value2, float %value3) {
Entry:
  %Max.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %value3.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Max.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float %value3, float* %value3.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp ogt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %value3.addr
  %5 = load float, float* %cur
  %6 = fcmp ogt float %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load float, float* %value2.addr
  store float %7, float* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load float, float* %cur
  store float %8, float* %Max.ret
  %9 = load float, float* %Max.ret
  ret float %9

bb7:                                              ; preds = %bb3
  %10 = load float, float* %value3.addr
  store float %10, float* %cur
  br label %bb5
}

define float @"System.Math.Max$I@V@Float@value1?I@V@Float@value2?I@V@Float@value3?I@V@Float@value4"(float %value1, float %value2, float %value3, float %value4) {
Entry:
  %Max.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %value3.addr = alloca float
  %value4.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Max.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float %value3, float* %value3.addr
  store float %value4, float* %value4.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp ogt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %value3.addr
  %5 = load float, float* %cur
  %6 = fcmp ogt float %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load float, float* %value2.addr
  store float %7, float* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load float, float* %value4.addr
  %9 = load float, float* %cur
  %10 = fcmp ogt float %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load float, float* %value3.addr
  store float %11, float* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load float, float* %cur
  store float %12, float* %Max.ret
  %13 = load float, float* %Max.ret
  ret float %13

bb10:                                             ; preds = %bb6
  %14 = load float, float* %value4.addr
  store float %14, float* %cur
  br label %bb8
}

define double @"System.Math.Max$I@V@Double@value1?I@V@Double@value2"(double %value1, double %value2) {
Entry:
  %Max.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Max.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp ogt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %cur
  store double %4, double* %Max.ret
  %5 = load double, double* %Max.ret
  ret double %5

bb4:                                              ; preds = %bb1
  %6 = load double, double* %value2.addr
  store double %6, double* %cur
  br label %bb2
}

define double @"System.Math.Max$I@V@Double@value1?I@V@Double@value2?I@V@Double@value3"(double %value1, double %value2, double %value3) {
Entry:
  %Max.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %value3.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Max.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double %value3, double* %value3.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp ogt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %value3.addr
  %5 = load double, double* %cur
  %6 = fcmp ogt double %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load double, double* %value2.addr
  store double %7, double* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load double, double* %cur
  store double %8, double* %Max.ret
  %9 = load double, double* %Max.ret
  ret double %9

bb7:                                              ; preds = %bb3
  %10 = load double, double* %value3.addr
  store double %10, double* %cur
  br label %bb5
}

define double @"System.Math.Max$I@V@Double@value1?I@V@Double@value2?I@V@Double@value3?I@V@Double@value4"(double %value1, double %value2, double %value3, double %value4) {
Entry:
  %Max.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %value3.addr = alloca double
  %value4.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Max.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double %value3, double* %value3.addr
  store double %value4, double* %value4.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp ogt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %value3.addr
  %5 = load double, double* %cur
  %6 = fcmp ogt double %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load double, double* %value2.addr
  store double %7, double* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load double, double* %value4.addr
  %9 = load double, double* %cur
  %10 = fcmp ogt double %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load double, double* %value3.addr
  store double %11, double* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load double, double* %cur
  store double %12, double* %Max.ret
  %13 = load double, double* %Max.ret
  ret double %13

bb10:                                             ; preds = %bb6
  %14 = load double, double* %value4.addr
  store double %14, double* %cur
  br label %bb8
}

define i8 @"System.Math.Max$I@V@UInt8@value1?I@V@UInt8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Max.ret
  %5 = load i8, i8* %Max.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Max$I@V@UInt8@value1?I@V@UInt8@value2?I@V@UInt8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Max.ret
  %9 = load i8, i8* %Max.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Max$I@V@UInt8@value1?I@V@UInt8@value2?I@V@UInt8@value3?I@V@UInt8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp ugt i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Max.ret
  %13 = load i8, i8* %Max.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Max$I@V@UInt16@value1?I@V@UInt16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Max.ret
  %5 = load i16, i16* %Max.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Max$I@V@UInt16@value1?I@V@UInt16@value2?I@V@UInt16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Max.ret
  %9 = load i16, i16* %Max.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Max$I@V@UInt16@value1?I@V@UInt16@value2?I@V@UInt16@value3?I@V@UInt16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp ugt i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Max.ret
  %13 = load i16, i16* %Max.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Max$I@V@UInt32@value1?I@V@UInt32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Max.ret
  %5 = load i32, i32* %Max.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Max$I@V@UInt32@value1?I@V@UInt32@value2?I@V@UInt32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Max.ret
  %9 = load i32, i32* %Max.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Max$I@V@UInt32@value1?I@V@UInt32@value2?I@V@UInt32@value3?I@V@UInt32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp ugt i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Max.ret
  %13 = load i32, i32* %Max.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@UInt64@value1?I@V@UInt64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@UInt64@value1?I@V@UInt64@value2?I@V@UInt64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@UInt64@value1?I@V@UInt64@value2?I@V@UInt64@value3?I@V@UInt64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp ugt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i8 @"System.Math.Max$I@V@Int8@value1?I@V@Int8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp sgt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Max.ret
  %5 = load i8, i8* %Max.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Max$I@V@Int8@value1?I@V@Int8@value2?I@V@Int8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp sgt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp sgt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Max.ret
  %9 = load i8, i8* %Max.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Max$I@V@Int8@value1?I@V@Int8@value2?I@V@Int8@value3?I@V@Int8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp sgt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp sgt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp sgt i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Max.ret
  %13 = load i8, i8* %Max.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Max$I@V@Int16@value1?I@V@Int16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp sgt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Max.ret
  %5 = load i16, i16* %Max.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Max$I@V@Int16@value1?I@V@Int16@value2?I@V@Int16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp sgt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp sgt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Max.ret
  %9 = load i16, i16* %Max.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Max$I@V@Int16@value1?I@V@Int16@value2?I@V@Int16@value3?I@V@Int16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp sgt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp sgt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp sgt i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Max.ret
  %13 = load i16, i16* %Max.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Max$I@V@Int32@value1?I@V@Int32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp sgt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Max.ret
  %5 = load i32, i32* %Max.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Max$I@V@Int32@value1?I@V@Int32@value2?I@V@Int32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp sgt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp sgt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Max.ret
  %9 = load i32, i32* %Max.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Max$I@V@Int32@value1?I@V@Int32@value2?I@V@Int32@value3?I@V@Int32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp sgt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp sgt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp sgt i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Max.ret
  %13 = load i32, i32* %Max.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@Int64@value1?I@V@Int64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@Int64@value1?I@V@Int64@value2?I@V@Int64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@Int64@value1?I@V@Int64@value2?I@V@Int64@value3?I@V@Int64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@TIME@value1?I@V@TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@TIME@value1?I@V@TIME@value2?I@V@TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@TIME@value1?I@V@TIME@value2?I@V@TIME@value3?I@V@TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@LTIME@value1?I@V@LTIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@LTIME@value1?I@V@LTIME@value2?I@V@LTIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@LTIME@value1?I@V@LTIME@value2?I@V@LTIME@value3?I@V@LTIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i8 @"System.Math.Max$I@V@Byte8@value1?I@V@Byte8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Max.ret
  %5 = load i8, i8* %Max.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Max$I@V@Byte8@value1?I@V@Byte8@value2?I@V@Byte8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Max.ret
  %9 = load i8, i8* %Max.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Max$I@V@Byte8@value1?I@V@Byte8@value2?I@V@Byte8@value3?I@V@Byte8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Max.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Max.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ugt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ugt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp ugt i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Max.ret
  %13 = load i8, i8* %Max.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Max$I@V@Byte16@value1?I@V@Byte16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Max.ret
  %5 = load i16, i16* %Max.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Max$I@V@Byte16@value1?I@V@Byte16@value2?I@V@Byte16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Max.ret
  %9 = load i16, i16* %Max.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Max$I@V@Byte16@value1?I@V@Byte16@value2?I@V@Byte16@value3?I@V@Byte16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Max.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Max.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ugt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ugt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp ugt i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Max.ret
  %13 = load i16, i16* %Max.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Max$I@V@Byte32@value1?I@V@Byte32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Max.ret
  %5 = load i32, i32* %Max.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Max$I@V@Byte32@value1?I@V@Byte32@value2?I@V@Byte32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Max.ret
  %9 = load i32, i32* %Max.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Max$I@V@Byte32@value1?I@V@Byte32@value2?I@V@Byte32@value3?I@V@Byte32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Max.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Max.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ugt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ugt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp ugt i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Max.ret
  %13 = load i32, i32* %Max.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@Byte64@value1?I@V@Byte64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@Byte64@value1?I@V@Byte64@value2?I@V@Byte64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@Byte64@value1?I@V@Byte64@value2?I@V@Byte64@value3?I@V@Byte64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ugt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ugt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp ugt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@DATE@value1?I@V@DATE@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@DATE@value1?I@V@DATE@value2?I@V@DATE@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@DATE@value1?I@V@DATE@value2?I@V@DATE@value3?I@V@DATE@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@LDATE@value1?I@V@LDATE@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@LDATE@value1?I@V@LDATE@value2?I@V@LDATE@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@LDATE@value1?I@V@LDATE@value2?I@V@LDATE@value3?I@V@LDATE@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2?I@V@TIME_OF_DAY@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2?I@V@TIME_OF_DAY@value3?I@V@TIME_OF_DAY@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2?I@V@LTIME_OF_DAY@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2?I@V@LTIME_OF_DAY@value3?I@V@LTIME_OF_DAY@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2?I@V@DATE_AND_TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2?I@V@DATE_AND_TIME@value3?I@V@DATE_AND_TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Max$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Max.ret
  %5 = load i64, i64* %Max.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Max$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2?I@V@LDATE_AND_TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Max.ret
  %9 = load i64, i64* %Max.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Max$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2?I@V@LDATE_AND_TIME@value3?I@V@LDATE_AND_TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Max.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Max.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp sgt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp sgt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp sgt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Max.ret
  %13 = load i64, i64* %Max.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define float @"System.Math.Min$I@V@Float@value1?I@V@Float@value2"(float %value1, float %value2) {
Entry:
  %Min.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Min.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp olt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %cur
  store float %4, float* %Min.ret
  %5 = load float, float* %Min.ret
  ret float %5

bb4:                                              ; preds = %bb1
  %6 = load float, float* %value2.addr
  store float %6, float* %cur
  br label %bb2
}

define float @"System.Math.Min$I@V@Float@value1?I@V@Float@value2?I@V@Float@value3"(float %value1, float %value2, float %value3) {
Entry:
  %Min.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %value3.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Min.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float %value3, float* %value3.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp olt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %value3.addr
  %5 = load float, float* %cur
  %6 = fcmp olt float %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load float, float* %value2.addr
  store float %7, float* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load float, float* %cur
  store float %8, float* %Min.ret
  %9 = load float, float* %Min.ret
  ret float %9

bb7:                                              ; preds = %bb3
  %10 = load float, float* %value3.addr
  store float %10, float* %cur
  br label %bb5
}

define float @"System.Math.Min$I@V@Float@value1?I@V@Float@value2?I@V@Float@value3?I@V@Float@value4"(float %value1, float %value2, float %value3, float %value4) {
Entry:
  %Min.ret = alloca float
  %value1.addr = alloca float
  %value2.addr = alloca float
  %value3.addr = alloca float
  %value4.addr = alloca float
  %cur = alloca float
  store float 0.000000e+00, float* %Min.ret
  store float %value1, float* %value1.addr
  store float %value2, float* %value2.addr
  store float %value3, float* %value3.addr
  store float %value4, float* %value4.addr
  store float 0.000000e+00, float* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value1.addr
  store float %0, float* %cur
  %1 = load float, float* %value2.addr
  %2 = load float, float* %cur
  %3 = fcmp olt float %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load float, float* %value3.addr
  %5 = load float, float* %cur
  %6 = fcmp olt float %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load float, float* %value2.addr
  store float %7, float* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load float, float* %value4.addr
  %9 = load float, float* %cur
  %10 = fcmp olt float %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load float, float* %value3.addr
  store float %11, float* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load float, float* %cur
  store float %12, float* %Min.ret
  %13 = load float, float* %Min.ret
  ret float %13

bb10:                                             ; preds = %bb6
  %14 = load float, float* %value4.addr
  store float %14, float* %cur
  br label %bb8
}

define double @"System.Math.Min$I@V@Double@value1?I@V@Double@value2"(double %value1, double %value2) {
Entry:
  %Min.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Min.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp olt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %cur
  store double %4, double* %Min.ret
  %5 = load double, double* %Min.ret
  ret double %5

bb4:                                              ; preds = %bb1
  %6 = load double, double* %value2.addr
  store double %6, double* %cur
  br label %bb2
}

define double @"System.Math.Min$I@V@Double@value1?I@V@Double@value2?I@V@Double@value3"(double %value1, double %value2, double %value3) {
Entry:
  %Min.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %value3.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Min.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double %value3, double* %value3.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp olt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %value3.addr
  %5 = load double, double* %cur
  %6 = fcmp olt double %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load double, double* %value2.addr
  store double %7, double* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load double, double* %cur
  store double %8, double* %Min.ret
  %9 = load double, double* %Min.ret
  ret double %9

bb7:                                              ; preds = %bb3
  %10 = load double, double* %value3.addr
  store double %10, double* %cur
  br label %bb5
}

define double @"System.Math.Min$I@V@Double@value1?I@V@Double@value2?I@V@Double@value3?I@V@Double@value4"(double %value1, double %value2, double %value3, double %value4) {
Entry:
  %Min.ret = alloca double
  %value1.addr = alloca double
  %value2.addr = alloca double
  %value3.addr = alloca double
  %value4.addr = alloca double
  %cur = alloca double
  store double 0.000000e+00, double* %Min.ret
  store double %value1, double* %value1.addr
  store double %value2, double* %value2.addr
  store double %value3, double* %value3.addr
  store double %value4, double* %value4.addr
  store double 0.000000e+00, double* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value1.addr
  store double %0, double* %cur
  %1 = load double, double* %value2.addr
  %2 = load double, double* %cur
  %3 = fcmp olt double %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load double, double* %value3.addr
  %5 = load double, double* %cur
  %6 = fcmp olt double %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load double, double* %value2.addr
  store double %7, double* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load double, double* %value4.addr
  %9 = load double, double* %cur
  %10 = fcmp olt double %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load double, double* %value3.addr
  store double %11, double* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load double, double* %cur
  store double %12, double* %Min.ret
  %13 = load double, double* %Min.ret
  ret double %13

bb10:                                             ; preds = %bb6
  %14 = load double, double* %value4.addr
  store double %14, double* %cur
  br label %bb8
}

define i8 @"System.Math.Min$I@V@UInt8@value1?I@V@UInt8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Min.ret
  %5 = load i8, i8* %Min.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Min$I@V@UInt8@value1?I@V@UInt8@value2?I@V@UInt8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ult i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Min.ret
  %9 = load i8, i8* %Min.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Min$I@V@UInt8@value1?I@V@UInt8@value2?I@V@UInt8@value3?I@V@UInt8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ult i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp ult i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Min.ret
  %13 = load i8, i8* %Min.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Min$I@V@UInt16@value1?I@V@UInt16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Min.ret
  %5 = load i16, i16* %Min.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Min$I@V@UInt16@value1?I@V@UInt16@value2?I@V@UInt16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ult i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Min.ret
  %9 = load i16, i16* %Min.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Min$I@V@UInt16@value1?I@V@UInt16@value2?I@V@UInt16@value3?I@V@UInt16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ult i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp ult i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Min.ret
  %13 = load i16, i16* %Min.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Min$I@V@UInt32@value1?I@V@UInt32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Min.ret
  %5 = load i32, i32* %Min.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Min$I@V@UInt32@value1?I@V@UInt32@value2?I@V@UInt32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ult i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Min.ret
  %9 = load i32, i32* %Min.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Min$I@V@UInt32@value1?I@V@UInt32@value2?I@V@UInt32@value3?I@V@UInt32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ult i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp ult i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Min.ret
  %13 = load i32, i32* %Min.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@UInt64@value1?I@V@UInt64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@UInt64@value1?I@V@UInt64@value2?I@V@UInt64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ult i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@UInt64@value1?I@V@UInt64@value2?I@V@UInt64@value3?I@V@UInt64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ult i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp ult i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i8 @"System.Math.Min$I@V@Int8@value1?I@V@Int8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Min.ret
  %5 = load i8, i8* %Min.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Min$I@V@Int8@value1?I@V@Int8@value2?I@V@Int8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp slt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Min.ret
  %9 = load i8, i8* %Min.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Min$I@V@Int8@value1?I@V@Int8@value2?I@V@Int8@value3?I@V@Int8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp slt i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp slt i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Min.ret
  %13 = load i8, i8* %Min.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Min$I@V@Int16@value1?I@V@Int16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Min.ret
  %5 = load i16, i16* %Min.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Min$I@V@Int16@value1?I@V@Int16@value2?I@V@Int16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp slt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Min.ret
  %9 = load i16, i16* %Min.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Min$I@V@Int16@value1?I@V@Int16@value2?I@V@Int16@value3?I@V@Int16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp slt i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp slt i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Min.ret
  %13 = load i16, i16* %Min.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Min$I@V@Int32@value1?I@V@Int32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Min.ret
  %5 = load i32, i32* %Min.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Min$I@V@Int32@value1?I@V@Int32@value2?I@V@Int32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp slt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Min.ret
  %9 = load i32, i32* %Min.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Min$I@V@Int32@value1?I@V@Int32@value2?I@V@Int32@value3?I@V@Int32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp slt i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Min.ret
  %13 = load i32, i32* %Min.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@Int64@value1?I@V@Int64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@Int64@value1?I@V@Int64@value2?I@V@Int64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@Int64@value1?I@V@Int64@value2?I@V@Int64@value3?I@V@Int64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@TIME@value1?I@V@TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@TIME@value1?I@V@TIME@value2?I@V@TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@TIME@value1?I@V@TIME@value2?I@V@TIME@value3?I@V@TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@LTIME@value1?I@V@LTIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@LTIME@value1?I@V@LTIME@value2?I@V@LTIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@LTIME@value1?I@V@LTIME@value2?I@V@LTIME@value3?I@V@LTIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i8 @"System.Math.Min$I@V@Byte8@value1?I@V@Byte8@value2"(i8 %value1, i8 %value2) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %cur
  store i8 %4, i8* %Min.ret
  %5 = load i8, i8* %Min.ret
  ret i8 %5

bb4:                                              ; preds = %bb1
  %6 = load i8, i8* %value2.addr
  store i8 %6, i8* %cur
  br label %bb2
}

define i8 @"System.Math.Min$I@V@Byte8@value1?I@V@Byte8@value2?I@V@Byte8@value3"(i8 %value1, i8 %value2, i8 %value3) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ult i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %cur
  store i8 %8, i8* %Min.ret
  %9 = load i8, i8* %Min.ret
  ret i8 %9

bb7:                                              ; preds = %bb3
  %10 = load i8, i8* %value3.addr
  store i8 %10, i8* %cur
  br label %bb5
}

define i8 @"System.Math.Min$I@V@Byte8@value1?I@V@Byte8@value2?I@V@Byte8@value3?I@V@Byte8@value4"(i8 %value1, i8 %value2, i8 %value3, i8 %value4) {
Entry:
  %Min.ret = alloca i8
  %value1.addr = alloca i8
  %value2.addr = alloca i8
  %value3.addr = alloca i8
  %value4.addr = alloca i8
  %cur = alloca i8
  store i8 0, i8* %Min.ret
  store i8 %value1, i8* %value1.addr
  store i8 %value2, i8* %value2.addr
  store i8 %value3, i8* %value3.addr
  store i8 %value4, i8* %value4.addr
  store i8 0, i8* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value1.addr
  store i8 %0, i8* %cur
  %1 = load i8, i8* %value2.addr
  %2 = load i8, i8* %cur
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i8, i8* %value3.addr
  %5 = load i8, i8* %cur
  %6 = icmp ult i8 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i8, i8* %value2.addr
  store i8 %7, i8* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i8, i8* %value4.addr
  %9 = load i8, i8* %cur
  %10 = icmp ult i8 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i8, i8* %value3.addr
  store i8 %11, i8* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i8, i8* %cur
  store i8 %12, i8* %Min.ret
  %13 = load i8, i8* %Min.ret
  ret i8 %13

bb10:                                             ; preds = %bb6
  %14 = load i8, i8* %value4.addr
  store i8 %14, i8* %cur
  br label %bb8
}

define i16 @"System.Math.Min$I@V@Byte16@value1?I@V@Byte16@value2"(i16 %value1, i16 %value2) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %cur
  store i16 %4, i16* %Min.ret
  %5 = load i16, i16* %Min.ret
  ret i16 %5

bb4:                                              ; preds = %bb1
  %6 = load i16, i16* %value2.addr
  store i16 %6, i16* %cur
  br label %bb2
}

define i16 @"System.Math.Min$I@V@Byte16@value1?I@V@Byte16@value2?I@V@Byte16@value3"(i16 %value1, i16 %value2, i16 %value3) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ult i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %cur
  store i16 %8, i16* %Min.ret
  %9 = load i16, i16* %Min.ret
  ret i16 %9

bb7:                                              ; preds = %bb3
  %10 = load i16, i16* %value3.addr
  store i16 %10, i16* %cur
  br label %bb5
}

define i16 @"System.Math.Min$I@V@Byte16@value1?I@V@Byte16@value2?I@V@Byte16@value3?I@V@Byte16@value4"(i16 %value1, i16 %value2, i16 %value3, i16 %value4) {
Entry:
  %Min.ret = alloca i16
  %value1.addr = alloca i16
  %value2.addr = alloca i16
  %value3.addr = alloca i16
  %value4.addr = alloca i16
  %cur = alloca i16
  store i16 0, i16* %Min.ret
  store i16 %value1, i16* %value1.addr
  store i16 %value2, i16* %value2.addr
  store i16 %value3, i16* %value3.addr
  store i16 %value4, i16* %value4.addr
  store i16 0, i16* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value1.addr
  store i16 %0, i16* %cur
  %1 = load i16, i16* %value2.addr
  %2 = load i16, i16* %cur
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i16, i16* %value3.addr
  %5 = load i16, i16* %cur
  %6 = icmp ult i16 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i16, i16* %value2.addr
  store i16 %7, i16* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i16, i16* %value4.addr
  %9 = load i16, i16* %cur
  %10 = icmp ult i16 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i16, i16* %value3.addr
  store i16 %11, i16* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i16, i16* %cur
  store i16 %12, i16* %Min.ret
  %13 = load i16, i16* %Min.ret
  ret i16 %13

bb10:                                             ; preds = %bb6
  %14 = load i16, i16* %value4.addr
  store i16 %14, i16* %cur
  br label %bb8
}

define i32 @"System.Math.Min$I@V@Byte32@value1?I@V@Byte32@value2"(i32 %value1, i32 %value2) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %cur
  store i32 %4, i32* %Min.ret
  %5 = load i32, i32* %Min.ret
  ret i32 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %value2.addr
  store i32 %6, i32* %cur
  br label %bb2
}

define i32 @"System.Math.Min$I@V@Byte32@value1?I@V@Byte32@value2?I@V@Byte32@value3"(i32 %value1, i32 %value2, i32 %value3) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ult i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %cur
  store i32 %8, i32* %Min.ret
  %9 = load i32, i32* %Min.ret
  ret i32 %9

bb7:                                              ; preds = %bb3
  %10 = load i32, i32* %value3.addr
  store i32 %10, i32* %cur
  br label %bb5
}

define i32 @"System.Math.Min$I@V@Byte32@value1?I@V@Byte32@value2?I@V@Byte32@value3?I@V@Byte32@value4"(i32 %value1, i32 %value2, i32 %value3, i32 %value4) {
Entry:
  %Min.ret = alloca i32
  %value1.addr = alloca i32
  %value2.addr = alloca i32
  %value3.addr = alloca i32
  %value4.addr = alloca i32
  %cur = alloca i32
  store i32 0, i32* %Min.ret
  store i32 %value1, i32* %value1.addr
  store i32 %value2, i32* %value2.addr
  store i32 %value3, i32* %value3.addr
  store i32 %value4, i32* %value4.addr
  store i32 0, i32* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value1.addr
  store i32 %0, i32* %cur
  %1 = load i32, i32* %value2.addr
  %2 = load i32, i32* %cur
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i32, i32* %value3.addr
  %5 = load i32, i32* %cur
  %6 = icmp ult i32 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i32, i32* %value2.addr
  store i32 %7, i32* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i32, i32* %value4.addr
  %9 = load i32, i32* %cur
  %10 = icmp ult i32 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i32, i32* %value3.addr
  store i32 %11, i32* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i32, i32* %cur
  store i32 %12, i32* %Min.ret
  %13 = load i32, i32* %Min.ret
  ret i32 %13

bb10:                                             ; preds = %bb6
  %14 = load i32, i32* %value4.addr
  store i32 %14, i32* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@Byte64@value1?I@V@Byte64@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@Byte64@value1?I@V@Byte64@value2?I@V@Byte64@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ult i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@Byte64@value1?I@V@Byte64@value2?I@V@Byte64@value3?I@V@Byte64@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp ult i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp ult i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@DATE@value1?I@V@DATE@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@DATE@value1?I@V@DATE@value2?I@V@DATE@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@DATE@value1?I@V@DATE@value2?I@V@DATE@value3?I@V@DATE@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@LDATE@value1?I@V@LDATE@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@LDATE@value1?I@V@LDATE@value2?I@V@LDATE@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@LDATE@value1?I@V@LDATE@value2?I@V@LDATE@value3?I@V@LDATE@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2?I@V@TIME_OF_DAY@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@TIME_OF_DAY@value1?I@V@TIME_OF_DAY@value2?I@V@TIME_OF_DAY@value3?I@V@TIME_OF_DAY@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2?I@V@LTIME_OF_DAY@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@LTIME_OF_DAY@value1?I@V@LTIME_OF_DAY@value2?I@V@LTIME_OF_DAY@value3?I@V@LTIME_OF_DAY@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2?I@V@DATE_AND_TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@DATE_AND_TIME@value1?I@V@DATE_AND_TIME@value2?I@V@DATE_AND_TIME@value3?I@V@DATE_AND_TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i64 @"System.Math.Min$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2"(i64 %value1, i64 %value2) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %cur
  store i64 %4, i64* %Min.ret
  %5 = load i64, i64* %Min.ret
  ret i64 %5

bb4:                                              ; preds = %bb1
  %6 = load i64, i64* %value2.addr
  store i64 %6, i64* %cur
  br label %bb2
}

define i64 @"System.Math.Min$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2?I@V@LDATE_AND_TIME@value3"(i64 %value1, i64 %value2, i64 %value3) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %cur
  store i64 %8, i64* %Min.ret
  %9 = load i64, i64* %Min.ret
  ret i64 %9

bb7:                                              ; preds = %bb3
  %10 = load i64, i64* %value3.addr
  store i64 %10, i64* %cur
  br label %bb5
}

define i64 @"System.Math.Min$I@V@LDATE_AND_TIME@value1?I@V@LDATE_AND_TIME@value2?I@V@LDATE_AND_TIME@value3?I@V@LDATE_AND_TIME@value4"(i64 %value1, i64 %value2, i64 %value3, i64 %value4) {
Entry:
  %Min.ret = alloca i64
  %value1.addr = alloca i64
  %value2.addr = alloca i64
  %value3.addr = alloca i64
  %value4.addr = alloca i64
  %cur = alloca i64
  store i64 0, i64* %Min.ret
  store i64 %value1, i64* %value1.addr
  store i64 %value2, i64* %value2.addr
  store i64 %value3, i64* %value3.addr
  store i64 %value4, i64* %value4.addr
  store i64 0, i64* %cur
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value1.addr
  store i64 %0, i64* %cur
  %1 = load i64, i64* %value2.addr
  %2 = load i64, i64* %cur
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %4 = load i64, i64* %value3.addr
  %5 = load i64, i64* %cur
  %6 = icmp slt i64 %4, %5
  br i1 %6, label %bb7, label %bb5

bb4:                                              ; preds = %bb1
  %7 = load i64, i64* %value2.addr
  store i64 %7, i64* %cur
  br label %bb2

bb5:                                              ; preds = %bb7, %bb3
  br label %bb6

bb6:                                              ; preds = %bb5
  %8 = load i64, i64* %value4.addr
  %9 = load i64, i64* %cur
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %bb10, label %bb8

bb7:                                              ; preds = %bb3
  %11 = load i64, i64* %value3.addr
  store i64 %11, i64* %cur
  br label %bb5

bb8:                                              ; preds = %bb10, %bb6
  br label %bb9

bb9:                                              ; preds = %bb8
  %12 = load i64, i64* %cur
  store i64 %12, i64* %Min.ret
  %13 = load i64, i64* %Min.ret
  ret i64 %13

bb10:                                             ; preds = %bb6
  %14 = load i64, i64* %value4.addr
  store i64 %14, i64* %cur
  br label %bb8
}

define i16 @"System.Math.Abs$I@V@Int16@value"(i16 %value) {
Entry:
  %Abs.ret = alloca i16
  %value.addr = alloca i16
  store i16 0, i16* %Abs.ret
  store i16 %value, i16* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i16, i16* %value.addr
  %1 = icmp slt i16 %0, 0
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load i16, i16* %value.addr
  store i16 %2, i16* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load i16, i16* %Abs.ret
  ret i16 %3

bb5:                                              ; preds = %bb1
  %4 = load i16, i16* %value.addr
  %5 = sub i16 0, %4
  store i16 %5, i16* %Abs.ret
  br label %bb3
}

define i8 @"System.Math.Abs$I@V@Int8@value"(i8 %value) {
Entry:
  %Abs.ret = alloca i8
  %value.addr = alloca i8
  store i8 0, i8* %Abs.ret
  store i8 %value, i8* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i8, i8* %value.addr
  %1 = icmp slt i8 %0, 0
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load i8, i8* %value.addr
  store i8 %2, i8* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load i8, i8* %Abs.ret
  ret i8 %3

bb5:                                              ; preds = %bb1
  %4 = load i8, i8* %value.addr
  %5 = sub i8 0, %4
  store i8 %5, i8* %Abs.ret
  br label %bb3
}

define i32 @"System.Math.Abs$I@V@Int32@value"(i32 %value) {
Entry:
  %Abs.ret = alloca i32
  %value.addr = alloca i32
  store i32 0, i32* %Abs.ret
  store i32 %value, i32* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %value.addr
  %1 = icmp slt i32 %0, 0
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load i32, i32* %value.addr
  store i32 %2, i32* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load i32, i32* %Abs.ret
  ret i32 %3

bb5:                                              ; preds = %bb1
  %4 = load i32, i32* %value.addr
  %5 = sub i32 0, %4
  store i32 %5, i32* %Abs.ret
  br label %bb3
}

define i64 @"System.Math.Abs$I@V@Int64@value"(i64 %value) {
Entry:
  %Abs.ret = alloca i64
  %value.addr = alloca i64
  store i64 0, i64* %Abs.ret
  store i64 %value, i64* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i64, i64* %value.addr
  %1 = icmp slt i64 %0, 0
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load i64, i64* %value.addr
  store i64 %2, i64* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load i64, i64* %Abs.ret
  ret i64 %3

bb5:                                              ; preds = %bb1
  %4 = load i64, i64* %value.addr
  %5 = sub i64 0, %4
  store i64 %5, i64* %Abs.ret
  br label %bb3
}

define float @"System.Math.Abs$I@V@Float@value"(float %value) {
Entry:
  %Abs.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Abs.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fcmp olt float %0, 0.000000e+00
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load float, float* %value.addr
  store float %2, float* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load float, float* %Abs.ret
  ret float %3

bb5:                                              ; preds = %bb1
  %4 = load float, float* %value.addr
  %5 = fsub float 0.000000e+00, %4
  store float %5, float* %Abs.ret
  br label %bb3
}

define double @"System.Math.Abs$I@V@Double@value"(double %value) {
Entry:
  %Abs.ret = alloca double
  %value.addr = alloca double
  store double 0.000000e+00, double* %Abs.ret
  store double %value, double* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = fcmp olt double %0, 0.000000e+00
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load double, double* %value.addr
  store double %2, double* %Abs.ret
  br label %bb3

bb3:                                              ; preds = %bb5, %bb2
  br label %bb4

bb4:                                              ; preds = %bb3
  %3 = load double, double* %Abs.ret
  ret double %3

bb5:                                              ; preds = %bb1
  %4 = load double, double* %value.addr
  %5 = fsub double 0.000000e+00, %4
  store double %5, double* %Abs.ret
  br label %bb3
}

define float @"System.Math.Acos$I@V@Float@value"(float %value) {
Entry:
  %Acos.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Acos.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Acos$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Acos.ret
  %4 = load float, float* %Acos.ret
  ret float %4
}

define double @"System.Math.Acos$I@V@Double@value"(double %value) {
Entry:
  %Acos.ret = alloca double
  %value.addr = alloca double
  %hx = alloca i32
  %ix = alloca i32
  %z = alloca double
  %p = alloca double
  %q = alloca double
  %r = alloca double
  %w = alloca double
  %s = alloca double
  %c = alloca double
  %df = alloca double
  store double 0.000000e+00, double* %Acos.ret
  store double %value, double* %value.addr
  store i32 0, i32* %hx
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %p
  store double 0.000000e+00, double* %q
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %s
  store double 0.000000e+00, double* %c
  store double 0.000000e+00, double* %df
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, 2147483647
  store i32 %6, i32* %ix
  %7 = load i32, i32* %ix
  %8 = icmp uge i32 %7, 1072693248
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb13, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %ix
  %10 = icmp ult i32 %9, 1071644672
  br i1 %10, label %bb16, label %bb14

bb4:                                              ; preds = %bb1
  %11 = load i32, i32* %ix
  %12 = sub i32 %11, 1072693248
  %13 = load double, double* %value.addr
  %14 = bitcast double %13 to i64
  %15 = and i64 %14, 4294967295
  %16 = lshr i64 %15, 0
  %17 = trunc i64 %16 to i32
  %18 = or i32 %12, %17
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %bb8, label %bb5

bb5:                                              ; preds = %bb4
  %20 = load double, double* %value.addr
  %21 = load double, double* %value.addr
  %22 = fsub double %20, %21
  %23 = load double, double* %value.addr
  %24 = load double, double* %value.addr
  %25 = fsub double %23, %24
  %26 = fdiv double %22, %25
  store double %26, double* %Acos.ret
  br label %bb6

bb6:                                              ; preds = %bb11, %bb5
  br label %bb7

bb7:                                              ; preds = %bb6
  %27 = load double, double* %Acos.ret
  ret double %27

bb8:                                              ; preds = %bb4
  %28 = load i32, i32* %hx
  %29 = and i32 %28, -2147483648
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %bb12, label %bb9

bb9:                                              ; preds = %bb8
  store double 0.000000e+00, double* %Acos.ret
  br label %bb10

bb10:                                             ; preds = %bb12, %bb9
  br label %bb11

bb11:                                             ; preds = %bb10
  br label %bb6

bb12:                                             ; preds = %bb8
  store double 0x400921FB54442D18, double* %Acos.ret
  br label %bb10

bb13:                                             ; No predecessors!
  br label %bb2

bb14:                                             ; preds = %bb21, %bb3
  br label %bb15

bb15:                                             ; preds = %bb14
  %31 = load i32, i32* %hx
  %32 = and i32 %31, -2147483648
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %bb25, label %bb22

bb16:                                             ; preds = %bb3
  %34 = load i32, i32* %ix
  %35 = icmp ule i32 %34, 1012924416
  br i1 %35, label %bb19, label %bb17

bb17:                                             ; preds = %bb20, %bb16
  br label %bb18

bb18:                                             ; preds = %bb17
  %36 = load double, double* %value.addr
  %37 = load double, double* %value.addr
  %38 = fmul double %36, %37
  store double %38, double* %z
  %39 = load double, double* %z
  %40 = fmul double %39, 0x3F023DE10DFDF709
  %41 = fadd double 0x3F49EFE07501B288, %40
  %42 = load double, double* %z
  %43 = fmul double %42, %41
  %44 = fadd double 0xBFA48228B5688F3B, %43
  %45 = load double, double* %z
  %46 = fmul double %45, %44
  %47 = fadd double 0x3FC9C1550E884455, %46
  %48 = load double, double* %z
  %49 = fmul double %48, %47
  %50 = fadd double 0xBFD4D61203EB6F7D, %49
  %51 = load double, double* %z
  %52 = fmul double %51, %50
  %53 = fadd double 0x3FC5555555555555, %52
  %54 = load double, double* %z
  %55 = fmul double %54, %53
  store double %55, double* %p
  %56 = load double, double* %z
  %57 = fmul double %56, 0x3FB3B8C5B12E9282
  %58 = fadd double 0xBFE6066C1B8D0159, %57
  %59 = load double, double* %z
  %60 = fmul double %59, %58
  %61 = fadd double 0x40002AE59C598AC8, %60
  %62 = load double, double* %z
  %63 = fmul double %62, %61
  %64 = fadd double 0xC0033A271C8A2D4B, %63
  %65 = load double, double* %z
  %66 = fmul double %65, %64
  %67 = fadd double 1.000000e+00, %66
  store double %67, double* %q
  %68 = load double, double* %p
  %69 = load double, double* %q
  %70 = fdiv double %68, %69
  store double %70, double* %r
  %71 = load double, double* %value.addr
  %72 = load double, double* %r
  %73 = fmul double %71, %72
  %74 = fsub double 0x3C91A62633145C07, %73
  %75 = load double, double* %value.addr
  %76 = fsub double %75, %74
  %77 = fsub double 0x3FF921FB54442D18, %76
  store double %77, double* %Acos.ret
  %78 = load double, double* %Acos.ret
  ret double %78

bb19:                                             ; preds = %bb16
  store double 0x3FF921FB54442D18, double* %Acos.ret
  %79 = load double, double* %Acos.ret
  ret double %79

bb20:                                             ; No predecessors!
  br label %bb17

bb21:                                             ; No predecessors!
  br label %bb14

bb22:                                             ; preds = %bb15
  %80 = load double, double* %value.addr
  %81 = fsub double 1.000000e+00, %80
  %82 = fmul double %81, 5.000000e-01
  store double %82, double* %z
  %83 = load double, double* %z
  %84 = call double @"System.Math.Sqrt$I@V@Double@value"(double %83)
  store double %84, double* %s
  %85 = load double, double* %s
  store double %85, double* %df
  %86 = load double, double* %df
  %87 = bitcast double %86 to i64
  %88 = and i64 %87, -4294967296
  %89 = bitcast i64 %88 to double
  store double %89, double* %df
  %90 = load double, double* %df
  %91 = load double, double* %df
  %92 = fmul double %90, %91
  %93 = load double, double* %z
  %94 = fsub double %93, %92
  %95 = load double, double* %s
  %96 = load double, double* %df
  %97 = fadd double %95, %96
  %98 = fdiv double %94, %97
  store double %98, double* %c
  %99 = load double, double* %z
  %100 = fmul double %99, 0x3F023DE10DFDF709
  %101 = fadd double 0x3F49EFE07501B288, %100
  %102 = load double, double* %z
  %103 = fmul double %102, %101
  %104 = fadd double 0xBFA48228B5688F3B, %103
  %105 = load double, double* %z
  %106 = fmul double %105, %104
  %107 = fadd double 0x3FC9C1550E884455, %106
  %108 = load double, double* %z
  %109 = fmul double %108, %107
  %110 = fadd double 0xBFD4D61203EB6F7D, %109
  %111 = load double, double* %z
  %112 = fmul double %111, %110
  %113 = fadd double 0x3FC5555555555555, %112
  %114 = load double, double* %z
  %115 = fmul double %114, %113
  store double %115, double* %p
  %116 = load double, double* %z
  %117 = fmul double %116, 0x3FB3B8C5B12E9282
  %118 = fadd double 0xBFE6066C1B8D0159, %117
  %119 = load double, double* %z
  %120 = fmul double %119, %118
  %121 = fadd double 0x40002AE59C598AC8, %120
  %122 = load double, double* %z
  %123 = fmul double %122, %121
  %124 = fadd double 0xC0033A271C8A2D4B, %123
  %125 = load double, double* %z
  %126 = fmul double %125, %124
  %127 = fadd double 1.000000e+00, %126
  store double %127, double* %q
  %128 = load double, double* %p
  %129 = load double, double* %q
  %130 = fdiv double %128, %129
  store double %130, double* %r
  %131 = load double, double* %r
  %132 = load double, double* %s
  %133 = fmul double %131, %132
  %134 = load double, double* %c
  %135 = fadd double %133, %134
  store double %135, double* %w
  %136 = load double, double* %df
  %137 = load double, double* %w
  %138 = fadd double %136, %137
  %139 = fmul double 2.000000e+00, %138
  store double %139, double* %Acos.ret
  br label %bb23

bb23:                                             ; preds = %bb25, %bb22
  br label %bb24

bb24:                                             ; preds = %bb23
  %140 = load double, double* %Acos.ret
  ret double %140

bb25:                                             ; preds = %bb15
  %141 = load double, double* %value.addr
  %142 = fadd double 1.000000e+00, %141
  %143 = fmul double %142, 5.000000e-01
  store double %143, double* %z
  %144 = load double, double* %z
  %145 = fmul double %144, 0x3F023DE10DFDF709
  %146 = fadd double 0x3F49EFE07501B288, %145
  %147 = load double, double* %z
  %148 = fmul double %147, %146
  %149 = fadd double 0xBFA48228B5688F3B, %148
  %150 = load double, double* %z
  %151 = fmul double %150, %149
  %152 = fadd double 0x3FC9C1550E884455, %151
  %153 = load double, double* %z
  %154 = fmul double %153, %152
  %155 = fadd double 0xBFD4D61203EB6F7D, %154
  %156 = load double, double* %z
  %157 = fmul double %156, %155
  %158 = fadd double 0x3FC5555555555555, %157
  %159 = load double, double* %z
  %160 = fmul double %159, %158
  store double %160, double* %p
  %161 = load double, double* %z
  %162 = fmul double %161, 0x3FB3B8C5B12E9282
  %163 = fadd double 0xBFE6066C1B8D0159, %162
  %164 = load double, double* %z
  %165 = fmul double %164, %163
  %166 = fadd double 0x40002AE59C598AC8, %165
  %167 = load double, double* %z
  %168 = fmul double %167, %166
  %169 = fadd double 0xC0033A271C8A2D4B, %168
  %170 = load double, double* %z
  %171 = fmul double %170, %169
  %172 = fadd double 1.000000e+00, %171
  store double %172, double* %q
  %173 = load double, double* %z
  %174 = call double @"System.Math.Sqrt$I@V@Double@value"(double %173)
  store double %174, double* %s
  %175 = load double, double* %p
  %176 = load double, double* %q
  %177 = fdiv double %175, %176
  store double %177, double* %r
  %178 = load double, double* %r
  %179 = load double, double* %s
  %180 = fmul double %178, %179
  %181 = fsub double %180, 0x3C91A62633145C07
  store double %181, double* %w
  %182 = load double, double* %s
  %183 = load double, double* %w
  %184 = fadd double %182, %183
  %185 = fmul double 2.000000e+00, %184
  %186 = fsub double 0x400921FB54442D18, %185
  store double %186, double* %Acos.ret
  br label %bb23
}

define double @"System.Math.Sqrt$I@V@Double@value"(double %value) {
Entry:
  %Sqrt.ret = alloca double
  %value.addr = alloca double
  %z = alloca double
  %ix = alloca i64
  %r = alloca i64
  %q = alloca i64
  %ix0 = alloca i32
  %m = alloca i32
  %t = alloca i64
  %s0 = alloca i64
  store double 0.000000e+00, double* %Sqrt.ret
  store double %value, double* %value.addr
  store double 0.000000e+00, double* %z
  store i64 0, i64* %ix
  store i64 0, i64* %r
  store i64 0, i64* %q
  store i32 0, i32* %ix0
  store i32 0, i32* %m
  store i64 0, i64* %t
  store i64 0, i64* %s0
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  store i64 %1, i64* %ix
  %2 = load i64, i64* %ix
  %3 = and i64 %2, -4294967296
  %4 = lshr i64 %3, 32
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %ix0
  %6 = load i32, i32* %ix0
  %7 = and i32 %6, 2146435072
  %8 = icmp eq i32 %7, 2146435072
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %ix0
  %10 = and i32 %9, -2147483648
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %12 = load double, double* %value.addr
  %13 = load double, double* %value.addr
  %14 = fmul double %12, %13
  %15 = load double, double* %value.addr
  %16 = fadd double %14, %15
  store double %16, double* %Sqrt.ret
  %17 = load double, double* %Sqrt.ret
  ret double %17

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %18 = load i64, i64* %ix
  %19 = and i64 %18, 9223372036854775807
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %bb12, label %bb10

bb8:                                              ; preds = %bb3
  %21 = load double, double* %value.addr
  %22 = load double, double* %value.addr
  %23 = fsub double %21, %22
  %24 = load double, double* %value.addr
  %25 = load double, double* %value.addr
  %26 = fsub double %24, %25
  %27 = fdiv double %23, %26
  store double %27, double* %Sqrt.ret
  %28 = load double, double* %Sqrt.ret
  ret double %28

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb13, %bb7
  br label %bb11

bb11:                                             ; preds = %bb10
  %29 = load i32, i32* %ix0
  %30 = lshr i32 %29, 20
  store i32 %30, i32* %m
  %31 = load i32, i32* %m
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %bb16, label %bb14

bb12:                                             ; preds = %bb7
  %33 = load double, double* %value.addr
  store double %33, double* %Sqrt.ret
  %34 = load double, double* %Sqrt.ret
  ret double %34

bb13:                                             ; No predecessors!
  br label %bb10

bb14:                                             ; preds = %bb24, %bb11
  br label %bb15

bb15:                                             ; preds = %bb14
  %35 = load i32, i32* %m
  %36 = sub i32 %35, 1023
  store i32 %36, i32* %m
  %37 = load i64, i64* %ix
  %38 = and i64 %37, 4503599627370495
  %39 = or i64 %38, 4503599627370496
  store i64 %39, i64* %ix
  %40 = load i32, i32* %m
  %41 = and i32 %40, 1
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %bb27, label %bb25

bb16:                                             ; preds = %bb11
  br label %bb17

bb17:                                             ; preds = %bb18, %bb16
  %43 = load i64, i64* %ix
  %44 = and i64 %43, -4294967296
  %45 = lshr i64 %44, 32
  %46 = trunc i64 %45 to i32
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %bb18, label %bb19

bb18:                                             ; preds = %bb17
  %48 = load i32, i32* %m
  %49 = sub i32 %48, 21
  store i32 %49, i32* %m
  %50 = load i64, i64* %ix
  %51 = shl i64 %50, 21
  store i64 %51, i64* %ix
  br label %bb17

bb19:                                             ; preds = %bb17
  br label %bb20

bb20:                                             ; preds = %bb19
  br label %bb21

bb21:                                             ; preds = %bb22, %bb20
  %52 = load i64, i64* %ix
  %53 = and i64 %52, -4294967296
  %54 = lshr i64 %53, 32
  %55 = trunc i64 %54 to i32
  %56 = and i32 %55, 1048576
  %57 = icmp eq i32 %56, 0
  br i1 %57, label %bb22, label %bb23

bb22:                                             ; preds = %bb21
  %58 = load i32, i32* %m
  %59 = sub i32 %58, 1
  store i32 %59, i32* %m
  %60 = load i64, i64* %ix
  %61 = shl i64 %60, 1
  store i64 %61, i64* %ix
  br label %bb21

bb23:                                             ; preds = %bb21
  br label %bb24

bb24:                                             ; preds = %bb23
  br label %bb14

bb25:                                             ; preds = %bb27, %bb15
  br label %bb26

bb26:                                             ; preds = %bb25
  %62 = load i32, i32* %m
  %63 = lshr i32 %62, 1
  store i32 %63, i32* %m
  %64 = load i64, i64* %ix
  %65 = shl i64 %64, 1
  store i64 %65, i64* %ix
  store i64 9007199254740992, i64* %r
  br label %bb28

bb27:                                             ; preds = %bb15
  %66 = load i64, i64* %ix
  %67 = shl i64 %66, 1
  store i64 %67, i64* %ix
  br label %bb25

bb28:                                             ; preds = %bb33, %bb26
  %68 = load i64, i64* %r
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %bb29, label %bb30

bb29:                                             ; preds = %bb28
  %70 = load i64, i64* %s0
  %71 = load i64, i64* %r
  %72 = add i64 %70, %71
  store i64 %72, i64* %t
  %73 = load i64, i64* %t
  %74 = load i64, i64* %ix
  %75 = icmp ule i64 %73, %74
  br i1 %75, label %bb34, label %bb32

bb30:                                             ; preds = %bb28
  br label %bb31

bb31:                                             ; preds = %bb30
  %76 = load i64, i64* %ix
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %bb37, label %bb35

bb32:                                             ; preds = %bb34, %bb29
  br label %bb33

bb33:                                             ; preds = %bb32
  %78 = load i64, i64* %ix
  %79 = shl i64 %78, 1
  store i64 %79, i64* %ix
  %80 = load i64, i64* %r
  %81 = lshr i64 %80, 1
  store i64 %81, i64* %r
  br label %bb28

bb34:                                             ; preds = %bb29
  %82 = load i64, i64* %t
  %83 = load i64, i64* %r
  %84 = add i64 %82, %83
  store i64 %84, i64* %s0
  %85 = load i64, i64* %ix
  %86 = load i64, i64* %t
  %87 = sub i64 %85, %86
  store i64 %87, i64* %ix
  %88 = load i64, i64* %q
  %89 = load i64, i64* %r
  %90 = or i64 %88, %89
  store i64 %90, i64* %q
  br label %bb32

bb35:                                             ; preds = %bb39, %bb31
  br label %bb36

bb36:                                             ; preds = %bb35
  %91 = load i64, i64* %q
  %92 = lshr i64 %91, 1
  %93 = load i32, i32* %m
  %94 = add i32 %93, 1022
  %95 = zext i32 %94 to i64
  %96 = shl i64 %95, 52
  %97 = add i64 %92, %96
  store i64 %97, i64* %ix
  %98 = load i64, i64* %ix
  %99 = bitcast i64 %98 to double
  store double %99, double* %z
  %100 = load double, double* %z
  store double %100, double* %Sqrt.ret
  %101 = load double, double* %Sqrt.ret
  ret double %101

bb37:                                             ; preds = %bb31
  store double 1.000000e+00, double* %z
  %102 = load double, double* %z
  %103 = fcmp oge double %102, 1.000000e+00
  br i1 %103, label %bb40, label %bb38

bb38:                                             ; preds = %bb43, %bb37
  br label %bb39

bb39:                                             ; preds = %bb38
  br label %bb35

bb40:                                             ; preds = %bb37
  %104 = load i64, i64* %q
  %105 = and i64 %104, 4294967295
  %106 = lshr i64 %105, 0
  %107 = trunc i64 %106 to i32
  %108 = icmp eq i32 %107, -1
  br i1 %108, label %bb44, label %bb41

bb41:                                             ; preds = %bb40
  store double 1.000000e+00, double* %z
  %109 = load double, double* %z
  %110 = fcmp ogt double %109, 1.000000e+00
  br i1 %110, label %bb48, label %bb45

bb42:                                             ; preds = %bb47, %bb44
  br label %bb43

bb43:                                             ; preds = %bb42
  br label %bb38

bb44:                                             ; preds = %bb40
  %111 = load i64, i64* %q
  %112 = add i64 %111, 1
  store i64 %112, i64* %q
  br label %bb42

bb45:                                             ; preds = %bb41
  %113 = load i64, i64* %q
  %114 = and i64 %113, 1
  %115 = icmp ne i64 %114, 0
  %116 = zext i1 %115 to i16
  %117 = zext i16 %116 to i64
  %118 = load i64, i64* %q
  %119 = add i64 %118, %117
  store i64 %119, i64* %q
  br label %bb46

bb46:                                             ; preds = %bb48, %bb45
  br label %bb47

bb47:                                             ; preds = %bb46
  br label %bb42

bb48:                                             ; preds = %bb41
  %120 = load i64, i64* %q
  %121 = add i64 %120, 2
  store i64 %121, i64* %q
  br label %bb46
}

define float @"System.Math.Asin$I@V@Float@value"(float %value) {
Entry:
  %Asin.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Asin.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Asin$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Asin.ret
  %4 = load float, float* %Asin.ret
  ret float %4
}

define double @"System.Math.Asin$I@V@Double@value"(double %value) {
Entry:
  %Asin.ret = alloca double
  %value.addr = alloca double
  %hx = alloca i32
  %ix = alloca i32
  %t = alloca double
  %w = alloca double
  %p = alloca double
  %q = alloca double
  %c = alloca double
  %r = alloca double
  %s = alloca double
  store double 0.000000e+00, double* %Asin.ret
  store double %value, double* %value.addr
  store i32 0, i32* %hx
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %t
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %p
  store double 0.000000e+00, double* %q
  store double 0.000000e+00, double* %c
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %s
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, 2147483647
  store i32 %6, i32* %ix
  %7 = load i32, i32* %ix
  %8 = icmp uge i32 %7, 1072693248
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb9, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %ix
  %10 = icmp ult i32 %9, 1071644672
  br i1 %10, label %bb12, label %bb10

bb4:                                              ; preds = %bb1
  %11 = load i32, i32* %ix
  %12 = sub i32 %11, 1072693248
  %13 = load double, double* %value.addr
  %14 = bitcast double %13 to i64
  %15 = and i64 %14, 4294967295
  %16 = lshr i64 %15, 0
  %17 = trunc i64 %16 to i32
  %18 = or i32 %12, %17
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %bb8, label %bb5

bb5:                                              ; preds = %bb4
  %20 = load double, double* %value.addr
  %21 = load double, double* %value.addr
  %22 = fsub double %20, %21
  %23 = load double, double* %value.addr
  %24 = load double, double* %value.addr
  %25 = fsub double %23, %24
  %26 = fdiv double %22, %25
  store double %26, double* %Asin.ret
  br label %bb6

bb6:                                              ; preds = %bb8, %bb5
  br label %bb7

bb7:                                              ; preds = %bb6
  %27 = load double, double* %Asin.ret
  ret double %27

bb8:                                              ; preds = %bb4
  %28 = load double, double* %value.addr
  %29 = fmul double %28, 0x3FF921FB54442D18
  %30 = load double, double* %value.addr
  %31 = fmul double %30, 0x3C91A62633145C07
  %32 = fadd double %29, %31
  store double %32, double* %Asin.ret
  br label %bb6

bb9:                                              ; No predecessors!
  br label %bb2

bb10:                                             ; preds = %bb20, %bb3
  br label %bb11

bb11:                                             ; preds = %bb10
  %33 = load double, double* %value.addr
  %34 = call double @"System.Math.Abs$I@V@Double@value"(double %33)
  %35 = fsub double 1.000000e+00, %34
  store double %35, double* %w
  %36 = load double, double* %w
  %37 = fmul double %36, 5.000000e-01
  store double %37, double* %t
  %38 = load double, double* %t
  %39 = fmul double %38, 0x3F023DE10DFDF709
  %40 = fadd double 0x3F49EFE07501B288, %39
  %41 = load double, double* %t
  %42 = fmul double %41, %40
  %43 = fadd double 0xBFA48228B5688F3B, %42
  %44 = load double, double* %t
  %45 = fmul double %44, %43
  %46 = fadd double 0x3FC9C1550E884455, %45
  %47 = load double, double* %t
  %48 = fmul double %47, %46
  %49 = fadd double 0xBFD4D61203EB6F7D, %48
  %50 = load double, double* %t
  %51 = fmul double %50, %49
  %52 = fadd double 0x3FC5555555555555, %51
  %53 = load double, double* %t
  %54 = fmul double %53, %52
  store double %54, double* %p
  %55 = load double, double* %t
  %56 = fmul double %55, 0x3FB3B8C5B12E9282
  %57 = fadd double 0xBFE6066C1B8D0159, %56
  %58 = load double, double* %t
  %59 = fmul double %58, %57
  %60 = fadd double 0x40002AE59C598AC8, %59
  %61 = load double, double* %t
  %62 = fmul double %61, %60
  %63 = fadd double 0xC0033A271C8A2D4B, %62
  %64 = load double, double* %t
  %65 = fmul double %64, %63
  %66 = fadd double 1.000000e+00, %65
  store double %66, double* %q
  %67 = load double, double* %t
  %68 = call double @"System.Math.Sqrt$I@V@Double@value"(double %67)
  store double %68, double* %s
  %69 = load i32, i32* %ix
  %70 = icmp uge i32 %69, 1072640819
  br i1 %70, label %bb24, label %bb21

bb12:                                             ; preds = %bb3
  %71 = load i32, i32* %ix
  %72 = icmp ule i32 %71, 1044381696
  br i1 %72, label %bb15, label %bb13

bb13:                                             ; preds = %bb19, %bb12
  br label %bb14

bb14:                                             ; preds = %bb13
  %73 = load double, double* %value.addr
  %74 = load double, double* %value.addr
  %75 = fmul double %73, %74
  store double %75, double* %t
  %76 = load double, double* %t
  %77 = fmul double %76, 0x3F023DE10DFDF709
  %78 = fadd double 0x3F49EFE07501B288, %77
  %79 = load double, double* %t
  %80 = fmul double %79, %78
  %81 = fadd double 0xBFA48228B5688F3B, %80
  %82 = load double, double* %t
  %83 = fmul double %82, %81
  %84 = fadd double 0x3FC9C1550E884455, %83
  %85 = load double, double* %t
  %86 = fmul double %85, %84
  %87 = fadd double 0xBFD4D61203EB6F7D, %86
  %88 = load double, double* %t
  %89 = fmul double %88, %87
  %90 = fadd double 0x3FC5555555555555, %89
  %91 = load double, double* %t
  %92 = fmul double %91, %90
  store double %92, double* %p
  %93 = load double, double* %t
  %94 = fmul double %93, 0x3FB3B8C5B12E9282
  %95 = fadd double 0xBFE6066C1B8D0159, %94
  %96 = load double, double* %t
  %97 = fmul double %96, %95
  %98 = fadd double 0x40002AE59C598AC8, %97
  %99 = load double, double* %t
  %100 = fmul double %99, %98
  %101 = fadd double 0xC0033A271C8A2D4B, %100
  %102 = load double, double* %t
  %103 = fmul double %102, %101
  %104 = fadd double 1.000000e+00, %103
  store double %104, double* %q
  %105 = load double, double* %p
  %106 = load double, double* %q
  %107 = fdiv double %105, %106
  store double %107, double* %w
  %108 = load double, double* %value.addr
  %109 = load double, double* %w
  %110 = fmul double %108, %109
  %111 = load double, double* %value.addr
  %112 = fadd double %111, %110
  store double %112, double* %Asin.ret
  %113 = load double, double* %Asin.ret
  ret double %113

bb15:                                             ; preds = %bb12
  %114 = load double, double* %value.addr
  %115 = fadd double 1.000000e+300, %114
  %116 = fcmp ogt double %115, 1.000000e+00
  br i1 %116, label %bb18, label %bb16

bb16:                                             ; preds = %bb18, %bb15
  br label %bb17

bb17:                                             ; preds = %bb16
  %117 = load double, double* %Asin.ret
  ret double %117

bb18:                                             ; preds = %bb15
  %118 = load double, double* %value.addr
  store double %118, double* %Asin.ret
  br label %bb16

bb19:                                             ; No predecessors!
  br label %bb13

bb20:                                             ; No predecessors!
  br label %bb10

bb21:                                             ; preds = %bb11
  %119 = load double, double* %s
  store double %119, double* %w
  %120 = load double, double* %w
  %121 = bitcast double %120 to i64
  %122 = and i64 %121, -4294967296
  %123 = bitcast i64 %122 to double
  store double %123, double* %w
  %124 = load double, double* %w
  %125 = load double, double* %w
  %126 = fmul double %124, %125
  %127 = load double, double* %t
  %128 = fsub double %127, %126
  %129 = load double, double* %s
  %130 = load double, double* %w
  %131 = fadd double %129, %130
  %132 = fdiv double %128, %131
  store double %132, double* %c
  %133 = load double, double* %p
  %134 = load double, double* %q
  %135 = fdiv double %133, %134
  store double %135, double* %r
  %136 = load double, double* %s
  %137 = fmul double 2.000000e+00, %136
  %138 = load double, double* %r
  %139 = fmul double %137, %138
  %140 = load double, double* %c
  %141 = fmul double 2.000000e+00, %140
  %142 = fsub double 0x3C91A62633145C07, %141
  %143 = fsub double %139, %142
  store double %143, double* %p
  %144 = load double, double* %w
  %145 = fmul double 2.000000e+00, %144
  %146 = fsub double 0x3FE921FB54442D18, %145
  store double %146, double* %q
  %147 = load double, double* %p
  %148 = load double, double* %q
  %149 = fsub double %147, %148
  %150 = fsub double 0x3FE921FB54442D18, %149
  store double %150, double* %t
  br label %bb22

bb22:                                             ; preds = %bb24, %bb21
  br label %bb23

bb23:                                             ; preds = %bb22
  %151 = load i32, i32* %hx
  %152 = and i32 %151, -2147483648
  %153 = icmp ne i32 %152, 0
  br i1 %153, label %bb28, label %bb25

bb24:                                             ; preds = %bb11
  %154 = load double, double* %p
  %155 = load double, double* %q
  %156 = fdiv double %154, %155
  store double %156, double* %w
  %157 = load double, double* %s
  %158 = load double, double* %w
  %159 = fmul double %157, %158
  %160 = load double, double* %s
  %161 = fadd double %160, %159
  %162 = fmul double 2.000000e+00, %161
  %163 = fsub double %162, 0x3C91A62633145C07
  %164 = fsub double 0x3FF921FB54442D18, %163
  store double %164, double* %t
  br label %bb22

bb25:                                             ; preds = %bb23
  %165 = load double, double* %t
  store double %165, double* %Asin.ret
  br label %bb26

bb26:                                             ; preds = %bb28, %bb25
  br label %bb27

bb27:                                             ; preds = %bb26
  %166 = load double, double* %Asin.ret
  ret double %166

bb28:                                             ; preds = %bb23
  %167 = load double, double* %t
  %168 = fsub double 0.000000e+00, %167
  store double %168, double* %Asin.ret
  br label %bb26
}

define float @"System.Math.Atan$I@V@Float@value"(float %value) {
Entry:
  %Atan.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Atan.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Atan$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Atan.ret
  %4 = load float, float* %Atan.ret
  ret float %4
}

define double @"System.Math.Atan$I@V@Double@value"(double %value) {
Entry:
  %Atan.ret = alloca double
  %value.addr = alloca double
  %hx = alloca i32
  %ix = alloca i32
  %xx = alloca double
  %w = alloca double
  %s1 = alloca double
  %s2 = alloca double
  %z = alloca double
  %id = alloca i32
  %atanhi = alloca [4 x double]
  %atanlo = alloca [4 x double]
  store double 0.000000e+00, double* %Atan.ret
  store double %value, double* %value.addr
  store i32 0, i32* %hx
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %xx
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %s1
  store double 0.000000e+00, double* %s2
  store double 0.000000e+00, double* %z
  store i32 0, i32* %id
  store [4 x double] [double 0x3FDDAC670561BB4F, double 0x3FE921FB54442D18, double 0x3FEF730BD281F69B, double 0x3FF921FB54442D18], [4 x double]* %atanhi
  store [4 x double] [double 0x3C7A2B7F222F65E2, double 0x3C81A62633145C07, double 0x3C7007887AF0CBBD, double 0x3C91A62633145C07], [4 x double]* %atanlo
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, 2147483647
  store i32 %6, i32* %ix
  %7 = load i32, i32* %ix
  %8 = icmp uge i32 %7, 1141899264
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb13, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %ix
  %10 = icmp ult i32 %9, 1071382528
  br i1 %10, label %bb17, label %bb14

bb4:                                              ; preds = %bb1
  %11 = load i32, i32* %ix
  %12 = icmp ugt i32 %11, 2146435072
  %13 = load i32, i32* %ix
  %14 = icmp eq i32 %13, 2146435072
  %15 = load double, double* %value.addr
  %16 = bitcast double %15 to i64
  %17 = and i64 %16, 4294967295
  %18 = lshr i64 %17, 0
  %19 = trunc i64 %18 to i32
  %20 = icmp ne i32 %19, 0
  %21 = and i1 %14, %20
  %22 = or i1 %12, %21
  br i1 %22, label %bb7, label %bb5

bb5:                                              ; preds = %bb8, %bb4
  br label %bb6

bb6:                                              ; preds = %bb5
  %23 = load i32, i32* %hx
  %24 = and i32 %23, -2147483648
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %bb12, label %bb9

bb7:                                              ; preds = %bb4
  %26 = load double, double* %value.addr
  %27 = load double, double* %value.addr
  %28 = fadd double %26, %27
  store double %28, double* %Atan.ret
  %29 = load double, double* %Atan.ret
  ret double %29

bb8:                                              ; No predecessors!
  br label %bb5

bb9:                                              ; preds = %bb6
  %30 = getelementptr inbounds [4 x double], [4 x double]* %atanhi, i32 0, i32 3
  %31 = getelementptr inbounds [4 x double], [4 x double]* %atanlo, i32 0, i32 3
  %32 = load double, double* %30
  %33 = load double, double* %31
  %34 = fadd double %32, %33
  store double %34, double* %Atan.ret
  br label %bb10

bb10:                                             ; preds = %bb12, %bb9
  br label %bb11

bb11:                                             ; preds = %bb10
  %35 = load double, double* %Atan.ret
  ret double %35

bb12:                                             ; preds = %bb6
  %36 = getelementptr inbounds [4 x double], [4 x double]* %atanhi, i32 0, i32 3
  %37 = load double, double* %36
  %38 = fsub double 0.000000e+00, %37
  %39 = getelementptr inbounds [4 x double], [4 x double]* %atanlo, i32 0, i32 3
  %40 = load double, double* %39
  %41 = fsub double %38, %40
  store double %41, double* %Atan.ret
  br label %bb10

bb13:                                             ; No predecessors!
  br label %bb2

bb14:                                             ; preds = %bb3
  %42 = load double, double* %value.addr
  %43 = call double @"System.Math.Abs$I@V@Double@value"(double %42)
  store double %43, double* %xx
  %44 = load i32, i32* %ix
  %45 = icmp ult i32 %44, 1072889856
  br i1 %45, label %bb28, label %bb25

bb15:                                             ; preds = %bb27, %bb19
  br label %bb16

bb16:                                             ; preds = %bb15
  %46 = load double, double* %xx
  %47 = load double, double* %xx
  %48 = fmul double %46, %47
  store double %48, double* %z
  %49 = load double, double* %z
  %50 = load double, double* %z
  %51 = fmul double %49, %50
  store double %51, double* %w
  %52 = load double, double* %w
  %53 = fmul double %52, 0x3F90AD3AE322DA11
  %54 = fadd double 0x3FA97B4B24760DEB, %53
  %55 = load double, double* %w
  %56 = fmul double %55, %54
  %57 = fadd double 0x3FB10D66A0D03D51, %56
  %58 = load double, double* %w
  %59 = fmul double %58, %57
  %60 = fadd double 0x3FB745CDC54C206E, %59
  %61 = load double, double* %w
  %62 = fmul double %61, %60
  %63 = fadd double 0x3FC24924920083FF, %62
  %64 = load double, double* %w
  %65 = fmul double %64, %63
  %66 = fadd double 0x3FD555555555550D, %65
  %67 = load double, double* %z
  %68 = fmul double %67, %66
  store double %68, double* %s1
  %69 = load double, double* %w
  %70 = fmul double %69, 0xBFA2B4442C6A6C2F
  %71 = fadd double 0xBFADDE2D52DEFD9A, %70
  %72 = load double, double* %w
  %73 = fmul double %72, %71
  %74 = fadd double 0xBFB3B0F2AF749A6D, %73
  %75 = load double, double* %w
  %76 = fmul double %75, %74
  %77 = fadd double 0xBFBC71C6FE231671, %76
  %78 = load double, double* %w
  %79 = fmul double %78, %77
  %80 = fadd double 0xBFC999999998EBC4, %79
  %81 = load double, double* %w
  %82 = fmul double %81, %80
  store double %82, double* %s2
  %83 = load i32, i32* %id
  %84 = icmp slt i32 %83, 0
  br i1 %84, label %bb40, label %bb37

bb17:                                             ; preds = %bb3
  %85 = load i32, i32* %ix
  %86 = icmp ult i32 %85, 1042284544
  br i1 %86, label %bb20, label %bb18

bb18:                                             ; preds = %bb22, %bb17
  br label %bb19

bb19:                                             ; preds = %bb18
  store i32 -1, i32* %id
  %87 = load double, double* %value.addr
  store double %87, double* %xx
  br label %bb15

bb20:                                             ; preds = %bb17
  %88 = load double, double* %value.addr
  %89 = fadd double 1.000000e+300, %88
  %90 = fcmp ogt double %89, 1.000000e+00
  br i1 %90, label %bb23, label %bb21

bb21:                                             ; preds = %bb24, %bb20
  br label %bb22

bb22:                                             ; preds = %bb21
  br label %bb18

bb23:                                             ; preds = %bb20
  %91 = load double, double* %value.addr
  store double %91, double* %Atan.ret
  %92 = load double, double* %Atan.ret
  ret double %92

bb24:                                             ; No predecessors!
  br label %bb21

bb25:                                             ; preds = %bb14
  %93 = load i32, i32* %ix
  %94 = icmp ult i32 %93, 1073971200
  br i1 %94, label %bb36, label %bb33

bb26:                                             ; preds = %bb35, %bb31
  br label %bb27

bb27:                                             ; preds = %bb26
  br label %bb15

bb28:                                             ; preds = %bb14
  %95 = load i32, i32* %ix
  %96 = icmp ult i32 %95, 1072037888
  br i1 %96, label %bb32, label %bb29

bb29:                                             ; preds = %bb28
  store i32 1, i32* %id
  %97 = load double, double* %xx
  %98 = fsub double %97, 1.000000e+00
  %99 = load double, double* %xx
  %100 = fadd double %99, 1.000000e+00
  %101 = fdiv double %98, %100
  store double %101, double* %xx
  br label %bb30

bb30:                                             ; preds = %bb32, %bb29
  br label %bb31

bb31:                                             ; preds = %bb30
  br label %bb26

bb32:                                             ; preds = %bb28
  store i32 0, i32* %id
  %102 = load double, double* %xx
  %103 = fmul double 2.000000e+00, %102
  %104 = fsub double %103, 1.000000e+00
  %105 = load double, double* %xx
  %106 = fadd double 2.000000e+00, %105
  %107 = fdiv double %104, %106
  store double %107, double* %xx
  br label %bb30

bb33:                                             ; preds = %bb25
  store i32 3, i32* %id
  %108 = load double, double* %xx
  %109 = fdiv double -1.000000e+00, %108
  store double %109, double* %xx
  br label %bb34

bb34:                                             ; preds = %bb36, %bb33
  br label %bb35

bb35:                                             ; preds = %bb34
  br label %bb26

bb36:                                             ; preds = %bb25
  store i32 2, i32* %id
  %110 = load double, double* %xx
  %111 = fsub double %110, 1.500000e+00
  %112 = load double, double* %xx
  %113 = fmul double 1.500000e+00, %112
  %114 = fadd double 1.000000e+00, %113
  %115 = fdiv double %111, %114
  store double %115, double* %xx
  br label %bb34

bb37:                                             ; preds = %bb16
  %116 = load i32, i32* %id
  %117 = sub i32 %116, 0
  %118 = getelementptr inbounds [4 x double], [4 x double]* %atanhi, i32 0, i32 %117
  %119 = load double, double* %s1
  %120 = load double, double* %s2
  %121 = fadd double %119, %120
  %122 = load double, double* %xx
  %123 = fmul double %122, %121
  %124 = load i32, i32* %id
  %125 = sub i32 %124, 0
  %126 = getelementptr inbounds [4 x double], [4 x double]* %atanlo, i32 0, i32 %125
  %127 = load double, double* %126
  %128 = fsub double %123, %127
  %129 = load double, double* %xx
  %130 = fsub double %128, %129
  %131 = load double, double* %118
  %132 = fsub double %131, %130
  store double %132, double* %z
  %133 = load i32, i32* %hx
  %134 = and i32 %133, -2147483648
  %135 = icmp ne i32 %134, 0
  br i1 %135, label %bb43, label %bb41

bb38:                                             ; preds = %bb42, %bb40
  br label %bb39

bb39:                                             ; preds = %bb38
  %136 = load double, double* %Atan.ret
  ret double %136

bb40:                                             ; preds = %bb16
  %137 = load double, double* %s1
  %138 = load double, double* %s2
  %139 = fadd double %137, %138
  %140 = load double, double* %xx
  %141 = fmul double %140, %139
  %142 = load double, double* %xx
  %143 = fsub double %142, %141
  store double %143, double* %Atan.ret
  br label %bb38

bb41:                                             ; preds = %bb43, %bb37
  br label %bb42

bb42:                                             ; preds = %bb41
  %144 = load double, double* %z
  store double %144, double* %Atan.ret
  br label %bb38

bb43:                                             ; preds = %bb37
  %145 = load double, double* %z
  %146 = fsub double 0.000000e+00, %145
  store double %146, double* %z
  br label %bb41
}

define float @"System.Math.Atan2$I@V@Float@y?I@V@Float@x"(float %y, float %x) {
Entry:
  %Atan2.ret = alloca float
  %y.addr = alloca float
  %x.addr = alloca float
  store float 0.000000e+00, float* %Atan2.ret
  store float %y, float* %y.addr
  store float %x, float* %x.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %x.addr
  %1 = fcmp ogt float %0, 0.000000e+00
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load float, float* %x.addr
  %3 = fcmp olt float %2, 0.000000e+00
  br i1 %3, label %bb9, label %bb6

bb3:                                              ; preds = %bb8, %bb5
  br label %bb4

bb4:                                              ; preds = %bb3
  %4 = load float, float* %Atan2.ret
  ret float %4

bb5:                                              ; preds = %bb1
  %5 = load float, float* %y.addr
  %6 = load float, float* %x.addr
  %7 = fdiv float %5, %6
  %8 = call float @"System.Math.Atan$I@V@Float@value"(float %7)
  store float %8, float* %Atan2.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load float, float* %y.addr
  %10 = fcmp ogt float %9, 0.000000e+00
  br i1 %10, label %bb21, label %bb18

bb7:                                              ; preds = %bb20, %bb12
  br label %bb8

bb8:                                              ; preds = %bb7
  br label %bb3

bb9:                                              ; preds = %bb2
  %11 = load float, float* %y.addr
  %12 = fcmp ogt float %11, 0.000000e+00
  br i1 %12, label %bb13, label %bb10

bb10:                                             ; preds = %bb9
  %13 = load float, float* %y.addr
  %14 = fcmp olt float %13, 0.000000e+00
  br i1 %14, label %bb17, label %bb14

bb11:                                             ; preds = %bb16, %bb13
  br label %bb12

bb12:                                             ; preds = %bb11
  br label %bb7

bb13:                                             ; preds = %bb9
  %15 = load float, float* %y.addr
  %16 = load float, float* %x.addr
  %17 = fdiv float %15, %16
  %18 = call float @"System.Math.Atan$I@V@Float@value"(float %17)
  %19 = fadd float %18, 0x400921FB60000000
  store float %19, float* %Atan2.ret
  br label %bb11

bb14:                                             ; preds = %bb10
  store float 0x400921FB60000000, float* %Atan2.ret
  br label %bb15

bb15:                                             ; preds = %bb17, %bb14
  br label %bb16

bb16:                                             ; preds = %bb15
  br label %bb11

bb17:                                             ; preds = %bb10
  %20 = load float, float* %y.addr
  %21 = load float, float* %x.addr
  %22 = fdiv float %20, %21
  %23 = call float @"System.Math.Atan$I@V@Float@value"(float %22)
  %24 = fsub float %23, 0x400921FB60000000
  store float %24, float* %Atan2.ret
  br label %bb15

bb18:                                             ; preds = %bb6
  store float 0xBFF921FB60000000, float* %Atan2.ret
  br label %bb19

bb19:                                             ; preds = %bb21, %bb18
  br label %bb20

bb20:                                             ; preds = %bb19
  br label %bb7

bb21:                                             ; preds = %bb6
  store float 0x3FF921FB60000000, float* %Atan2.ret
  br label %bb19
}

define double @"System.Math.Atan2$I@V@Double@y?I@V@Double@x"(double %y, double %x) {
Entry:
  %Atan2.ret = alloca double
  %y.addr = alloca double
  %x.addr = alloca double
  store double 0.000000e+00, double* %Atan2.ret
  store double %y, double* %y.addr
  store double %x, double* %x.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = fcmp ogt double %0, 0.000000e+00
  br i1 %1, label %bb5, label %bb2

bb2:                                              ; preds = %bb1
  %2 = load double, double* %x.addr
  %3 = fcmp olt double %2, 0.000000e+00
  br i1 %3, label %bb9, label %bb6

bb3:                                              ; preds = %bb8, %bb5
  br label %bb4

bb4:                                              ; preds = %bb3
  %4 = load double, double* %Atan2.ret
  ret double %4

bb5:                                              ; preds = %bb1
  %5 = load double, double* %y.addr
  %6 = load double, double* %x.addr
  %7 = fdiv double %5, %6
  %8 = call double @"System.Math.Atan$I@V@Double@value"(double %7)
  store double %8, double* %Atan2.ret
  br label %bb3

bb6:                                              ; preds = %bb2
  %9 = load double, double* %y.addr
  %10 = fcmp ogt double %9, 0.000000e+00
  br i1 %10, label %bb21, label %bb18

bb7:                                              ; preds = %bb20, %bb12
  br label %bb8

bb8:                                              ; preds = %bb7
  br label %bb3

bb9:                                              ; preds = %bb2
  %11 = load double, double* %y.addr
  %12 = fcmp ogt double %11, 0.000000e+00
  br i1 %12, label %bb13, label %bb10

bb10:                                             ; preds = %bb9
  %13 = load double, double* %y.addr
  %14 = fcmp olt double %13, 0.000000e+00
  br i1 %14, label %bb17, label %bb14

bb11:                                             ; preds = %bb16, %bb13
  br label %bb12

bb12:                                             ; preds = %bb11
  br label %bb7

bb13:                                             ; preds = %bb9
  %15 = load double, double* %y.addr
  %16 = load double, double* %x.addr
  %17 = fdiv double %15, %16
  %18 = call double @"System.Math.Atan$I@V@Double@value"(double %17)
  %19 = fadd double %18, 0x400921FB54442D18
  store double %19, double* %Atan2.ret
  br label %bb11

bb14:                                             ; preds = %bb10
  store double 0x400921FB54442D18, double* %Atan2.ret
  br label %bb15

bb15:                                             ; preds = %bb17, %bb14
  br label %bb16

bb16:                                             ; preds = %bb15
  br label %bb11

bb17:                                             ; preds = %bb10
  %20 = load double, double* %y.addr
  %21 = load double, double* %x.addr
  %22 = fdiv double %20, %21
  %23 = call double @"System.Math.Atan$I@V@Double@value"(double %22)
  %24 = fsub double %23, 0x400921FB54442D18
  store double %24, double* %Atan2.ret
  br label %bb15

bb18:                                             ; preds = %bb6
  store double 0xBFF921FB54442D18, double* %Atan2.ret
  br label %bb19

bb19:                                             ; preds = %bb21, %bb18
  br label %bb20

bb20:                                             ; preds = %bb19
  br label %bb7

bb21:                                             ; preds = %bb6
  store double 0x3FF921FB54442D18, double* %Atan2.ret
  br label %bb19
}

define float @"System.Math.Cos$I@V@Float@angle"(float %angle) {
Entry:
  %Cos.ret = alloca float
  %angle.addr = alloca float
  store float 0.000000e+00, float* %Cos.ret
  store float %angle, float* %angle.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %angle.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Cos$I@V@Double@angle"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Cos.ret
  %4 = load float, float* %Cos.ret
  ret float %4
}

define double @"System.Math.Cos$I@V@Double@angle"(double %angle) {
Entry:
  %Cos.ret = alloca double
  %angle.addr = alloca double
  %y0 = alloca double
  %y1 = alloca double
  %ix = alloca i32
  %n = alloca i32
  %0 = alloca double
  store double 0.000000e+00, double* %0
  %1 = alloca double
  store double 0.000000e+00, double* %1
  store double 0.000000e+00, double* %Cos.ret
  store double %angle, double* %angle.addr
  store double 0.000000e+00, double* %y0
  store double 0.000000e+00, double* %y1
  store i32 0, i32* %ix
  store i32 0, i32* %n
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load double, double* %angle.addr
  %3 = bitcast double %2 to i64
  %4 = and i64 %3, -4294967296
  %5 = lshr i64 %4, 32
  %6 = trunc i64 %5 to i32
  %7 = and i32 %6, 2147483647
  store i32 %7, i32* %ix
  %8 = load i32, i32* %ix
  %9 = icmp ule i32 %8, 1072243195
  br i1 %9, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %10 = load i32, i32* %ix
  %11 = icmp uge i32 %10, 2146435072
  br i1 %11, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %12 = load double, double* %angle.addr
  %13 = call double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %12, double 0.000000e+00)
  store double %13, double* %Cos.ret
  %14 = load double, double* %Cos.ret
  ret double %14

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %15 = load double, double* %y0
  store double %15, double* %0
  %16 = load double, double* %y1
  store double %16, double* %1
  %17 = load double, double* %angle.addr
  %18 = call i32 @"System.MathInternal.rem_pio2$I@V@Double@x?O@V@Double@yy0?O@V@Double@yy1"(double %17, double* %0, double* %1)
  %19 = load double, double* %0
  store double %19, double* %y0
  %20 = load double, double* %1
  store double %20, double* %y1
  store i32 %18, i32* %n
  %21 = load i32, i32* %n
  switch i32 %21, label %bb14 [
    i32 0, label %bb11
    i32 1, label %bb12
    i32 2, label %bb13
  ]

bb8:                                              ; preds = %bb3
  %22 = load double, double* %angle.addr
  %23 = load double, double* %angle.addr
  %24 = fsub double %22, %23
  store double %24, double* %Cos.ret
  %25 = load double, double* %Cos.ret
  ret double %25

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb14, %bb13, %bb12, %bb11
  %26 = load double, double* %Cos.ret
  ret double %26

bb11:                                             ; preds = %bb7
  %27 = load double, double* %y0
  %28 = load double, double* %y1
  %29 = call double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %27, double %28)
  store double %29, double* %Cos.ret
  br label %bb10

bb12:                                             ; preds = %bb7
  %30 = load double, double* %y0
  %31 = load double, double* %y1
  %32 = call double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %30, double %31, i1 true)
  %33 = fsub double 0.000000e+00, %32
  store double %33, double* %Cos.ret
  br label %bb10

bb13:                                             ; preds = %bb7
  %34 = load double, double* %y0
  %35 = load double, double* %y1
  %36 = call double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %34, double %35)
  %37 = fsub double 0.000000e+00, %36
  store double %37, double* %Cos.ret
  br label %bb10

bb14:                                             ; preds = %bb7
  %38 = load double, double* %y0
  %39 = load double, double* %y1
  %40 = call double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %38, double %39, i1 true)
  store double %40, double* %Cos.ret
  br label %bb10
}

define double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %x, double %y) {
Entry:
  %_kernel_cos.ret = alloca double
  %x.addr = alloca double
  %y.addr = alloca double
  %ix = alloca i32
  %a = alloca double
  %hz = alloca double
  %z = alloca double
  %r = alloca double
  %qx = alloca double
  store double 0.000000e+00, double* %_kernel_cos.ret
  store double %x, double* %x.addr
  store double %y, double* %y.addr
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %a
  store double 0.000000e+00, double* %hz
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %qx
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  %5 = and i32 %4, 2147483647
  store i32 %5, i32* %ix
  %6 = load i32, i32* %ix
  %7 = icmp ult i32 %6, 1044381696
  %8 = load double, double* %x.addr
  %9 = call i32 @"$ax.sroundtoeven_f64_i32"(double %8)
  %10 = icmp eq i32 %9, 0
  %11 = and i1 %7, %10
  br i1 %11, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %12 = load double, double* %x.addr
  %13 = load double, double* %x.addr
  %14 = fmul double %12, %13
  store double %14, double* %z
  %15 = load double, double* %z
  %16 = fmul double %15, 0xBDA8FAE9BE8838D4
  %17 = fadd double 0x3E21EE9EBDB4B1C4, %16
  %18 = load double, double* %z
  %19 = fmul double %18, %17
  %20 = fadd double 0xBE927E4F809C52AD, %19
  %21 = load double, double* %z
  %22 = fmul double %21, %20
  %23 = fadd double 0x3EFA01A019CB1590, %22
  %24 = load double, double* %z
  %25 = fmul double %24, %23
  %26 = fadd double 0xBF56C16C16C15177, %25
  %27 = load double, double* %z
  %28 = fmul double %27, %26
  %29 = fadd double 0x3FA555555555554C, %28
  %30 = load double, double* %z
  %31 = fmul double %30, %29
  store double %31, double* %r
  %32 = load i32, i32* %ix
  %33 = icmp ult i32 %32, 1070805811
  br i1 %33, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  store double 1.000000e+00, double* %_kernel_cos.ret
  %34 = load double, double* %_kernel_cos.ret
  ret double %34

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %35 = load i32, i32* %ix
  %36 = icmp ugt i32 %35, 1072234496
  br i1 %36, label %bb13, label %bb10

bb8:                                              ; preds = %bb3
  %37 = load double, double* %z
  %38 = fmul double 5.000000e-01, %37
  %39 = load double, double* %z
  %40 = load double, double* %r
  %41 = fmul double %39, %40
  %42 = load double, double* %x.addr
  %43 = load double, double* %y.addr
  %44 = fmul double %42, %43
  %45 = fsub double %41, %44
  %46 = fsub double %38, %45
  %47 = fsub double 1.000000e+00, %46
  store double %47, double* %_kernel_cos.ret
  %48 = load double, double* %_kernel_cos.ret
  ret double %48

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb7
  %49 = load i32, i32* %ix
  %50 = sub i32 %49, 33554432
  %51 = zext i32 %50 to i64
  %52 = shl i64 %51, 32
  %53 = bitcast i64 %52 to double
  store double %53, double* %qx
  br label %bb11

bb11:                                             ; preds = %bb13, %bb10
  br label %bb12

bb12:                                             ; preds = %bb11
  %54 = load double, double* %z
  %55 = fmul double 5.000000e-01, %54
  %56 = load double, double* %qx
  %57 = fsub double %55, %56
  store double %57, double* %hz
  %58 = load double, double* %qx
  %59 = fsub double 1.000000e+00, %58
  store double %59, double* %a
  %60 = load double, double* %z
  %61 = load double, double* %r
  %62 = fmul double %60, %61
  %63 = load double, double* %x.addr
  %64 = load double, double* %y.addr
  %65 = fmul double %63, %64
  %66 = fsub double %62, %65
  %67 = load double, double* %hz
  %68 = fsub double %67, %66
  %69 = load double, double* %a
  %70 = fsub double %69, %68
  store double %70, double* %_kernel_cos.ret
  %71 = load double, double* %_kernel_cos.ret
  ret double %71

bb13:                                             ; preds = %bb7
  store double 2.812500e-01, double* %qx
  br label %bb11
}

define i32 @"System.MathInternal.rem_pio2$I@V@Double@x?O@V@Double@yy0?O@V@Double@yy1"(double %x, double* %yy0, double* %yy1) {
Entry:
  %rem_pio2.ret = alloca i32
  %x.addr = alloca double
  %yy0.addr = alloca double*
  %yy1.addr = alloca double*
  %hx = alloca i32
  %ix = alloca i32
  %high = alloca i32
  %xx = alloca double
  %z = alloca double
  %w = alloca double
  %t = alloca double
  %r = alloca double
  %fn = alloca double
  %ty0 = alloca double
  %ty1 = alloca double
  %tx = alloca [3 x double]
  %e0 = alloca i32
  %i = alloca i32
  %j = alloca i32
  %n = alloca i32
  store i32 0, i32* %rem_pio2.ret
  store double %x, double* %x.addr
  store double* %yy0, double** %yy0.addr
  store double* %yy1, double** %yy1.addr
  store i32 0, i32* %hx
  store i32 0, i32* %ix
  store i32 0, i32* %high
  store double 0.000000e+00, double* %xx
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %t
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %fn
  store double 0.000000e+00, double* %ty0
  store double 0.000000e+00, double* %ty1
  store [3 x double] zeroinitializer, [3 x double]* %tx
  store i32 0, i32* %e0
  store i32 0, i32* %i
  store i32 0, i32* %j
  store i32 0, i32* %n
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, 2147483647
  store i32 %6, i32* %ix
  %7 = load i32, i32* %ix
  %8 = icmp ule i32 %7, 1072243195
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load i32, i32* %ix
  %10 = icmp ult i32 %9, 1073928572
  br i1 %10, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %11 = load double, double* %x.addr
  %auto_deref_yy0.addr = load double*, double** %yy0.addr
  store double %11, double* %auto_deref_yy0.addr
  %auto_deref_yy1.addr = load double*, double** %yy1.addr
  store double 0.000000e+00, double* %auto_deref_yy1.addr
  store i32 0, i32* %rem_pio2.ret
  %12 = load i32, i32* %rem_pio2.ret
  ret i32 %12

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb21, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %13 = load double, double* %x.addr
  store double %13, double* %xx
  %14 = load i32, i32* %ix
  %15 = icmp ugt i32 %14, 1094263291
  br i1 %15, label %bb24, label %bb22

bb8:                                              ; preds = %bb3
  %16 = load i32, i32* %hx
  %17 = and i32 %16, -2147483648
  %18 = icmp ne i32 %17, 0
  %19 = xor i1 %18, true
  br i1 %19, label %bb12, label %bb9

bb9:                                              ; preds = %bb8
  %20 = load double, double* %x.addr
  %21 = fadd double %20, 0x3FF921FB54400000
  store double %21, double* %z
  %22 = load i32, i32* %ix
  %23 = icmp ne i32 %22, 1073291771
  br i1 %23, label %bb20, label %bb17

bb10:                                             ; preds = %bb19, %bb15
  br label %bb11

bb11:                                             ; preds = %bb10
  %24 = load i32, i32* %rem_pio2.ret
  ret i32 %24

bb12:                                             ; preds = %bb8
  %25 = load double, double* %x.addr
  %26 = fsub double %25, 0x3FF921FB54400000
  store double %26, double* %z
  %27 = load i32, i32* %ix
  %28 = icmp ne i32 %27, 1073291771
  br i1 %28, label %bb16, label %bb13

bb13:                                             ; preds = %bb12
  %29 = load double, double* %z
  %30 = fsub double %29, 0x3DD0B4611A600000
  store double %30, double* %z
  %31 = load double, double* %z
  %32 = fsub double %31, 0x3BA3198A2E037073
  %auto_deref_yy0.addr4 = load double*, double** %yy0.addr
  store double %32, double* %auto_deref_yy0.addr4
  %33 = load double, double* %z
  %auto_deref_yy0.addr5 = load double*, double** %yy0.addr
  %34 = load double, double* %auto_deref_yy0.addr5
  %35 = fsub double %33, %34
  %36 = fsub double %35, 0x3BA3198A2E037073
  %auto_deref_yy1.addr6 = load double*, double** %yy1.addr
  store double %36, double* %auto_deref_yy1.addr6
  br label %bb14

bb14:                                             ; preds = %bb16, %bb13
  br label %bb15

bb15:                                             ; preds = %bb14
  store i32 1, i32* %rem_pio2.ret
  br label %bb10

bb16:                                             ; preds = %bb12
  %37 = load double, double* %z
  %38 = fsub double %37, 0x3DD0B4611A626331
  %auto_deref_yy0.addr1 = load double*, double** %yy0.addr
  store double %38, double* %auto_deref_yy0.addr1
  %39 = load double, double* %z
  %auto_deref_yy0.addr2 = load double*, double** %yy0.addr
  %40 = load double, double* %auto_deref_yy0.addr2
  %41 = fsub double %39, %40
  %42 = fsub double %41, 0x3DD0B4611A626331
  %auto_deref_yy1.addr3 = load double*, double** %yy1.addr
  store double %42, double* %auto_deref_yy1.addr3
  br label %bb14

bb17:                                             ; preds = %bb9
  %43 = load double, double* %z
  %44 = fadd double %43, 0x3DD0B4611A600000
  store double %44, double* %z
  %45 = load double, double* %z
  %46 = fadd double %45, 0x3BA3198A2E037073
  %auto_deref_yy0.addr10 = load double*, double** %yy0.addr
  store double %46, double* %auto_deref_yy0.addr10
  %47 = load double, double* %z
  %auto_deref_yy0.addr11 = load double*, double** %yy0.addr
  %48 = load double, double* %auto_deref_yy0.addr11
  %49 = fsub double %47, %48
  %50 = fadd double %49, 0x3BA3198A2E037073
  %auto_deref_yy1.addr12 = load double*, double** %yy1.addr
  store double %50, double* %auto_deref_yy1.addr12
  br label %bb18

bb18:                                             ; preds = %bb20, %bb17
  br label %bb19

bb19:                                             ; preds = %bb18
  store i32 3, i32* %rem_pio2.ret
  br label %bb10

bb20:                                             ; preds = %bb9
  %51 = load double, double* %z
  %52 = fadd double %51, 0x3DD0B4611A626331
  %auto_deref_yy0.addr7 = load double*, double** %yy0.addr
  store double %52, double* %auto_deref_yy0.addr7
  %53 = load double, double* %z
  %auto_deref_yy0.addr8 = load double*, double** %yy0.addr
  %54 = load double, double* %auto_deref_yy0.addr8
  %55 = fsub double %53, %54
  %56 = fadd double %55, 0x3DD0B4611A626331
  %auto_deref_yy1.addr9 = load double*, double** %yy1.addr
  store double %56, double* %auto_deref_yy1.addr9
  br label %bb18

bb21:                                             ; No predecessors!
  br label %bb6

bb22:                                             ; preds = %bb30, %bb7
  br label %bb23

bb23:                                             ; preds = %bb22
  %57 = load double, double* %xx
  %58 = call double @"System.Math.Abs$I@V@Double@value"(double %57)
  store double %58, double* %t
  %59 = load double, double* %t
  %60 = fmul double %59, 0x3FE45F306DC9C883
  %61 = call i32 @"$ax.sroundtoeven_f64_i32"(double %60)
  store i32 %61, i32* %n
  %62 = load i32, i32* %n
  %63 = sitofp i32 %62 to double
  store double %63, double* %fn
  %64 = load double, double* %fn
  %65 = fmul double %64, 0x3FF921FB54400000
  %66 = load double, double* %t
  %67 = fsub double %66, %65
  store double %67, double* %r
  %68 = load double, double* %fn
  %69 = fmul double %68, 0x3DD0B4611A626331
  store double %69, double* %w
  %70 = load i32, i32* %n
  %71 = load i32, i32* %ix
  %72 = call i1 @"System.MathInternal.rem_pio2_quick_check$I@V@Int32@n?I@V@Byte32@ix"(i32 %70, i32 %71)
  br i1 %72, label %bb36, label %bb33

bb24:                                             ; preds = %bb7
  %73 = load i32, i32* %ix
  %74 = icmp uge i32 %73, 2146435072
  br i1 %74, label %bb27, label %bb25

bb25:                                             ; preds = %bb28, %bb24
  br label %bb26

bb26:                                             ; preds = %bb25
  %75 = load double, double* %x.addr
  %76 = call double @"System.Math.FMod$I@V@Double@x?I@V@Double@y"(double %75, double 0x401921FB54442D18)
  store double %76, double* %xx
  %77 = load double, double* %xx
  %78 = bitcast double %77 to i64
  %79 = and i64 %78, -4294967296
  %80 = lshr i64 %79, 32
  %81 = trunc i64 %80 to i32
  %82 = and i32 %81, 2147483647
  store i32 %82, i32* %ix
  %83 = load i32, i32* %ix
  %84 = icmp ule i32 %83, 1072243195
  br i1 %84, label %bb31, label %bb29

bb27:                                             ; preds = %bb24
  %85 = load double, double* %xx
  %86 = load double, double* %xx
  %87 = fsub double %85, %86
  %auto_deref_yy0.addr13 = load double*, double** %yy0.addr
  store double %87, double* %auto_deref_yy0.addr13
  %auto_deref_yy0.addr14 = load double*, double** %yy0.addr
  %88 = load double, double* %auto_deref_yy0.addr14
  %auto_deref_yy1.addr15 = load double*, double** %yy1.addr
  store double %88, double* %auto_deref_yy1.addr15
  store i32 0, i32* %rem_pio2.ret
  %89 = load i32, i32* %rem_pio2.ret
  ret i32 %89

bb28:                                             ; No predecessors!
  br label %bb25

bb29:                                             ; preds = %bb32, %bb26
  br label %bb30

bb30:                                             ; preds = %bb29
  br label %bb22

bb31:                                             ; preds = %bb26
  %90 = load double, double* %xx
  %auto_deref_yy0.addr16 = load double*, double** %yy0.addr
  store double %90, double* %auto_deref_yy0.addr16
  %auto_deref_yy1.addr17 = load double*, double** %yy1.addr
  store double 0.000000e+00, double* %auto_deref_yy1.addr17
  store i32 0, i32* %rem_pio2.ret
  %91 = load i32, i32* %rem_pio2.ret
  ret i32 %91

bb32:                                             ; No predecessors!
  br label %bb29

bb33:                                             ; preds = %bb23
  %92 = load i32, i32* %ix
  %93 = lshr i32 %92, 20
  store i32 %93, i32* %j
  %94 = load double, double* %r
  %95 = load double, double* %w
  %96 = fsub double %94, %95
  %auto_deref_yy0.addr19 = load double*, double** %yy0.addr
  store double %96, double* %auto_deref_yy0.addr19
  %auto_deref_yy0.addr20 = load double*, double** %yy0.addr
  %97 = load double, double* %auto_deref_yy0.addr20
  %98 = bitcast double %97 to i64
  %99 = and i64 %98, -4294967296
  %100 = lshr i64 %99, 32
  %101 = trunc i64 %100 to i32
  store i32 %101, i32* %high
  %102 = load i32, i32* %high
  %103 = lshr i32 %102, 20
  %104 = and i32 %103, 2047
  %105 = load i32, i32* %j
  %106 = sub i32 %105, %104
  store i32 %106, i32* %i
  %107 = load i32, i32* %i
  %108 = icmp sgt i32 %107, 16
  br i1 %108, label %bb39, label %bb37

bb34:                                             ; preds = %bb38, %bb36
  br label %bb35

bb35:                                             ; preds = %bb34
  %109 = load double, double* %r
  %auto_deref_yy0.addr24 = load double*, double** %yy0.addr
  %110 = load double, double* %auto_deref_yy0.addr24
  %111 = fsub double %109, %110
  %112 = load double, double* %w
  %113 = fsub double %111, %112
  %auto_deref_yy1.addr25 = load double*, double** %yy1.addr
  store double %113, double* %auto_deref_yy1.addr25
  %114 = load i32, i32* %hx
  %115 = and i32 %114, -2147483648
  %116 = icmp ne i32 %115, 0
  br i1 %116, label %bb45, label %bb43

bb36:                                             ; preds = %bb23
  %117 = load double, double* %r
  %118 = load double, double* %w
  %119 = fsub double %117, %118
  %auto_deref_yy0.addr18 = load double*, double** %yy0.addr
  store double %119, double* %auto_deref_yy0.addr18
  br label %bb34

bb37:                                             ; preds = %bb41, %bb33
  br label %bb38

bb38:                                             ; preds = %bb37
  br label %bb34

bb39:                                             ; preds = %bb33
  %120 = load double, double* %r
  store double %120, double* %t
  %121 = load double, double* %fn
  %122 = fmul double %121, 0x3DD0B4611A600000
  store double %122, double* %w
  %123 = load double, double* %t
  %124 = load double, double* %w
  %125 = fsub double %123, %124
  store double %125, double* %r
  %126 = load double, double* %fn
  %127 = fmul double %126, 0x3BA3198A2E037073
  %128 = load double, double* %t
  %129 = load double, double* %r
  %130 = fsub double %128, %129
  %131 = load double, double* %w
  %132 = fsub double %130, %131
  %133 = fsub double %127, %132
  store double %133, double* %w
  %134 = load double, double* %r
  %135 = load double, double* %w
  %136 = fsub double %134, %135
  %auto_deref_yy0.addr21 = load double*, double** %yy0.addr
  store double %136, double* %auto_deref_yy0.addr21
  %auto_deref_yy0.addr22 = load double*, double** %yy0.addr
  %137 = load double, double* %auto_deref_yy0.addr22
  %138 = bitcast double %137 to i64
  %139 = and i64 %138, -4294967296
  %140 = lshr i64 %139, 32
  %141 = trunc i64 %140 to i32
  store i32 %141, i32* %high
  %142 = load i32, i32* %high
  %143 = lshr i32 %142, 20
  %144 = and i32 %143, 2047
  %145 = load i32, i32* %j
  %146 = sub i32 %145, %144
  store i32 %146, i32* %i
  %147 = load i32, i32* %i
  %148 = icmp sgt i32 %147, 49
  br i1 %148, label %bb42, label %bb40

bb40:                                             ; preds = %bb42, %bb39
  br label %bb41

bb41:                                             ; preds = %bb40
  br label %bb37

bb42:                                             ; preds = %bb39
  %149 = load double, double* %r
  store double %149, double* %t
  %150 = load double, double* %fn
  %151 = fmul double %150, 0x3BA3198A2E000000
  store double %151, double* %w
  %152 = load double, double* %t
  %153 = load double, double* %w
  %154 = fsub double %152, %153
  store double %154, double* %r
  %155 = load double, double* %fn
  %156 = fmul double %155, 0x397B839A252049C1
  %157 = load double, double* %t
  %158 = load double, double* %r
  %159 = fsub double %157, %158
  %160 = load double, double* %w
  %161 = fsub double %159, %160
  %162 = fsub double %156, %161
  store double %162, double* %w
  %163 = load double, double* %r
  %164 = load double, double* %w
  %165 = fsub double %163, %164
  %auto_deref_yy0.addr23 = load double*, double** %yy0.addr
  store double %165, double* %auto_deref_yy0.addr23
  br label %bb40

bb43:                                             ; preds = %bb45, %bb35
  br label %bb44

bb44:                                             ; preds = %bb43
  %166 = load i32, i32* %n
  %167 = and i32 %166, 3
  store i32 %167, i32* %rem_pio2.ret
  %168 = load i32, i32* %rem_pio2.ret
  ret i32 %168

bb45:                                             ; preds = %bb35
  %auto_deref_yy0.addr26 = load double*, double** %yy0.addr
  %169 = load double, double* %auto_deref_yy0.addr26
  %170 = fsub double 0.000000e+00, %169
  %auto_deref_yy0.addr27 = load double*, double** %yy0.addr
  store double %170, double* %auto_deref_yy0.addr27
  %auto_deref_yy1.addr28 = load double*, double** %yy1.addr
  %171 = load double, double* %auto_deref_yy1.addr28
  %172 = fsub double 0.000000e+00, %171
  %auto_deref_yy1.addr29 = load double*, double** %yy1.addr
  store double %172, double* %auto_deref_yy1.addr29
  %173 = load i32, i32* %n
  %174 = sub i32 0, %173
  store i32 %174, i32* %n
  br label %bb43
}

define double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %x, double %y, i1 %reduced) {
Entry:
  %_kernel_sin.ret = alloca double
  %x.addr = alloca double
  %y.addr = alloca double
  %reduced.addr = alloca i1
  %ix = alloca i32
  %z = alloca double
  %r = alloca double
  %v = alloca double
  store double 0.000000e+00, double* %_kernel_sin.ret
  store double %x, double* %x.addr
  store double %y, double* %y.addr
  store i1 %reduced, i1* %reduced.addr
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %v
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  %5 = and i32 %4, 2147483647
  store i32 %5, i32* %ix
  %6 = load i32, i32* %ix
  %7 = icmp ult i32 %6, 1044381696
  %8 = load double, double* %x.addr
  %9 = call i32 @"$ax.sroundtoeven_f64_i32"(double %8)
  %10 = icmp eq i32 %9, 0
  %11 = and i1 %7, %10
  br i1 %11, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %12 = load double, double* %x.addr
  %13 = load double, double* %x.addr
  %14 = fmul double %12, %13
  store double %14, double* %z
  %15 = load double, double* %z
  %16 = load double, double* %x.addr
  %17 = fmul double %15, %16
  store double %17, double* %v
  %18 = load double, double* %z
  %19 = fmul double %18, 0x3DE5D93A5ACFD57C
  %20 = fadd double 0xBE5AE5E68A2B9CEB, %19
  %21 = load double, double* %z
  %22 = fmul double %21, %20
  %23 = fadd double 0x3EC71DE357B1FE7D, %22
  %24 = load double, double* %z
  %25 = fmul double %24, %23
  %26 = fadd double 0xBF2A01A019C161D5, %25
  %27 = load double, double* %z
  %28 = fmul double %27, %26
  %29 = fadd double 0x3F8111111110F8A6, %28
  store double %29, double* %r
  %30 = load i1, i1* %reduced.addr
  %31 = xor i1 %30, true
  br i1 %31, label %bb9, label %bb6

bb4:                                              ; preds = %bb1
  %32 = load double, double* %x.addr
  store double %32, double* %_kernel_sin.ret
  %33 = load double, double* %_kernel_sin.ret
  ret double %33

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb3
  %34 = load double, double* %y.addr
  %35 = fmul double 5.000000e-01, %34
  %36 = load double, double* %v
  %37 = load double, double* %r
  %38 = fmul double %36, %37
  %39 = fsub double %35, %38
  %40 = load double, double* %z
  %41 = fmul double %40, %39
  %42 = load double, double* %y.addr
  %43 = fsub double %41, %42
  %44 = load double, double* %v
  %45 = fmul double %44, 0xBFC5555555555549
  %46 = fsub double %43, %45
  %47 = load double, double* %x.addr
  %48 = fsub double %47, %46
  store double %48, double* %_kernel_sin.ret
  br label %bb7

bb7:                                              ; preds = %bb9, %bb6
  br label %bb8

bb8:                                              ; preds = %bb7
  %49 = load double, double* %_kernel_sin.ret
  ret double %49

bb9:                                              ; preds = %bb3
  %50 = load double, double* %z
  %51 = load double, double* %r
  %52 = fmul double %50, %51
  %53 = fadd double 0xBFC5555555555549, %52
  %54 = load double, double* %v
  %55 = fmul double %54, %53
  %56 = load double, double* %x.addr
  %57 = fadd double %56, %55
  store double %57, double* %_kernel_sin.ret
  br label %bb7
}

define i1 @"System.MathInternal.rem_pio2_quick_check$I@V@Int32@n?I@V@Byte32@ix"(i32 %n, i32 %ix) {
Entry:
  %rem_pio2_quick_check.ret = alloca i1
  %n.addr = alloca i32
  %ix.addr = alloca i32
  %npio2_hw = alloca [32 x i32]
  store i1 false, i1* %rem_pio2_quick_check.ret
  store i32 %n, i32* %n.addr
  store i32 %ix, i32* %ix.addr
  store [32 x i32] [i32 1073291771, i32 1074340347, i32 1074977148, i32 1075388923, i32 1075800698, i32 1076025724, i32 1076231611, i32 1076437499, i32 1076643386, i32 1076849274, i32 1076971356, i32 1077074300, i32 1077177244, i32 1077280187, i32 1077383131, i32 1077486075, i32 1077589019, i32 1077691962, i32 1077794906, i32 1077897850, i32 1077968460, i32 1078019932, i32 1078071404, i32 1078122876, i32 1078174348, i32 1078225820, i32 1078277292, i32 1078328763, i32 1078380235, i32 1078431707, i32 1078483179, i32 1078534651], [32 x i32]* %npio2_hw
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load i32, i32* %n.addr
  %1 = icmp slt i32 %0, 32
  %2 = load i32, i32* %n.addr
  %3 = icmp sgt i32 %2, 0
  %4 = and i1 %1, %3
  br i1 %4, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %5 = load i1, i1* %rem_pio2_quick_check.ret
  ret i1 %5

bb4:                                              ; preds = %bb1
  %6 = load i32, i32* %n.addr
  %7 = sub i32 %6, 1
  %8 = sub i32 %7, 0
  %9 = getelementptr inbounds [32 x i32], [32 x i32]* %npio2_hw, i32 0, i32 %8
  %10 = load i32, i32* %ix.addr
  %11 = load i32, i32* %9
  %12 = icmp ne i32 %10, %11
  store i1 %12, i1* %rem_pio2_quick_check.ret
  br label %bb2
}

define double @"System.Math.FMod$I@V@Double@x?I@V@Double@y"(double %x, double %y) {
Entry:
  %FMod.ret = alloca double
  %x.addr = alloca double
  %y.addr = alloca double
  %tx = alloca i64
  %ty = alloca i64
  %z = alloca i64
  %xx = alloca double
  %i = alloca i32
  %n = alloca i32
  %ix = alloca i32
  %iy = alloca i32
  %sx = alloca i1
  store double 0.000000e+00, double* %FMod.ret
  store double %x, double* %x.addr
  store double %y, double* %y.addr
  store i64 0, i64* %tx
  store i64 0, i64* %ty
  store i64 0, i64* %z
  store double 0.000000e+00, double* %xx
  store i32 0, i32* %i
  store i32 0, i32* %n
  store i32 0, i32* %ix
  store i32 0, i32* %iy
  store i1 false, i1* %sx
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = bitcast double %0 to i64
  store i64 %1, i64* %tx
  %2 = load i64, i64* %tx
  %3 = and i64 %2, -9223372036854775808
  %4 = icmp ne i64 %3, 0
  store i1 %4, i1* %sx
  %5 = load i64, i64* %tx
  %6 = and i64 %5, 9223372036854775807
  store i64 %6, i64* %tx
  %7 = load double, double* %y.addr
  %8 = bitcast double %7 to i64
  %9 = and i64 %8, 9223372036854775807
  store i64 %9, i64* %ty
  %10 = load i64, i64* %ty
  %11 = icmp eq i64 %10, 0
  %12 = load i64, i64* %tx
  %13 = and i64 %12, -4294967296
  %14 = lshr i64 %13, 32
  %15 = trunc i64 %14 to i32
  %16 = icmp uge i32 %15, 2146435072
  %17 = or i1 %11, %16
  %18 = load i64, i64* %ty
  %19 = and i64 %18, -4294967296
  %20 = lshr i64 %19, 32
  %21 = trunc i64 %20 to i32
  %22 = icmp ugt i32 %21, 2146435072
  %23 = or i1 %17, %22
  br i1 %23, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %24 = load i64, i64* %tx
  %25 = load i64, i64* %ty
  %26 = icmp ule i64 %24, %25
  br i1 %26, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %27 = load double, double* %x.addr
  %28 = load double, double* %y.addr
  %29 = fmul double %27, %28
  %30 = load double, double* %x.addr
  %31 = load double, double* %y.addr
  %32 = fmul double %30, %31
  %33 = fdiv double %29, %32
  store double %33, double* %FMod.ret
  %34 = load double, double* %FMod.ret
  ret double %34

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb13, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %35 = load i64, i64* %tx
  %36 = and i64 %35, -4294967296
  %37 = lshr i64 %36, 32
  %38 = trunc i64 %37 to i32
  %39 = icmp ult i32 %38, 1048576
  br i1 %39, label %bb17, label %bb14

bb8:                                              ; preds = %bb3
  %40 = load i64, i64* %tx
  %41 = load i64, i64* %ty
  %42 = icmp ult i64 %40, %41
  br i1 %42, label %bb12, label %bb9

bb9:                                              ; preds = %bb8
  store double 0.000000e+00, double* %FMod.ret
  br label %bb10

bb10:                                             ; preds = %bb12, %bb9
  br label %bb11

bb11:                                             ; preds = %bb10
  %43 = load double, double* %FMod.ret
  ret double %43

bb12:                                             ; preds = %bb8
  %44 = load double, double* %x.addr
  store double %44, double* %FMod.ret
  br label %bb10

bb13:                                             ; No predecessors!
  br label %bb6

bb14:                                             ; preds = %bb7
  %45 = load i64, i64* %tx
  %46 = lshr i64 %45, 52
  %47 = trunc i64 %46 to i32
  %48 = sub i32 %47, 1023
  store i32 %48, i32* %ix
  br label %bb15

bb15:                                             ; preds = %bb25, %bb14
  br label %bb16

bb16:                                             ; preds = %bb15
  %49 = load i64, i64* %ty
  %50 = and i64 %49, -4294967296
  %51 = lshr i64 %50, 32
  %52 = trunc i64 %51 to i32
  %53 = icmp ult i32 %52, 1048576
  br i1 %53, label %bb29, label %bb26

bb17:                                             ; preds = %bb7
  %54 = load i64, i64* %tx
  %55 = and i64 %54, -4294967296
  %56 = lshr i64 %55, 32
  %57 = trunc i64 %56 to i32
  %58 = icmp eq i32 %57, 0
  br i1 %58, label %bb21, label %bb18

bb18:                                             ; preds = %bb17
  store i32 -1022, i32* %ix
  %59 = load i64, i64* %tx
  %60 = shl i64 %59, 11
  %61 = and i64 %60, -4294967296
  %62 = lshr i64 %61, 32
  %63 = trunc i64 %62 to i32
  store i32 %63, i32* %i
  br label %bb19

bb19:                                             ; preds = %bb21, %bb18
  br label %bb20

bb20:                                             ; preds = %bb19
  br label %bb22

bb21:                                             ; preds = %bb17
  store i32 -1043, i32* %ix
  %64 = load i64, i64* %tx
  %65 = and i64 %64, 4294967295
  %66 = lshr i64 %65, 0
  %67 = trunc i64 %66 to i32
  store i32 %67, i32* %i
  br label %bb19

bb22:                                             ; preds = %bb23, %bb20
  %68 = load i32, i32* %i
  %69 = and i32 %68, -2147483648
  %70 = icmp ne i32 %69, 0
  %71 = xor i1 %70, true
  br i1 %71, label %bb23, label %bb24

bb23:                                             ; preds = %bb22
  %72 = load i32, i32* %ix
  %73 = sub i32 %72, 1
  store i32 %73, i32* %ix
  %74 = load i32, i32* %i
  %75 = shl i32 %74, 1
  store i32 %75, i32* %i
  br label %bb22

bb24:                                             ; preds = %bb22
  br label %bb25

bb25:                                             ; preds = %bb24
  br label %bb15

bb26:                                             ; preds = %bb16
  %76 = load i64, i64* %ty
  %77 = lshr i64 %76, 52
  %78 = trunc i64 %77 to i32
  %79 = sub i32 %78, 1023
  store i32 %79, i32* %iy
  br label %bb27

bb27:                                             ; preds = %bb37, %bb26
  br label %bb28

bb28:                                             ; preds = %bb27
  %80 = load i32, i32* %ix
  %81 = icmp sge i32 %80, -1022
  br i1 %81, label %bb41, label %bb38

bb29:                                             ; preds = %bb16
  %82 = load i64, i64* %ty
  %83 = and i64 %82, -4294967296
  %84 = lshr i64 %83, 32
  %85 = trunc i64 %84 to i32
  %86 = icmp eq i32 %85, 0
  br i1 %86, label %bb33, label %bb30

bb30:                                             ; preds = %bb29
  store i32 -1022, i32* %iy
  %87 = load i64, i64* %ty
  %88 = shl i64 %87, 11
  %89 = and i64 %88, -4294967296
  %90 = lshr i64 %89, 32
  %91 = trunc i64 %90 to i32
  store i32 %91, i32* %i
  br label %bb31

bb31:                                             ; preds = %bb33, %bb30
  br label %bb32

bb32:                                             ; preds = %bb31
  br label %bb34

bb33:                                             ; preds = %bb29
  store i32 -1043, i32* %iy
  %92 = load i64, i64* %ty
  %93 = and i64 %92, 4294967295
  %94 = lshr i64 %93, 0
  %95 = trunc i64 %94 to i32
  store i32 %95, i32* %i
  br label %bb31

bb34:                                             ; preds = %bb35, %bb32
  %96 = load i32, i32* %i
  %97 = and i32 %96, -2147483648
  %98 = icmp ne i32 %97, 0
  %99 = xor i1 %98, true
  br i1 %99, label %bb35, label %bb36

bb35:                                             ; preds = %bb34
  %100 = load i32, i32* %iy
  %101 = sub i32 %100, 1
  store i32 %101, i32* %iy
  %102 = load i32, i32* %i
  %103 = shl i32 %102, 1
  store i32 %103, i32* %i
  br label %bb34

bb36:                                             ; preds = %bb34
  br label %bb37

bb37:                                             ; preds = %bb36
  br label %bb27

bb38:                                             ; preds = %bb28
  %104 = load i32, i32* %ix
  %105 = sub i32 -1022, %104
  store i32 %105, i32* %n
  %106 = load i32, i32* %n
  %107 = zext i32 %106 to i64
  %108 = load i64, i64* %tx
  %109 = shl i64 %108, %107
  store i64 %109, i64* %tx
  br label %bb39

bb39:                                             ; preds = %bb41, %bb38
  br label %bb40

bb40:                                             ; preds = %bb39
  %110 = load i32, i32* %iy
  %111 = icmp sge i32 %110, -1022
  br i1 %111, label %bb45, label %bb42

bb41:                                             ; preds = %bb28
  %112 = load i64, i64* %tx
  %113 = and i64 %112, -4294967296
  %114 = lshr i64 %113, 32
  %115 = trunc i64 %114 to i32
  %116 = and i32 1048575, %115
  %117 = or i32 1048576, %116
  %118 = load i64, i64* %tx
  %119 = and i64 %118, 4294967295
  %120 = zext i32 %117 to i64
  %121 = shl i64 %120, 32
  %122 = or i64 %119, %121
  store i64 %122, i64* %tx
  br label %bb39

bb42:                                             ; preds = %bb40
  %123 = load i32, i32* %iy
  %124 = sub i32 -1022, %123
  store i32 %124, i32* %n
  %125 = load i32, i32* %n
  %126 = zext i32 %125 to i64
  %127 = load i64, i64* %ty
  %128 = shl i64 %127, %126
  store i64 %128, i64* %ty
  br label %bb43

bb43:                                             ; preds = %bb45, %bb42
  br label %bb44

bb44:                                             ; preds = %bb43
  %129 = load i32, i32* %ix
  %130 = load i32, i32* %iy
  %131 = sub i32 %129, %130
  store i32 %131, i32* %n
  br label %bb46

bb45:                                             ; preds = %bb40
  %132 = load i64, i64* %ty
  %133 = and i64 %132, -4294967296
  %134 = lshr i64 %133, 32
  %135 = trunc i64 %134 to i32
  %136 = and i32 1048575, %135
  %137 = or i32 1048576, %136
  %138 = load i64, i64* %ty
  %139 = and i64 %138, 4294967295
  %140 = zext i32 %137 to i64
  %141 = shl i64 %140, 32
  %142 = or i64 %139, %141
  store i64 %142, i64* %ty
  br label %bb43

bb46:                                             ; preds = %bb52, %bb44
  %143 = load i32, i32* %n
  %144 = icmp sgt i32 %143, 0
  br i1 %144, label %bb47, label %bb48

bb47:                                             ; preds = %bb46
  %145 = load i32, i32* %n
  %146 = sub i32 %145, 1
  store i32 %146, i32* %n
  %147 = load i64, i64* %tx
  %148 = load i64, i64* %ty
  %149 = sub i64 %147, %148
  store i64 %149, i64* %z
  %150 = load i64, i64* %z
  %151 = icmp slt i64 %150, 0
  br i1 %151, label %bb53, label %bb50

bb48:                                             ; preds = %bb46
  br label %bb49

bb49:                                             ; preds = %bb48
  %152 = load i64, i64* %tx
  %153 = load i64, i64* %ty
  %154 = sub i64 %152, %153
  store i64 %154, i64* %z
  %155 = load i64, i64* %z
  %156 = and i64 %155, -9223372036854775808
  %157 = icmp ne i64 %156, 0
  %158 = xor i1 %157, true
  br i1 %158, label %bb60, label %bb58

bb50:                                             ; preds = %bb47
  %159 = load i64, i64* %z
  %160 = icmp eq i64 %159, 0
  br i1 %160, label %bb56, label %bb54

bb51:                                             ; preds = %bb55, %bb53
  br label %bb52

bb52:                                             ; preds = %bb51
  br label %bb46

bb53:                                             ; preds = %bb47
  %161 = load i64, i64* %tx
  %162 = shl i64 %161, 1
  store i64 %162, i64* %tx
  br label %bb51

bb54:                                             ; preds = %bb57, %bb50
  br label %bb55

bb55:                                             ; preds = %bb54
  %163 = load i64, i64* %z
  %164 = shl i64 %163, 1
  store i64 %164, i64* %tx
  br label %bb51

bb56:                                             ; preds = %bb50
  store double 0.000000e+00, double* %FMod.ret
  %165 = load double, double* %FMod.ret
  ret double %165

bb57:                                             ; No predecessors!
  br label %bb54

bb58:                                             ; preds = %bb60, %bb49
  br label %bb59

bb59:                                             ; preds = %bb58
  %166 = load i64, i64* %tx
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %bb63, label %bb61

bb60:                                             ; preds = %bb49
  %168 = load i64, i64* %z
  store i64 %168, i64* %tx
  br label %bb58

bb61:                                             ; preds = %bb64, %bb59
  br label %bb62

bb62:                                             ; preds = %bb61
  br label %bb65

bb63:                                             ; preds = %bb59
  store double 0.000000e+00, double* %FMod.ret
  %169 = load double, double* %FMod.ret
  ret double %169

bb64:                                             ; No predecessors!
  br label %bb61

bb65:                                             ; preds = %bb66, %bb62
  %170 = load i64, i64* %tx
  %171 = icmp ult i64 %170, 4503599627370496
  br i1 %171, label %bb66, label %bb67

bb66:                                             ; preds = %bb65
  %172 = load i64, i64* %tx
  %173 = shl i64 %172, 1
  store i64 %173, i64* %tx
  %174 = load i32, i32* %iy
  %175 = sub i32 %174, 1
  store i32 %175, i32* %iy
  br label %bb65

bb67:                                             ; preds = %bb65
  br label %bb68

bb68:                                             ; preds = %bb67
  %176 = load i32, i32* %iy
  %177 = icmp sge i32 %176, -1022
  br i1 %177, label %bb72, label %bb69

bb69:                                             ; preds = %bb68
  %178 = load i32, i32* %iy
  %179 = sub i32 -1022, %178
  store i32 %179, i32* %n
  %180 = load i32, i32* %n
  %181 = zext i32 %180 to i64
  %182 = load i64, i64* %tx
  %183 = lshr i64 %182, %181
  store i64 %183, i64* %tx
  br label %bb70

bb70:                                             ; preds = %bb72, %bb69
  br label %bb71

bb71:                                             ; preds = %bb70
  %184 = load i1, i1* %sx
  br i1 %184, label %bb75, label %bb73

bb72:                                             ; preds = %bb68
  %185 = load i64, i64* %tx
  %186 = and i64 %185, 4503599627370495
  %187 = load i32, i32* %iy
  %188 = add i32 %187, 1023
  %189 = zext i32 %188 to i64
  %190 = shl i64 %189, 52
  %191 = or i64 %186, %190
  store i64 %191, i64* %tx
  br label %bb70

bb73:                                             ; preds = %bb75, %bb71
  br label %bb74

bb74:                                             ; preds = %bb73
  %192 = load i64, i64* %tx
  %193 = bitcast i64 %192 to double
  store double %193, double* %xx
  %194 = load double, double* %xx
  store double %194, double* %FMod.ret
  %195 = load double, double* %FMod.ret
  ret double %195

bb75:                                             ; preds = %bb71
  %196 = load i64, i64* %tx
  %197 = and i64 %196, 9223372036854775807
  %198 = or i64 %197, -9223372036854775808
  store i64 %198, i64* %tx
  br label %bb73
}

define float @"System.Math.Exp$I@V@Float@value"(float %value) {
Entry:
  %Exp.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Exp.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Exp$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Exp.ret
  %4 = load float, float* %Exp.ret
  ret float %4
}

define double @"System.Math.Exp$I@V@Double@value"(double %value) {
Entry:
  %Exp.ret = alloca double
  %value.addr = alloca double
  %hx = alloca i32
  %hy = alloca i32
  %xx = alloca double
  %y = alloca double
  %hi = alloca double
  %lo = alloca double
  %c = alloca double
  %t = alloca double
  %yw = alloca i64
  %k = alloca i32
  %xsb = alloca i1
  store double 0.000000e+00, double* %Exp.ret
  store double %value, double* %value.addr
  store i32 0, i32* %hx
  store i32 0, i32* %hy
  store double 0.000000e+00, double* %xx
  store double 0.000000e+00, double* %y
  store double 0.000000e+00, double* %hi
  store double 0.000000e+00, double* %lo
  store double 0.000000e+00, double* %c
  store double 0.000000e+00, double* %t
  store i64 0, i64* %yw
  store i32 0, i32* %k
  store i1 false, i1* %xsb
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, -2147483648
  %7 = icmp ne i32 %6, 0
  store i1 %7, i1* %xsb
  %8 = load i32, i32* %hx
  %9 = and i32 %8, 2147483647
  store i32 %9, i32* %hx
  %10 = load i32, i32* %hx
  %11 = icmp uge i32 %10, 1082535490
  br i1 %11, label %bb4, label %bb2

bb2:                                              ; preds = %bb22, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %12 = load i32, i32* %hx
  %13 = icmp ugt i32 %12, 1071001154
  br i1 %13, label %bb28, label %bb25

bb4:                                              ; preds = %bb1
  %14 = load i32, i32* %hx
  %15 = icmp uge i32 %14, 2146435072
  br i1 %15, label %bb7, label %bb5

bb5:                                              ; preds = %bb16, %bb4
  br label %bb6

bb6:                                              ; preds = %bb5
  %16 = load double, double* %value.addr
  %17 = fcmp ogt double %16, 0x40862E42FEFA39EF
  br i1 %17, label %bb19, label %bb17

bb7:                                              ; preds = %bb4
  %18 = load i32, i32* %hx
  %19 = and i32 %18, 1048575
  %20 = load double, double* %value.addr
  %21 = bitcast double %20 to i64
  %22 = and i64 %21, 4294967295
  %23 = lshr i64 %22, 0
  %24 = trunc i64 %23 to i32
  %25 = or i32 %19, %24
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %bb10, label %bb8

bb8:                                              ; preds = %bb11, %bb7
  br label %bb9

bb9:                                              ; preds = %bb8
  %27 = load i1, i1* %xsb
  br i1 %27, label %bb15, label %bb12

bb10:                                             ; preds = %bb7
  %28 = load double, double* %value.addr
  %29 = load double, double* %value.addr
  %30 = fadd double %28, %29
  store double %30, double* %Exp.ret
  %31 = load double, double* %Exp.ret
  ret double %31

bb11:                                             ; No predecessors!
  br label %bb8

bb12:                                             ; preds = %bb9
  %32 = load double, double* %value.addr
  store double %32, double* %Exp.ret
  br label %bb13

bb13:                                             ; preds = %bb15, %bb12
  br label %bb14

bb14:                                             ; preds = %bb13
  %33 = load double, double* %Exp.ret
  ret double %33

bb15:                                             ; preds = %bb9
  store double 0.000000e+00, double* %Exp.ret
  br label %bb13

bb16:                                             ; No predecessors!
  br label %bb5

bb17:                                             ; preds = %bb20, %bb6
  br label %bb18

bb18:                                             ; preds = %bb17
  %34 = load double, double* %value.addr
  %35 = fcmp olt double %34, 0xC0874910D52D3051
  br i1 %35, label %bb23, label %bb21

bb19:                                             ; preds = %bb6
  store double 0x7FF0000000000000, double* %Exp.ret
  %36 = load double, double* %Exp.ret
  ret double %36

bb20:                                             ; No predecessors!
  br label %bb17

bb21:                                             ; preds = %bb24, %bb18
  br label %bb22

bb22:                                             ; preds = %bb21
  br label %bb2

bb23:                                             ; preds = %bb18
  store double 0.000000e+00, double* %Exp.ret
  %37 = load double, double* %Exp.ret
  ret double %37

bb24:                                             ; No predecessors!
  br label %bb21

bb25:                                             ; preds = %bb3
  %38 = load i32, i32* %hx
  %39 = icmp ult i32 %38, 1039138816
  %40 = load double, double* %value.addr
  %41 = fadd double 1.000000e+300, %40
  %42 = fcmp ogt double %41, 1.000000e+00
  %43 = and i1 %39, %42
  br i1 %43, label %bb43, label %bb41

bb26:                                             ; preds = %bb42, %bb31
  br label %bb27

bb27:                                             ; preds = %bb26
  %44 = load double, double* %xx
  %45 = load double, double* %xx
  %46 = fmul double %44, %45
  store double %46, double* %t
  %47 = load double, double* %t
  %48 = fmul double %47, 0x3E66376972BEA4D0
  %49 = fadd double 0xBEBBBD41C5D26BF1, %48
  %50 = load double, double* %t
  %51 = fmul double %50, %49
  %52 = fadd double 0x3F11566AAF25DE2C, %51
  %53 = load double, double* %t
  %54 = fmul double %53, %52
  %55 = fadd double 0xBF66C16C16BEBD93, %54
  %56 = load double, double* %t
  %57 = fmul double %56, %55
  %58 = fadd double 0x3FC555555555553E, %57
  %59 = load double, double* %t
  %60 = fmul double %59, %58
  %61 = load double, double* %xx
  %62 = fsub double %61, %60
  store double %62, double* %c
  %63 = load i32, i32* %k
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %bb47, label %bb45

bb28:                                             ; preds = %bb3
  %65 = load i32, i32* %hx
  %66 = icmp ult i32 %65, 1072734898
  br i1 %66, label %bb32, label %bb29

bb29:                                             ; preds = %bb28
  %67 = load i1, i1* %xsb
  br i1 %67, label %bb40, label %bb37

bb30:                                             ; preds = %bb39, %bb35
  br label %bb31

bb31:                                             ; preds = %bb30
  %68 = load double, double* %hi
  %69 = load double, double* %lo
  %70 = fsub double %68, %69
  store double %70, double* %xx
  br label %bb26

bb32:                                             ; preds = %bb28
  %71 = load i1, i1* %xsb
  br i1 %71, label %bb36, label %bb33

bb33:                                             ; preds = %bb32
  %72 = load double, double* %value.addr
  %73 = fsub double %72, 0x3FE62E42FEE00000
  store double %73, double* %hi
  store double 0x3DEA39EF35793C76, double* %lo
  store i32 1, i32* %k
  br label %bb34

bb34:                                             ; preds = %bb36, %bb33
  br label %bb35

bb35:                                             ; preds = %bb34
  br label %bb30

bb36:                                             ; preds = %bb32
  %74 = load double, double* %value.addr
  %75 = fadd double %74, 0x3FE62E42FEE00000
  store double %75, double* %hi
  store double 0xBDEA39EF35793C76, double* %lo
  store i32 -1, i32* %k
  br label %bb34

bb37:                                             ; preds = %bb29
  %76 = load double, double* %value.addr
  %77 = fmul double 0x3FF71547652B82FE, %76
  %78 = fadd double %77, 5.000000e-01
  %79 = call i32 @"$ax.sroundtoeven_f64_i32"(double %78)
  store i32 %79, i32* %k
  br label %bb38

bb38:                                             ; preds = %bb40, %bb37
  br label %bb39

bb39:                                             ; preds = %bb38
  %80 = load i32, i32* %k
  %81 = sitofp i32 %80 to double
  store double %81, double* %t
  %82 = load double, double* %t
  %83 = fmul double %82, 0x3FE62E42FEE00000
  %84 = load double, double* %value.addr
  %85 = fsub double %84, %83
  store double %85, double* %hi
  %86 = load double, double* %t
  %87 = fmul double %86, 0x3DEA39EF35793C76
  store double %87, double* %lo
  br label %bb30

bb40:                                             ; preds = %bb29
  %88 = load double, double* %value.addr
  %89 = fmul double 0x3FF71547652B82FE, %88
  %90 = fsub double %89, 5.000000e-01
  %91 = call i32 @"$ax.sroundtoeven_f64_i32"(double %90)
  store i32 %91, i32* %k
  br label %bb38

bb41:                                             ; preds = %bb44, %bb25
  br label %bb42

bb42:                                             ; preds = %bb41
  %92 = load double, double* %value.addr
  store double %92, double* %xx
  br label %bb26

bb43:                                             ; preds = %bb25
  %93 = load double, double* %value.addr
  %94 = fadd double 1.000000e+00, %93
  store double %94, double* %Exp.ret
  %95 = load double, double* %Exp.ret
  ret double %95

bb44:                                             ; No predecessors!
  br label %bb41

bb45:                                             ; preds = %bb48, %bb27
  br label %bb46

bb46:                                             ; preds = %bb45
  %96 = load double, double* %xx
  %97 = load double, double* %c
  %98 = fmul double %96, %97
  %99 = load double, double* %c
  %100 = fsub double 2.000000e+00, %99
  %101 = fdiv double %98, %100
  %102 = load double, double* %lo
  %103 = fsub double %102, %101
  %104 = load double, double* %hi
  %105 = fsub double %103, %104
  %106 = fsub double 1.000000e+00, %105
  store double %106, double* %y
  %107 = load double, double* %y
  %108 = bitcast double %107 to i64
  %109 = and i64 %108, -4294967296
  %110 = lshr i64 %109, 32
  %111 = trunc i64 %110 to i32
  store i32 %111, i32* %hy
  %112 = load i32, i32* %k
  %113 = icmp sge i32 %112, -1021
  br i1 %113, label %bb52, label %bb49

bb47:                                             ; preds = %bb27
  %114 = load double, double* %xx
  %115 = load double, double* %c
  %116 = fmul double %114, %115
  %117 = load double, double* %c
  %118 = fsub double %117, 2.000000e+00
  %119 = fdiv double %116, %118
  %120 = load double, double* %value.addr
  %121 = fsub double %119, %120
  %122 = fsub double 1.000000e+00, %121
  store double %122, double* %Exp.ret
  %123 = load double, double* %Exp.ret
  ret double %123

bb48:                                             ; No predecessors!
  br label %bb45

bb49:                                             ; preds = %bb46
  %124 = load double, double* %y
  %125 = bitcast double %124 to i64
  store i64 %125, i64* %yw
  %126 = load i32, i32* %k
  %127 = add i32 %126, 1000
  %128 = shl i32 %127, 20
  %129 = load i32, i32* %hy
  %130 = add i32 %129, %128
  %131 = load i64, i64* %yw
  %132 = and i64 %131, 4294967295
  %133 = zext i32 %130 to i64
  %134 = shl i64 %133, 32
  %135 = or i64 %132, %134
  store i64 %135, i64* %yw
  %136 = load i64, i64* %yw
  %137 = bitcast i64 %136 to double
  store double %137, double* %y
  %138 = load double, double* %y
  %139 = fmul double %138, 0x170000000000000
  store double %139, double* %Exp.ret
  br label %bb50

bb50:                                             ; preds = %bb52, %bb49
  br label %bb51

bb51:                                             ; preds = %bb50
  %140 = load double, double* %Exp.ret
  ret double %140

bb52:                                             ; preds = %bb46
  %141 = load double, double* %y
  %142 = bitcast double %141 to i64
  store i64 %142, i64* %yw
  %143 = load i32, i32* %k
  %144 = shl i32 %143, 20
  %145 = load i32, i32* %hy
  %146 = add i32 %145, %144
  %147 = load i64, i64* %yw
  %148 = and i64 %147, 4294967295
  %149 = zext i32 %146 to i64
  %150 = shl i64 %149, 32
  %151 = or i64 %148, %150
  store i64 %151, i64* %yw
  %152 = load i64, i64* %yw
  %153 = bitcast i64 %152 to double
  store double %153, double* %y
  %154 = load double, double* %y
  store double %154, double* %Exp.ret
  br label %bb50
}

define i1 @"System.Math.IsValid$I@V@Float@value"(float %value) {
Entry:
  %IsValid.ret = alloca i1
  %value.addr = alloca float
  %exponent = alloca i32
  store i1 false, i1* %IsValid.ret
  store float %value, float* %value.addr
  store i32 0, i32* %exponent
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = bitcast float %0 to i32
  %2 = lshr i32 %1, 23
  %3 = and i32 %2, 255
  store i32 %3, i32* %exponent
  %4 = load i32, i32* %exponent
  %5 = icmp ne i32 %4, 255
  store i1 %5, i1* %IsValid.ret
  %6 = load i1, i1* %IsValid.ret
  ret i1 %6
}

define i1 @"System.Math.IsValid$I@V@Double@value"(double %value) {
Entry:
  %IsValid.ret = alloca i1
  %value.addr = alloca double
  %exponent = alloca i64
  store i1 false, i1* %IsValid.ret
  store double %value, double* %value.addr
  store i64 0, i64* %exponent
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = lshr i64 %1, 52
  %3 = and i64 %2, 2047
  store i64 %3, i64* %exponent
  %4 = load i64, i64* %exponent
  %5 = icmp ne i64 %4, 2047
  store i1 %5, i1* %IsValid.ret
  %6 = load i1, i1* %IsValid.ret
  ret i1 %6
}

define float @"System.Math.Ln$I@V@Float@value"(float %value) {
Entry:
  %Ln.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Ln.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Ln$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Ln.ret
  %4 = load float, float* %Ln.ret
  ret float %4
}

define double @"System.Math.Ln$I@V@Double@value"(double %value) {
Entry:
  %Ln.ret = alloca double
  %value.addr = alloca double
  %xx = alloca double
  %hfsq = alloca double
  %f = alloca double
  %s = alloca double
  %z = alloca double
  %R = alloca double
  %w = alloca double
  %t1 = alloca double
  %t2 = alloca double
  %dk = alloca double
  %hx = alloca i32
  %i = alloca i32
  %j = alloca i32
  %k = alloca i32
  %xxw = alloca i64
  store double 0.000000e+00, double* %Ln.ret
  store double %value, double* %value.addr
  store double 0.000000e+00, double* %xx
  store double 0.000000e+00, double* %hfsq
  store double 0.000000e+00, double* %f
  store double 0.000000e+00, double* %s
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %R
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %t1
  store double 0.000000e+00, double* %t2
  store double 0.000000e+00, double* %dk
  store i32 0, i32* %hx
  store i32 0, i32* %i
  store i32 0, i32* %j
  store i32 0, i32* %k
  store i64 0, i64* %xxw
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  store i32 0, i32* %k
  %5 = load i32, i32* %hx
  %6 = and i32 %5, -2147483648
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %8 = load i32, i32* %hx
  %9 = icmp uge i32 %8, 2146435072
  br i1 %9, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %10 = load double, double* %value.addr
  %11 = load double, double* %value.addr
  %12 = fsub double %10, %11
  %13 = fdiv double %12, 0.000000e+00
  store double %13, double* %Ln.ret
  %14 = load double, double* %Ln.ret
  ret double %14

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %15 = load double, double* %value.addr
  store double %15, double* %xx
  %16 = load i32, i32* %hx
  %17 = icmp ult i32 %16, 1048576
  br i1 %17, label %bb12, label %bb10

bb8:                                              ; preds = %bb3
  %18 = load double, double* %value.addr
  %19 = load double, double* %value.addr
  %20 = fadd double %18, %19
  store double %20, double* %Ln.ret
  %21 = load double, double* %Ln.ret
  ret double %21

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb14, %bb7
  br label %bb11

bb11:                                             ; preds = %bb10
  %22 = load i32, i32* %hx
  %23 = lshr i32 %22, 20
  %24 = load i32, i32* %k
  %25 = add i32 %24, %23
  %26 = sub i32 %25, 1023
  store i32 %26, i32* %k
  %27 = load i32, i32* %hx
  %28 = and i32 %27, 1048575
  store i32 %28, i32* %hx
  %29 = load i32, i32* %hx
  %30 = add i32 %29, 614244
  %31 = and i32 %30, 1048576
  store i32 %31, i32* %i
  %32 = load double, double* %xx
  %33 = bitcast double %32 to i64
  store i64 %33, i64* %xxw
  %34 = load i32, i32* %i
  %35 = xor i32 %34, 1072693248
  %36 = load i32, i32* %hx
  %37 = or i32 %36, %35
  %38 = load i64, i64* %xxw
  %39 = and i64 %38, 4294967295
  %40 = zext i32 %37 to i64
  %41 = shl i64 %40, 32
  %42 = or i64 %39, %41
  store i64 %42, i64* %xxw
  %43 = load i64, i64* %xxw
  %44 = bitcast i64 %43 to double
  store double %44, double* %xx
  %45 = load i32, i32* %i
  %46 = lshr i32 %45, 20
  %47 = load i32, i32* %k
  %48 = add i32 %47, %46
  store i32 %48, i32* %k
  %49 = load double, double* %xx
  %50 = fsub double %49, 1.000000e+00
  store double %50, double* %f
  %51 = load i32, i32* %hx
  %52 = add i32 %51, 2
  %53 = and i32 1048575, %52
  %54 = icmp ult i32 %53, 3
  br i1 %54, label %bb19, label %bb17

bb12:                                             ; preds = %bb7
  %55 = load i32, i32* %hx
  %56 = and i32 %55, 2147483647
  %57 = load double, double* %value.addr
  %58 = bitcast double %57 to i64
  %59 = and i64 %58, 4294967295
  %60 = lshr i64 %59, 0
  %61 = trunc i64 %60 to i32
  %62 = or i32 %56, %61
  %63 = icmp eq i32 %62, 0
  br i1 %63, label %bb15, label %bb13

bb13:                                             ; preds = %bb16, %bb12
  br label %bb14

bb14:                                             ; preds = %bb13
  %64 = load i32, i32* %k
  %65 = sub i32 %64, 54
  store i32 %65, i32* %k
  %66 = load double, double* %xx
  %67 = fmul double %66, 0x4350000000000000
  store double %67, double* %xx
  %68 = load double, double* %xx
  %69 = bitcast double %68 to i64
  %70 = and i64 %69, -4294967296
  %71 = lshr i64 %70, 32
  %72 = trunc i64 %71 to i32
  store i32 %72, i32* %hx
  br label %bb10

bb15:                                             ; preds = %bb12
  store double 0xFFF0000000000000, double* %f
  %73 = load double, double* %f
  store double %73, double* %Ln.ret
  %74 = load double, double* %Ln.ret
  ret double %74

bb16:                                             ; No predecessors!
  br label %bb13

bb17:                                             ; preds = %bb32, %bb11
  br label %bb18

bb18:                                             ; preds = %bb17
  %75 = load double, double* %f
  %76 = fadd double 2.000000e+00, %75
  %77 = load double, double* %f
  %78 = fdiv double %77, %76
  store double %78, double* %s
  %79 = load i32, i32* %k
  %80 = sitofp i32 %79 to double
  store double %80, double* %dk
  %81 = load double, double* %s
  %82 = load double, double* %s
  %83 = fmul double %81, %82
  store double %83, double* %z
  %84 = load i32, i32* %hx
  %85 = sub i32 %84, 398458
  store i32 %85, i32* %i
  %86 = load double, double* %z
  %87 = load double, double* %z
  %88 = fmul double %86, %87
  store double %88, double* %w
  %89 = load i32, i32* %hx
  %90 = sub i32 440401, %89
  store i32 %90, i32* %j
  %91 = load double, double* %w
  %92 = fmul double %91, 0x3FC39A09D078C69F
  %93 = fadd double 0x3FCC71C51D8E78AF, %92
  %94 = load double, double* %w
  %95 = fmul double %94, %93
  %96 = fadd double 0x3FD999999997FA04, %95
  %97 = load double, double* %w
  %98 = fmul double %97, %96
  store double %98, double* %t1
  %99 = load double, double* %w
  %100 = fmul double %99, 0x3FC2F112DF3E5244
  %101 = fadd double 0x3FC7466496CB03DE, %100
  %102 = load double, double* %w
  %103 = fmul double %102, %101
  %104 = fadd double 0x3FD2492494229359, %103
  %105 = load double, double* %w
  %106 = fmul double %105, %104
  %107 = fadd double 0x3FE5555555555593, %106
  %108 = load double, double* %z
  %109 = fmul double %108, %107
  store double %109, double* %t2
  %110 = load i32, i32* %i
  %111 = load i32, i32* %j
  %112 = or i32 %110, %111
  store i32 %112, i32* %i
  %113 = load double, double* %t2
  %114 = load double, double* %t1
  %115 = fadd double %113, %114
  store double %115, double* %R
  %116 = load i32, i32* %i
  %117 = icmp ugt i32 %116, 0
  br i1 %117, label %bb36, label %bb33

bb19:                                             ; preds = %bb11
  %118 = load double, double* %f
  %119 = fcmp oeq double %118, 0.000000e+00
  br i1 %119, label %bb23, label %bb20

bb20:                                             ; preds = %bb19
  %120 = load double, double* %f
  %121 = load double, double* %f
  %122 = fmul double %120, %121
  %123 = load double, double* %f
  %124 = fmul double 0x3FD5555555555555, %123
  %125 = fsub double 5.000000e-01, %124
  %126 = fmul double %122, %125
  store double %126, double* %R
  %127 = load i32, i32* %k
  %128 = icmp eq i32 %127, 0
  br i1 %128, label %bb31, label %bb28

bb21:                                             ; preds = %bb30, %bb26
  br label %bb22

bb22:                                             ; preds = %bb21
  %129 = load double, double* %Ln.ret
  ret double %129

bb23:                                             ; preds = %bb19
  %130 = load i32, i32* %k
  %131 = icmp eq i32 %130, 0
  br i1 %131, label %bb27, label %bb24

bb24:                                             ; preds = %bb23
  %132 = load i32, i32* %k
  %133 = sitofp i32 %132 to double
  store double %133, double* %dk
  %134 = load double, double* %dk
  %135 = fmul double %134, 0x3FE62E42FEE00000
  %136 = load double, double* %dk
  %137 = fmul double %136, 0x3DEA39EF35793C76
  %138 = fadd double %135, %137
  store double %138, double* %Ln.ret
  br label %bb25

bb25:                                             ; preds = %bb27, %bb24
  br label %bb26

bb26:                                             ; preds = %bb25
  br label %bb21

bb27:                                             ; preds = %bb23
  store double 0.000000e+00, double* %Ln.ret
  br label %bb25

bb28:                                             ; preds = %bb20
  %139 = load i32, i32* %k
  %140 = sitofp i32 %139 to double
  store double %140, double* %dk
  %141 = load double, double* %dk
  %142 = fmul double %141, 0x3FE62E42FEE00000
  %143 = load double, double* %dk
  %144 = fmul double %143, 0x3DEA39EF35793C76
  %145 = load double, double* %R
  %146 = fsub double %145, %144
  %147 = load double, double* %f
  %148 = fsub double %146, %147
  %149 = fsub double %142, %148
  store double %149, double* %Ln.ret
  br label %bb29

bb29:                                             ; preds = %bb31, %bb28
  br label %bb30

bb30:                                             ; preds = %bb29
  br label %bb21

bb31:                                             ; preds = %bb20
  %150 = load double, double* %f
  %151 = load double, double* %R
  %152 = fsub double %150, %151
  store double %152, double* %Ln.ret
  br label %bb29

bb32:                                             ; No predecessors!
  br label %bb17

bb33:                                             ; preds = %bb18
  %153 = load i32, i32* %k
  %154 = icmp eq i32 %153, 0
  br i1 %154, label %bb44, label %bb41

bb34:                                             ; preds = %bb43, %bb39
  br label %bb35

bb35:                                             ; preds = %bb34
  %155 = load double, double* %Ln.ret
  ret double %155

bb36:                                             ; preds = %bb18
  %156 = load double, double* %f
  %157 = fmul double 5.000000e-01, %156
  %158 = load double, double* %f
  %159 = fmul double %157, %158
  store double %159, double* %hfsq
  %160 = load i32, i32* %k
  %161 = icmp eq i32 %160, 0
  br i1 %161, label %bb40, label %bb37

bb37:                                             ; preds = %bb36
  %162 = load double, double* %dk
  %163 = fmul double %162, 0x3FE62E42FEE00000
  %164 = load double, double* %hfsq
  %165 = load double, double* %R
  %166 = fadd double %164, %165
  %167 = load double, double* %s
  %168 = fmul double %167, %166
  %169 = load double, double* %dk
  %170 = fmul double %169, 0x3DEA39EF35793C76
  %171 = fadd double %168, %170
  %172 = load double, double* %hfsq
  %173 = fsub double %172, %171
  %174 = load double, double* %f
  %175 = fsub double %173, %174
  %176 = fsub double %163, %175
  store double %176, double* %Ln.ret
  br label %bb38

bb38:                                             ; preds = %bb40, %bb37
  br label %bb39

bb39:                                             ; preds = %bb38
  br label %bb34

bb40:                                             ; preds = %bb36
  %177 = load double, double* %hfsq
  %178 = load double, double* %R
  %179 = fadd double %177, %178
  %180 = load double, double* %s
  %181 = fmul double %180, %179
  %182 = load double, double* %hfsq
  %183 = fsub double %182, %181
  %184 = load double, double* %f
  %185 = fsub double %184, %183
  store double %185, double* %Ln.ret
  br label %bb38

bb41:                                             ; preds = %bb33
  %186 = load double, double* %dk
  %187 = fmul double %186, 0x3FE62E42FEE00000
  %188 = load double, double* %f
  %189 = load double, double* %R
  %190 = fsub double %188, %189
  %191 = load double, double* %s
  %192 = fmul double %191, %190
  %193 = load double, double* %dk
  %194 = fmul double %193, 0x3DEA39EF35793C76
  %195 = fsub double %192, %194
  %196 = load double, double* %f
  %197 = fsub double %195, %196
  %198 = fsub double %187, %197
  store double %198, double* %Ln.ret
  br label %bb42

bb42:                                             ; preds = %bb44, %bb41
  br label %bb43

bb43:                                             ; preds = %bb42
  br label %bb34

bb44:                                             ; preds = %bb33
  %199 = load double, double* %f
  %200 = load double, double* %R
  %201 = fsub double %199, %200
  %202 = load double, double* %s
  %203 = fmul double %202, %201
  %204 = load double, double* %f
  %205 = fsub double %204, %203
  store double %205, double* %Ln.ret
  br label %bb42
}

define float @"System.Math.Log10$I@V@Float@value"(float %value) {
Entry:
  %Log10.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Log10.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = call float @"System.Math.Ln$I@V@Float@value"(float %0)
  %2 = fdiv float %1, 0x40026BB1C0000000
  store float %2, float* %Log10.ret
  %3 = load float, float* %Log10.ret
  ret float %3
}

define double @"System.Math.Log10$I@V@Double@value"(double %value) {
Entry:
  %Log10.ret = alloca double
  %value.addr = alloca double
  store double 0.000000e+00, double* %Log10.ret
  store double %value, double* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %value.addr
  %1 = call double @"System.Math.Ln$I@V@Double@value"(double %0)
  %2 = fdiv double %1, 0x40026BB1BBB55516
  store double %2, double* %Log10.ret
  %3 = load double, double* %Log10.ret
  ret double %3
}

define float @"System.Math.Sin$I@V@Float@angle"(float %angle) {
Entry:
  %Sin.ret = alloca float
  %angle.addr = alloca float
  store float 0.000000e+00, float* %Sin.ret
  store float %angle, float* %angle.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %angle.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Sin$I@V@Double@angle"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Sin.ret
  %4 = load float, float* %Sin.ret
  ret float %4
}

define double @"System.Math.Sin$I@V@Double@angle"(double %angle) {
Entry:
  %Sin.ret = alloca double
  %angle.addr = alloca double
  %y0 = alloca double
  %y1 = alloca double
  %ix = alloca i32
  %n = alloca i32
  %0 = alloca double
  store double 0.000000e+00, double* %0
  %1 = alloca double
  store double 0.000000e+00, double* %1
  store double 0.000000e+00, double* %Sin.ret
  store double %angle, double* %angle.addr
  store double 0.000000e+00, double* %y0
  store double 0.000000e+00, double* %y1
  store i32 0, i32* %ix
  store i32 0, i32* %n
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load double, double* %angle.addr
  %3 = bitcast double %2 to i64
  %4 = and i64 %3, -4294967296
  %5 = lshr i64 %4, 32
  %6 = trunc i64 %5 to i32
  %7 = and i32 %6, 2147483647
  store i32 %7, i32* %ix
  %8 = load i32, i32* %ix
  %9 = icmp ule i32 %8, 1072243195
  br i1 %9, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %10 = load i32, i32* %ix
  %11 = icmp uge i32 %10, 2146435072
  br i1 %11, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %12 = load double, double* %angle.addr
  %13 = call double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %12, double 0.000000e+00, i1 false)
  store double %13, double* %Sin.ret
  %14 = load double, double* %Sin.ret
  ret double %14

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %15 = load double, double* %y0
  store double %15, double* %0
  %16 = load double, double* %y1
  store double %16, double* %1
  %17 = load double, double* %angle.addr
  %18 = call i32 @"System.MathInternal.rem_pio2$I@V@Double@x?O@V@Double@yy0?O@V@Double@yy1"(double %17, double* %0, double* %1)
  %19 = load double, double* %0
  store double %19, double* %y0
  %20 = load double, double* %1
  store double %20, double* %y1
  store i32 %18, i32* %n
  %21 = load i32, i32* %n
  switch i32 %21, label %bb14 [
    i32 0, label %bb11
    i32 1, label %bb12
    i32 2, label %bb13
  ]

bb8:                                              ; preds = %bb3
  %22 = load double, double* %angle.addr
  %23 = load double, double* %angle.addr
  %24 = fsub double %22, %23
  store double %24, double* %Sin.ret
  %25 = load double, double* %Sin.ret
  ret double %25

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb14, %bb13, %bb12, %bb11
  %26 = load double, double* %Sin.ret
  ret double %26

bb11:                                             ; preds = %bb7
  %27 = load double, double* %y0
  %28 = load double, double* %y1
  %29 = call double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %27, double %28, i1 true)
  store double %29, double* %Sin.ret
  br label %bb10

bb12:                                             ; preds = %bb7
  %30 = load double, double* %y0
  %31 = load double, double* %y1
  %32 = call double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %30, double %31)
  store double %32, double* %Sin.ret
  br label %bb10

bb13:                                             ; preds = %bb7
  %33 = load double, double* %y0
  %34 = load double, double* %y1
  %35 = call double @"System.MathInternal._kernel_sin$I@V@Double@x?I@V@Double@y?I@V@Int1@reduced"(double %33, double %34, i1 true)
  %36 = fsub double 0.000000e+00, %35
  store double %36, double* %Sin.ret
  br label %bb10

bb14:                                             ; preds = %bb7
  %37 = load double, double* %y0
  %38 = load double, double* %y1
  %39 = call double @"System.MathInternal._kernel_cos$I@V@Double@x?I@V@Double@y"(double %37, double %38)
  %40 = fsub double 0.000000e+00, %39
  store double %40, double* %Sin.ret
  br label %bb10
}

define float @"System.Math.Sqrt$I@V@Float@value"(float %value) {
Entry:
  %Sqrt.ret = alloca float
  %value.addr = alloca float
  store float 0.000000e+00, float* %Sqrt.ret
  store float %value, float* %value.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %value.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Sqrt$I@V@Double@value"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Sqrt.ret
  %4 = load float, float* %Sqrt.ret
  ret float %4
}

define float @"System.Math.Tan$I@V@Float@angle"(float %angle) {
Entry:
  %Tan.ret = alloca float
  %angle.addr = alloca float
  store float 0.000000e+00, float* %Tan.ret
  store float %angle, float* %angle.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load float, float* %angle.addr
  %1 = fpext float %0 to double
  %2 = call double @"System.Math.Tan$I@V@Double@angle"(double %1)
  %3 = fptrunc double %2 to float
  store float %3, float* %Tan.ret
  %4 = load float, float* %Tan.ret
  ret float %4
}

define double @"System.Math.Tan$I@V@Double@angle"(double %angle) {
Entry:
  %Tan.ret = alloca double
  %angle.addr = alloca double
  %y0 = alloca double
  %y1 = alloca double
  %ix = alloca i32
  %n = alloca i32
  %0 = alloca double
  store double 0.000000e+00, double* %0
  %1 = alloca double
  store double 0.000000e+00, double* %1
  store double 0.000000e+00, double* %Tan.ret
  store double %angle, double* %angle.addr
  store double 0.000000e+00, double* %y0
  store double 0.000000e+00, double* %y1
  store i32 0, i32* %ix
  store i32 0, i32* %n
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = load double, double* %angle.addr
  %3 = bitcast double %2 to i64
  %4 = and i64 %3, -4294967296
  %5 = lshr i64 %4, 32
  %6 = trunc i64 %5 to i32
  %7 = and i32 %6, 2147483647
  store i32 %7, i32* %ix
  %8 = load i32, i32* %ix
  %9 = icmp ule i32 %8, 1072243195
  br i1 %9, label %bb4, label %bb2

bb2:                                              ; preds = %bb5, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %10 = load i32, i32* %ix
  %11 = icmp uge i32 %10, 2146435072
  br i1 %11, label %bb8, label %bb6

bb4:                                              ; preds = %bb1
  %12 = load double, double* %angle.addr
  %13 = call double @"System.MathInternal._kernel_tan$I@V@Double@x?I@V@Double@y?I@V@Int32@iy"(double %12, double 0.000000e+00, i32 1)
  store double %13, double* %Tan.ret
  %14 = load double, double* %Tan.ret
  ret double %14

bb5:                                              ; No predecessors!
  br label %bb2

bb6:                                              ; preds = %bb9, %bb3
  br label %bb7

bb7:                                              ; preds = %bb6
  %15 = load double, double* %y0
  store double %15, double* %0
  %16 = load double, double* %y1
  store double %16, double* %1
  %17 = load double, double* %angle.addr
  %18 = call i32 @"System.MathInternal.rem_pio2$I@V@Double@x?O@V@Double@yy0?O@V@Double@yy1"(double %17, double* %0, double* %1)
  %19 = load double, double* %0
  store double %19, double* %y0
  %20 = load double, double* %1
  store double %20, double* %y1
  store i32 %18, i32* %n
  %21 = load i32, i32* %n
  %22 = and i32 %21, 1
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %bb13, label %bb10

bb8:                                              ; preds = %bb3
  %24 = load double, double* %angle.addr
  %25 = load double, double* %angle.addr
  %26 = fsub double %24, %25
  store double %26, double* %Tan.ret
  %27 = load double, double* %Tan.ret
  ret double %27

bb9:                                              ; No predecessors!
  br label %bb6

bb10:                                             ; preds = %bb7
  store i32 -1, i32* %n
  br label %bb11

bb11:                                             ; preds = %bb13, %bb10
  br label %bb12

bb12:                                             ; preds = %bb11
  %28 = load double, double* %y0
  %29 = load double, double* %y1
  %30 = load i32, i32* %n
  %31 = call double @"System.MathInternal._kernel_tan$I@V@Double@x?I@V@Double@y?I@V@Int32@iy"(double %28, double %29, i32 %30)
  store double %31, double* %Tan.ret
  %32 = load double, double* %Tan.ret
  ret double %32

bb13:                                             ; preds = %bb7
  store i32 1, i32* %n
  br label %bb11
}

define double @"System.MathInternal._kernel_tan$I@V@Double@x?I@V@Double@y?I@V@Int32@iy"(double %x, double %y, i32 %iy) {
Entry:
  %_kernel_tan.ret = alloca double
  %x.addr = alloca double
  %y.addr = alloca double
  %iy.addr = alloca i32
  %hx = alloca i32
  %ix = alloca i32
  %z = alloca double
  %r = alloca double
  %v = alloca double
  %w = alloca double
  %s = alloca double
  %a = alloca double
  %tt = alloca double
  %xx = alloca double
  %yy = alloca double
  store double 0.000000e+00, double* %_kernel_tan.ret
  store double %x, double* %x.addr
  store double %y, double* %y.addr
  store i32 %iy, i32* %iy.addr
  store i32 0, i32* %hx
  store i32 0, i32* %ix
  store double 0.000000e+00, double* %z
  store double 0.000000e+00, double* %r
  store double 0.000000e+00, double* %v
  store double 0.000000e+00, double* %w
  store double 0.000000e+00, double* %s
  store double 0.000000e+00, double* %a
  store double 0.000000e+00, double* %tt
  store double 0.000000e+00, double* %xx
  store double 0.000000e+00, double* %yy
  br label %bb1

bb1:                                              ; preds = %Entry
  %0 = load double, double* %x.addr
  %1 = bitcast double %0 to i64
  %2 = and i64 %1, -4294967296
  %3 = lshr i64 %2, 32
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %hx
  %5 = load i32, i32* %hx
  %6 = and i32 %5, 2147483647
  store i32 %6, i32* %ix
  %7 = load i32, i32* %ix
  %8 = icmp ult i32 %7, 1043333120
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb6, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = load double, double* %x.addr
  store double %9, double* %xx
  %10 = load double, double* %y.addr
  store double %10, double* %yy
  %11 = load i32, i32* %ix
  %12 = icmp uge i32 %11, 1072010280
  br i1 %12, label %bb18, label %bb16

bb4:                                              ; preds = %bb1
  %13 = load double, double* %x.addr
  %14 = call i32 @"$ax.sroundtoeven_f64_i32"(double %13)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %bb7, label %bb5

bb5:                                              ; preds = %bb15, %bb4
  br label %bb6

bb6:                                              ; preds = %bb5
  br label %bb2

bb7:                                              ; preds = %bb4
  %16 = load double, double* %x.addr
  %17 = bitcast double %16 to i64
  %18 = and i64 %17, 4294967295
  %19 = lshr i64 %18, 0
  %20 = trunc i64 %19 to i32
  %21 = load i32, i32* %ix
  %22 = or i32 %21, %20
  %23 = load i32, i32* %iy.addr
  %24 = add i32 %23, 1
  %25 = or i32 %22, %24
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %bb11, label %bb8

bb8:                                              ; preds = %bb7
  %27 = load double, double* %x.addr
  store double %27, double* %_kernel_tan.ret
  %28 = load i32, i32* %iy.addr
  %29 = icmp ne i32 %28, 1
  br i1 %29, label %bb14, label %bb12

bb9:                                              ; preds = %bb13, %bb11
  br label %bb10

bb10:                                             ; preds = %bb9
  %30 = load double, double* %_kernel_tan.ret
  ret double %30

bb11:                                             ; preds = %bb7
  %31 = load double, double* %x.addr
  %32 = call double @"System.Math.Abs$I@V@Double@value"(double %31)
  %33 = fdiv double 1.000000e+00, %32
  store double %33, double* %_kernel_tan.ret
  br label %bb9

bb12:                                             ; preds = %bb14, %bb8
  br label %bb13

bb13:                                             ; preds = %bb12
  br label %bb9

bb14:                                             ; preds = %bb8
  %34 = load double, double* %x.addr
  %35 = fdiv double -1.000000e+00, %34
  store double %35, double* %_kernel_tan.ret
  br label %bb12

bb15:                                             ; No predecessors!
  br label %bb5

bb16:                                             ; preds = %bb20, %bb3
  br label %bb17

bb17:                                             ; preds = %bb16
  %36 = load double, double* %xx
  %37 = load double, double* %xx
  %38 = fmul double %36, %37
  store double %38, double* %z
  %39 = load double, double* %z
  %40 = load double, double* %z
  %41 = fmul double %39, %40
  store double %41, double* %w
  %42 = load double, double* %w
  %43 = fmul double %42, 0xBEF375CBDB605373
  %44 = fadd double 0x3F147E88A03792A6, %43
  %45 = load double, double* %w
  %46 = fmul double %45, %44
  %47 = fadd double 0x3F4344D8F2F26501, %46
  %48 = load double, double* %w
  %49 = fmul double %48, %47
  %50 = fadd double 0x3F6D6D22C9560328, %49
  %51 = load double, double* %w
  %52 = fmul double %51, %50
  %53 = fadd double 0x3F9664F48406D637, %52
  %54 = load double, double* %w
  %55 = fmul double %54, %53
  %56 = fadd double 0x3FC111111110FE7A, %55
  store double %56, double* %r
  %57 = load double, double* %w
  %58 = fmul double %57, 0x3EFB2A7074BF7AD4
  %59 = fadd double 0x3F12B80F32F0A7E9, %58
  %60 = load double, double* %w
  %61 = fmul double %60, %59
  %62 = fadd double 0x3F3026F71A8D1068, %61
  %63 = load double, double* %w
  %64 = fmul double %63, %62
  %65 = fadd double 0x3F57DBC8FEE08315, %64
  %66 = load double, double* %w
  %67 = fmul double %66, %65
  %68 = fadd double 0x3F8226E3E96E8493, %67
  %69 = load double, double* %w
  %70 = fmul double %69, %68
  %71 = fadd double 0x3FABA1BA1BB341FE, %70
  %72 = load double, double* %z
  %73 = fmul double %72, %71
  store double %73, double* %v
  %74 = load double, double* %z
  %75 = load double, double* %xx
  %76 = fmul double %74, %75
  store double %76, double* %s
  %77 = load double, double* %r
  %78 = load double, double* %v
  %79 = fadd double %77, %78
  %80 = load double, double* %s
  %81 = fmul double %80, %79
  %82 = load double, double* %yy
  %83 = fadd double %81, %82
  %84 = load double, double* %z
  %85 = fmul double %84, %83
  %86 = load double, double* %yy
  %87 = fadd double %86, %85
  store double %87, double* %r
  %88 = load double, double* %s
  %89 = fmul double 0x3FD5555555555563, %88
  %90 = load double, double* %r
  %91 = fadd double %90, %89
  store double %91, double* %r
  %92 = load double, double* %xx
  %93 = load double, double* %r
  %94 = fadd double %92, %93
  store double %94, double* %w
  %95 = load i32, i32* %ix
  %96 = icmp uge i32 %95, 1072010280
  br i1 %96, label %bb24, label %bb22

bb18:                                             ; preds = %bb3
  %97 = load i32, i32* %hx
  %98 = and i32 %97, -2147483648
  %99 = icmp ne i32 %98, 0
  br i1 %99, label %bb21, label %bb19

bb19:                                             ; preds = %bb21, %bb18
  br label %bb20

bb20:                                             ; preds = %bb19
  %100 = load double, double* %xx
  %101 = fsub double 0x3FE921FB54442D18, %100
  store double %101, double* %z
  %102 = load double, double* %yy
  %103 = fsub double 0x3C81A62633145C07, %102
  store double %103, double* %w
  %104 = load double, double* %z
  %105 = load double, double* %w
  %106 = fadd double %104, %105
  store double %106, double* %xx
  store double 0.000000e+00, double* %yy
  br label %bb16

bb21:                                             ; preds = %bb18
  %107 = load double, double* %xx
  %108 = fsub double 0.000000e+00, %107
  store double %108, double* %xx
  %109 = load double, double* %yy
  %110 = fsub double 0.000000e+00, %109
  store double %110, double* %yy
  br label %bb19

bb22:                                             ; preds = %bb25, %bb17
  br label %bb23

bb23:                                             ; preds = %bb22
  %111 = load i32, i32* %iy.addr
  %112 = icmp eq i32 %111, 1
  br i1 %112, label %bb28, label %bb26

bb24:                                             ; preds = %bb17
  %113 = load i32, i32* %iy.addr
  %114 = sitofp i32 %113 to double
  store double %114, double* %v
  %115 = load i32, i32* %hx
  %116 = lshr i32 %115, 30
  %117 = and i32 %116, 2
  %118 = sub i32 1, %117
  %119 = sitofp i32 %118 to double
  %120 = load double, double* %w
  %121 = load double, double* %w
  %122 = fmul double %120, %121
  %123 = load double, double* %w
  %124 = load double, double* %v
  %125 = fadd double %123, %124
  %126 = fdiv double %122, %125
  %127 = load double, double* %r
  %128 = fsub double %126, %127
  %129 = load double, double* %xx
  %130 = fsub double %129, %128
  %131 = fmul double 2.000000e+00, %130
  %132 = load double, double* %v
  %133 = fsub double %132, %131
  %134 = fmul double %119, %133
  store double %134, double* %_kernel_tan.ret
  %135 = load double, double* %_kernel_tan.ret
  ret double %135

bb25:                                             ; No predecessors!
  br label %bb22

bb26:                                             ; preds = %bb29, %bb23
  br label %bb27

bb27:                                             ; preds = %bb26
  %136 = load double, double* %w
  %137 = bitcast double %136 to i64
  %138 = and i64 %137, -4294967296
  %139 = bitcast i64 %138 to double
  store double %139, double* %z
  %140 = load double, double* %z
  %141 = load double, double* %xx
  %142 = fsub double %140, %141
  %143 = load double, double* %r
  %144 = fsub double %143, %142
  store double %144, double* %v
  %145 = load double, double* %w
  %146 = fdiv double -1.000000e+00, %145
  store double %146, double* %a
  %147 = load double, double* %a
  %148 = bitcast double %147 to i64
  %149 = and i64 %148, -4294967296
  %150 = bitcast i64 %149 to double
  store double %150, double* %tt
  %151 = load double, double* %tt
  %152 = load double, double* %z
  %153 = fmul double %151, %152
  %154 = fadd double 1.000000e+00, %153
  store double %154, double* %s
  %155 = load double, double* %tt
  %156 = load double, double* %v
  %157 = fmul double %155, %156
  %158 = load double, double* %s
  %159 = fadd double %158, %157
  %160 = load double, double* %a
  %161 = fmul double %160, %159
  %162 = load double, double* %tt
  %163 = fadd double %162, %161
  store double %163, double* %_kernel_tan.ret
  %164 = load double, double* %_kernel_tan.ret
  ret double %164

bb28:                                             ; preds = %bb23
  %165 = load double, double* %w
  store double %165, double* %_kernel_tan.ret
  %166 = load double, double* %_kernel_tan.ret
  ret double %166

bb29:                                             ; No predecessors!
  br label %bb26
}

define %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3"(i8* %string1, i8* %string2, i8* %string3) {
Entry:
  %Concat.ret = alloca %STRING.0
  %string1.addr = alloca %STRING.0
  %string2.addr = alloca %STRING.0
  %string3.addr = alloca %STRING.0
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %Concat.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string1.addr
  %2 = bitcast %STRING.0* %string1.addr to i8*
  call void @"$ax.AssignST_String"(i8* %2, i8* %string1)
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string2.addr
  %3 = bitcast %STRING.0* %string2.addr to i8*
  call void @"$ax.AssignST_String"(i8* %3, i8* %string2)
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string3.addr
  %4 = bitcast %STRING.0* %string3.addr to i8*
  call void @"$ax.AssignST_String"(i8* %4, i8* %string3)
  br label %bb1

bb1:                                              ; preds = %Entry
  %5 = bitcast %STRING.0* %string1.addr to i8*
  %6 = bitcast %STRING.0* %string2.addr to i8*
  %7 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %5, i8* %6)
  store %STRING.0 %7, %STRING.0* %0
  %8 = bitcast %STRING.0* %0 to i8*
  %9 = bitcast %STRING.0* %string3.addr to i8*
  %10 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %8, i8* %9)
  store %STRING.0 %10, %STRING.0* %1
  %11 = bitcast %STRING.0* %Concat.ret to i8*
  %12 = bitcast %STRING.0* %1 to i8*
  call void @"$ax.AssignST_String"(i8* %11, i8* %12)
  %13 = load %STRING.0, %STRING.0* %Concat.ret
  ret %STRING.0 %13
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Concat_String(%STRING.0* noalias sret %0, i8* %1, i8* %2) #13 {
  %4 = alloca i8*, align 8
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = bitcast %STRING.0* %0 to i8*
  store i8* %7, i8** %4, align 8
  store i8* %2, i8** %5, align 8
  store i8* %1, i8** %6, align 8
  %8 = load i8*, i8** %5, align 8
  %9 = load i8*, i8** %6, align 8
  call void @"??$ax_Concat_String@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBD0@Z"(%STRING.0* sret %0, i8* %9, i8* %8)
  ret void
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local void @"??$ax_Concat_String@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBD0@Z"(%STRING.0* noalias sret %0, i8* %1, i8* %2) #13 comdat {
  %4 = alloca i8*, align 8
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = alloca %STRING.0*, align 8
  %8 = alloca %STRING.0*, align 8
  %9 = bitcast %STRING.0* %0 to i8*
  store i8* %9, i8** %4, align 8
  store i8* %2, i8** %5, align 8
  store i8* %1, i8** %6, align 8
  %10 = load i8*, i8** %6, align 8
  %11 = bitcast i8* %10 to %STRING.0*
  store %STRING.0* %11, %STRING.0** %7, align 8
  %12 = load i8*, i8** %5, align 8
  %13 = bitcast i8* %12 to %STRING.0*
  store %STRING.0* %13, %STRING.0** %8, align 8
  %14 = bitcast %STRING.0* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %14, i8 0, i64 257, i1 false)
  %15 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 0
  store i8 -2, i8* %15, align 1
  %16 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 0, i8* %16, align 1
  %17 = load %STRING.0*, %STRING.0** %8, align 8
  %18 = load %STRING.0*, %STRING.0** %7, align 8
  %19 = call zeroext i1 @"??$are_strings_ok_dss@Uax_ST_STRING@@@@YA_NPEAUax_ST_STRING@@PEBU0@1@Z"(%STRING.0* %0, %STRING.0* %18, %STRING.0* %17)
  br i1 %19, label %20, label %56

20:                                               ; preds = %3
  %21 = load %STRING.0*, %STRING.0** %8, align 8
  %22 = getelementptr inbounds %STRING.0, %STRING.0* %21, i32 0, i32 1
  %23 = load i8, i8* %22, align 1
  %24 = load %STRING.0*, %STRING.0** %7, align 8
  %25 = getelementptr inbounds %STRING.0, %STRING.0* %24, i32 0, i32 1
  %26 = load i8, i8* %25, align 1
  %27 = call i8 @"??$safe_add@Uax_ST_STRING@@@@YAEEE@Z"(i8 %26, i8 %23)
  %28 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 %27, i8* %28, align 1
  %29 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %30 = getelementptr inbounds [255 x i8], [255 x i8]* %29, i64 0, i64 0
  %31 = load %STRING.0*, %STRING.0** %7, align 8
  %32 = getelementptr inbounds %STRING.0, %STRING.0* %31, i32 0, i32 2
  %33 = getelementptr inbounds [255 x i8], [255 x i8]* %32, i64 0, i64 0
  %34 = load %STRING.0*, %STRING.0** %7, align 8
  %35 = getelementptr inbounds %STRING.0, %STRING.0* %34, i32 0, i32 1
  %36 = load i8, i8* %35, align 1
  %37 = zext i8 %36 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* align 1 %33, i64 %37, i1 false)
  %38 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %39 = load %STRING.0*, %STRING.0** %7, align 8
  %40 = getelementptr inbounds %STRING.0, %STRING.0* %39, i32 0, i32 1
  %41 = load i8, i8* %40, align 1
  %42 = zext i8 %41 to i64
  %43 = getelementptr inbounds [255 x i8], [255 x i8]* %38, i64 0, i64 %42
  %44 = load %STRING.0*, %STRING.0** %8, align 8
  %45 = getelementptr inbounds %STRING.0, %STRING.0* %44, i32 0, i32 2
  %46 = getelementptr inbounds [255 x i8], [255 x i8]* %45, i64 0, i64 0
  %47 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %48 = load i8, i8* %47, align 1
  %49 = zext i8 %48 to i32
  %50 = load %STRING.0*, %STRING.0** %7, align 8
  %51 = getelementptr inbounds %STRING.0, %STRING.0* %50, i32 0, i32 1
  %52 = load i8, i8* %51, align 1
  %53 = zext i8 %52 to i32
  %54 = sub nsw i32 %49, %53
  %55 = sext i32 %54 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %43, i8* align 1 %46, i64 %55, i1 false)
  br label %56

56:                                               ; preds = %20, %3
  %57 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %58 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %59 = load i8, i8* %58, align 1
  %60 = zext i8 %59 to i64
  %61 = getelementptr inbounds [255 x i8], [255 x i8]* %57, i64 0, i64 %60
  store i8 0, i8* %61, align 1
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #4

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local zeroext i1 @"??$are_strings_ok_dss@Uax_ST_STRING@@@@YA_NPEAUax_ST_STRING@@PEBU0@1@Z"(%STRING.0* %0, %STRING.0* %1, %STRING.0* %2) #13 comdat {
  %4 = alloca %STRING.0*, align 8
  %5 = alloca %STRING.0*, align 8
  %6 = alloca %STRING.0*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i8, align 1
  store %STRING.0* %2, %STRING.0** %4, align 8
  store %STRING.0* %1, %STRING.0** %5, align 8
  store %STRING.0* %0, %STRING.0** %6, align 8
  %11 = load %STRING.0*, %STRING.0** %5, align 8
  %12 = call i32 @"??$get_string_sign@Uax_ST_STRING@@@@YAHPEBUax_ST_STRING@@_N@Z"(%STRING.0* %11, i1 zeroext false)
  store i32 %12, i32* %7, align 4
  %13 = load %STRING.0*, %STRING.0** %4, align 8
  %14 = call i32 @"??$get_string_sign@Uax_ST_STRING@@@@YAHPEBUax_ST_STRING@@_N@Z"(%STRING.0* %13, i1 zeroext false)
  store i32 %14, i32* %8, align 4
  %15 = load %STRING.0*, %STRING.0** %6, align 8
  %16 = call i32 @"??$get_string_sign@Uax_ST_STRING@@@@YAHPEBUax_ST_STRING@@_N@Z"(%STRING.0* %15, i1 zeroext true)
  store i32 %16, i32* %9, align 4
  %17 = load i32, i32* %7, align 4
  %18 = icmp sge i32 %17, 0
  br i1 %18, label %19, label %25

19:                                               ; preds = %3
  %20 = load i32, i32* %8, align 4
  %21 = icmp sge i32 %20, 0
  br i1 %21, label %22, label %25

22:                                               ; preds = %19
  %23 = load i32, i32* %9, align 4
  %24 = icmp sge i32 %23, 0
  br label %25

25:                                               ; preds = %22, %19, %3
  %26 = phi i1 [ false, %19 ], [ false, %3 ], [ %24, %22 ]
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %10, align 1
  %28 = load i8, i8* %10, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %44

30:                                               ; preds = %25
  %31 = load %STRING.0*, %STRING.0** %5, align 8
  %32 = load %STRING.0*, %STRING.0** %6, align 8
  %33 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_STRING@@@@YA_NPEBUax_ST_STRING@@0@Z"(%STRING.0* %32, %STRING.0* %31)
  br i1 %33, label %42, label %34

34:                                               ; preds = %30
  %35 = load %STRING.0*, %STRING.0** %4, align 8
  %36 = load %STRING.0*, %STRING.0** %6, align 8
  %37 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_STRING@@@@YA_NPEBUax_ST_STRING@@0@Z"(%STRING.0* %36, %STRING.0* %35)
  br i1 %37, label %42, label %38

38:                                               ; preds = %34
  %39 = load %STRING.0*, %STRING.0** %4, align 8
  %40 = load %STRING.0*, %STRING.0** %5, align 8
  %41 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_STRING@@@@YA_NPEBUax_ST_STRING@@0@Z"(%STRING.0* %40, %STRING.0* %39)
  br i1 %41, label %42, label %43

42:                                               ; preds = %38, %34, %30
  store i8 0, i8* %10, align 1
  br label %43

43:                                               ; preds = %42, %38
  br label %44

44:                                               ; preds = %43, %25
  %45 = load i8, i8* %10, align 1
  %46 = trunc i8 %45 to i1
  br i1 %46, label %53, label %47

47:                                               ; preds = %44
  %48 = load i32, i32* %9, align 4
  %49 = icmp sge i32 %48, -2
  br i1 %49, label %50, label %53

50:                                               ; preds = %47
  %51 = load %STRING.0*, %STRING.0** %6, align 8
  %52 = getelementptr inbounds %STRING.0, %STRING.0* %51, i32 0, i32 1
  store i8 0, i8* %52, align 1
  br label %53

53:                                               ; preds = %50, %47, %44
  %54 = load i8, i8* %10, align 1
  %55 = trunc i8 %54 to i1
  ret i1 %55
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i8 @"??$safe_add@Uax_ST_STRING@@@@YAEEE@Z"(i8 %0, i8 %1) #13 comdat {
  %3 = alloca i8, align 1
  %4 = alloca i8, align 1
  %5 = alloca i8, align 1
  %6 = alloca i8, align 1
  store i8 %1, i8* %4, align 1
  store i8 %0, i8* %5, align 1
  %7 = load i8, i8* %5, align 1
  %8 = load i8, i8* %4, align 1
  %9 = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 %7, i8 %8)
  %10 = extractvalue { i8, i1 } %9, 1
  %11 = extractvalue { i8, i1 } %9, 0
  store i8 %11, i8* %6, align 1
  br i1 %10, label %12, label %13

12:                                               ; preds = %2
  store i8 -2, i8* %3, align 1
  br label %16

13:                                               ; preds = %2
  %14 = load i8, i8* %6, align 1
  %15 = call i8 @"??$cap@Uax_ST_STRING@@@@YAEE@Z"(i8 %14)
  store i8 %15, i8* %3, align 1
  br label %16

16:                                               ; preds = %13, %12
  %17 = load i8, i8* %3, align 1
  ret i8 %17
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind readnone speculatable willreturn
declare { i8, i1 } @llvm.uadd.with.overflow.i8(i8, i8) #0

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local i8 @"??$cap@Uax_ST_STRING@@@@YAEE@Z"(i8 %0) #14 comdat {
  %2 = alloca i8, align 1
  %3 = alloca i8, align 1
  store i8 %0, i8* %2, align 1
  store i8 -2, i8* %3, align 1
  %4 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %2, i8* dereferenceable(1) %3) #5
  %5 = load i8, i8* %4, align 1
  ret i8 %5
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %0, i8* dereferenceable(1) %1) #14 comdat {
  %3 = alloca i8*, align 8
  %4 = alloca i8*, align 8
  %5 = alloca i8*, align 8
  store i8* %1, i8** %4, align 8
  store i8* %0, i8** %5, align 8
  %6 = load i8*, i8** %4, align 8
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i32
  %9 = load i8*, i8** %5, align 8
  %10 = load i8, i8* %9, align 1
  %11 = zext i8 %10 to i32
  %12 = icmp slt i32 %8, %11
  br i1 %12, label %13, label %15

13:                                               ; preds = %2
  %14 = load i8*, i8** %4, align 8
  store i8* %14, i8** %3, align 8
  br label %17

15:                                               ; preds = %2
  %16 = load i8*, i8** %5, align 8
  store i8* %16, i8** %3, align 8
  br label %17

17:                                               ; preds = %15, %13
  %18 = load i8*, i8** %3, align 8
  ret i8* %18
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i32 @"??$get_string_sign@Uax_ST_STRING@@@@YAHPEBUax_ST_STRING@@_N@Z"(%STRING.0* %0, i1 zeroext %1) #13 comdat {
  %3 = alloca i32, align 4
  %4 = alloca i8, align 1
  %5 = alloca %STRING.0*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = zext i1 %1 to i8
  store i8 %10, i8* %4, align 1
  store %STRING.0* %0, %STRING.0** %5, align 8
  %11 = load %STRING.0*, %STRING.0** %5, align 8
  %12 = icmp eq %STRING.0* %11, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %2
  %14 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @"??_C@_03IGPHLJKL@NIL?$AA@", i64 0, i64 0))
  store i32 -4, i32* %3, align 4
  br label %39

15:                                               ; preds = %2
  store i32 255, i32* %6, align 4
  store i32 254, i32* %7, align 4
  %16 = load %STRING.0*, %STRING.0** %5, align 8
  %17 = getelementptr inbounds %STRING.0, %STRING.0* %16, i32 0, i32 0
  %18 = load i8, i8* %17, align 1
  %19 = zext i8 %18 to i32
  store i32 %19, i32* %8, align 4
  %20 = load %STRING.0*, %STRING.0** %5, align 8
  %21 = getelementptr inbounds %STRING.0, %STRING.0* %20, i32 0, i32 1
  %22 = load i8, i8* %21, align 1
  %23 = zext i8 %22 to i32
  store i32 %23, i32* %9, align 4
  %24 = load i32, i32* %8, align 4
  %25 = load i32, i32* %6, align 4
  %26 = icmp sgt i32 %24, %25
  br i1 %26, label %35, label %27

27:                                               ; preds = %15
  %28 = load i32, i32* %8, align 4
  %29 = load i32, i32* %7, align 4
  %30 = icmp sgt i32 %28, %29
  br i1 %30, label %35, label %31

31:                                               ; preds = %27
  %32 = load i32, i32* %9, align 4
  %33 = load i32, i32* %8, align 4
  %34 = icmp sgt i32 %32, %33
  br i1 %34, label %35, label %37

35:                                               ; preds = %31, %27, %15
  %36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @"??_C@_0P@EALMCFKA@STRING_CORRUPT?$AA@", i64 0, i64 0))
  store i32 -1, i32* %6, align 4
  br label %37

37:                                               ; preds = %35, %31
  %38 = load i32, i32* %6, align 4
  store i32 %38, i32* %3, align 4
  br label %39

39:                                               ; preds = %37, %13
  %40 = load i32, i32* %3, align 4
  ret i32 %40
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local zeroext i1 @"??$are_strings_overlapping@Uax_ST_STRING@@@@YA_NPEBUax_ST_STRING@@0@Z"(%STRING.0* %0, %STRING.0* %1) #14 comdat {
  %3 = alloca %STRING.0*, align 8
  %4 = alloca %STRING.0*, align 8
  store %STRING.0* %1, %STRING.0** %3, align 8
  store %STRING.0* %0, %STRING.0** %4, align 8
  %5 = load %STRING.0*, %STRING.0** %4, align 8
  %6 = load %STRING.0*, %STRING.0** %3, align 8
  %7 = icmp eq %STRING.0* %5, %6
  ret i1 %7
}

define %STRING.0 @"System.Strings.Concat$I@V@STRING@string1?I@V@STRING@string2?I@V@STRING@string3?I@V@STRING@string4"(i8* %string1, i8* %string2, i8* %string3, i8* %string4) {
Entry:
  %Concat.ret = alloca %STRING.0
  %string1.addr = alloca %STRING.0
  %string2.addr = alloca %STRING.0
  %string3.addr = alloca %STRING.0
  %string4.addr = alloca %STRING.0
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  %2 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %Concat.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string1.addr
  %3 = bitcast %STRING.0* %string1.addr to i8*
  call void @"$ax.AssignST_String"(i8* %3, i8* %string1)
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string2.addr
  %4 = bitcast %STRING.0* %string2.addr to i8*
  call void @"$ax.AssignST_String"(i8* %4, i8* %string2)
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string3.addr
  %5 = bitcast %STRING.0* %string3.addr to i8*
  call void @"$ax.AssignST_String"(i8* %5, i8* %string3)
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %string4.addr
  %6 = bitcast %STRING.0* %string4.addr to i8*
  call void @"$ax.AssignST_String"(i8* %6, i8* %string4)
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = bitcast %STRING.0* %string1.addr to i8*
  %8 = bitcast %STRING.0* %string2.addr to i8*
  %9 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %7, i8* %8)
  store %STRING.0 %9, %STRING.0* %0
  %10 = bitcast %STRING.0* %0 to i8*
  %11 = bitcast %STRING.0* %string3.addr to i8*
  %12 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %10, i8* %11)
  store %STRING.0 %12, %STRING.0* %1
  %13 = bitcast %STRING.0* %1 to i8*
  %14 = bitcast %STRING.0* %string4.addr to i8*
  %15 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i8*)* @ax_Concat_String to %STRING.0 (i8*, i8*)*)(i8* %13, i8* %14)
  store %STRING.0 %15, %STRING.0* %2
  %16 = bitcast %STRING.0* %Concat.ret to i8*
  %17 = bitcast %STRING.0* %2 to i8*
  call void @"$ax.AssignST_String"(i8* %16, i8* %17)
  %18 = load %STRING.0, %STRING.0* %Concat.ret
  ret %STRING.0 %18
}

define %WSTRING.6 @"System.Strings.Concat$I@V@WSTRING@string1?I@V@WSTRING@string2?I@V@WSTRING@string3"(i16* %string1, i16* %string2, i16* %string3) {
Entry:
  %Concat.ret = alloca %WSTRING.6
  %string1.addr = alloca %WSTRING.6
  %string2.addr = alloca %WSTRING.6
  %string3.addr = alloca %WSTRING.6
  %0 = alloca %WSTRING.6
  %1 = alloca %WSTRING.6
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %Concat.ret
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string1.addr
  %2 = bitcast %WSTRING.6* %string1.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %2, i16* %string1)
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string2.addr
  %3 = bitcast %WSTRING.6* %string2.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %3, i16* %string2)
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string3.addr
  %4 = bitcast %WSTRING.6* %string3.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %4, i16* %string3)
  br label %bb1

bb1:                                              ; preds = %Entry
  %5 = bitcast %WSTRING.6* %string1.addr to i16*
  %6 = bitcast %WSTRING.6* %string2.addr to i16*
  %7 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i16*)* @ax_Concat_WString to %WSTRING.6 (i16*, i16*)*)(i16* %5, i16* %6)
  store %WSTRING.6 %7, %WSTRING.6* %0
  %8 = bitcast %WSTRING.6* %0 to i16*
  %9 = bitcast %WSTRING.6* %string3.addr to i16*
  %10 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i16*)* @ax_Concat_WString to %WSTRING.6 (i16*, i16*)*)(i16* %8, i16* %9)
  store %WSTRING.6 %10, %WSTRING.6* %1
  %11 = bitcast %WSTRING.6* %Concat.ret to i16*
  %12 = bitcast %WSTRING.6* %1 to i16*
  call void @"$ax.AssignST_WString"(i16* %11, i16* %12)
  %13 = load %WSTRING.6, %WSTRING.6* %Concat.ret
  ret %WSTRING.6 %13
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Concat_WString(%WSTRING.6* noalias sret %0, i16* %1, i16* %2) #13 {
  %4 = alloca i8*, align 8
  %5 = alloca i16*, align 8
  %6 = alloca i16*, align 8
  %7 = bitcast %WSTRING.6* %0 to i8*
  store i8* %7, i8** %4, align 8
  store i16* %2, i16** %5, align 8
  store i16* %1, i16** %6, align 8
  %8 = load i16*, i16** %5, align 8
  %9 = load i16*, i16** %6, align 8
  call void @"??$ax_Concat_String@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBF0@Z"(%WSTRING.6* sret %0, i16* %9, i16* %8)
  ret void
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local void @"??$ax_Concat_String@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBF0@Z"(%WSTRING.6* noalias sret %0, i16* %1, i16* %2) #13 comdat {
  %4 = alloca i8*, align 8
  %5 = alloca i16*, align 8
  %6 = alloca i16*, align 8
  %7 = alloca %WSTRING.6*, align 8
  %8 = alloca %WSTRING.6*, align 8
  %9 = bitcast %WSTRING.6* %0 to i8*
  store i8* %9, i8** %4, align 8
  store i16* %2, i16** %5, align 8
  store i16* %1, i16** %6, align 8
  %10 = load i16*, i16** %6, align 8
  %11 = bitcast i16* %10 to %WSTRING.6*
  store %WSTRING.6* %11, %WSTRING.6** %7, align 8
  %12 = load i16*, i16** %5, align 8
  %13 = bitcast i16* %12 to %WSTRING.6*
  store %WSTRING.6* %13, %WSTRING.6** %8, align 8
  %14 = bitcast %WSTRING.6* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 2 %14, i8 0, i64 514, i1 false)
  %15 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 0
  store i16 254, i16* %15, align 2
  %16 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 0, i16* %16, align 2
  %17 = load %WSTRING.6*, %WSTRING.6** %8, align 8
  %18 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %19 = call zeroext i1 @"??$are_strings_ok_dss@Uax_ST_WSTRING@@@@YA_NPEAUax_ST_WSTRING@@PEBU0@1@Z"(%WSTRING.6* %0, %WSTRING.6* %18, %WSTRING.6* %17)
  br i1 %19, label %20, label %60

20:                                               ; preds = %3
  %21 = load %WSTRING.6*, %WSTRING.6** %8, align 8
  %22 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %21, i32 0, i32 1
  %23 = load i16, i16* %22, align 2
  %24 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %25 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %24, i32 0, i32 1
  %26 = load i16, i16* %25, align 2
  %27 = call i16 @"??$safe_add@Uax_ST_WSTRING@@@@YAGGG@Z"(i16 %26, i16 %23)
  %28 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 %27, i16* %28, align 2
  %29 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %30 = getelementptr inbounds [255 x i16], [255 x i16]* %29, i64 0, i64 0
  %31 = bitcast i16* %30 to i8*
  %32 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %33 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %32, i32 0, i32 2
  %34 = getelementptr inbounds [255 x i16], [255 x i16]* %33, i64 0, i64 0
  %35 = bitcast i16* %34 to i8*
  %36 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %37 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %36, i32 0, i32 1
  %38 = load i16, i16* %37, align 2
  %39 = zext i16 %38 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %31, i8* align 2 %35, i64 %39, i1 false)
  %40 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %41 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %42 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %41, i32 0, i32 1
  %43 = load i16, i16* %42, align 2
  %44 = zext i16 %43 to i64
  %45 = getelementptr inbounds [255 x i16], [255 x i16]* %40, i64 0, i64 %44
  %46 = bitcast i16* %45 to i8*
  %47 = load %WSTRING.6*, %WSTRING.6** %8, align 8
  %48 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %47, i32 0, i32 2
  %49 = getelementptr inbounds [255 x i16], [255 x i16]* %48, i64 0, i64 0
  %50 = bitcast i16* %49 to i8*
  %51 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %52 = load i16, i16* %51, align 2
  %53 = zext i16 %52 to i32
  %54 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %55 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %54, i32 0, i32 1
  %56 = load i16, i16* %55, align 2
  %57 = zext i16 %56 to i32
  %58 = sub nsw i32 %53, %57
  %59 = sext i32 %58 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %46, i8* align 2 %50, i64 %59, i1 false)
  br label %60

60:                                               ; preds = %20, %3
  %61 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %62 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %63 = load i16, i16* %62, align 2
  %64 = zext i16 %63 to i64
  %65 = getelementptr inbounds [255 x i16], [255 x i16]* %61, i64 0, i64 %64
  store i16 0, i16* %65, align 2
  ret void
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local zeroext i1 @"??$are_strings_ok_dss@Uax_ST_WSTRING@@@@YA_NPEAUax_ST_WSTRING@@PEBU0@1@Z"(%WSTRING.6* %0, %WSTRING.6* %1, %WSTRING.6* %2) #13 comdat {
  %4 = alloca %WSTRING.6*, align 8
  %5 = alloca %WSTRING.6*, align 8
  %6 = alloca %WSTRING.6*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i8, align 1
  store %WSTRING.6* %2, %WSTRING.6** %4, align 8
  store %WSTRING.6* %1, %WSTRING.6** %5, align 8
  store %WSTRING.6* %0, %WSTRING.6** %6, align 8
  %11 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %12 = call i32 @"??$get_string_sign@Uax_ST_WSTRING@@@@YAHPEBUax_ST_WSTRING@@_N@Z"(%WSTRING.6* %11, i1 zeroext false)
  store i32 %12, i32* %7, align 4
  %13 = load %WSTRING.6*, %WSTRING.6** %4, align 8
  %14 = call i32 @"??$get_string_sign@Uax_ST_WSTRING@@@@YAHPEBUax_ST_WSTRING@@_N@Z"(%WSTRING.6* %13, i1 zeroext false)
  store i32 %14, i32* %8, align 4
  %15 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %16 = call i32 @"??$get_string_sign@Uax_ST_WSTRING@@@@YAHPEBUax_ST_WSTRING@@_N@Z"(%WSTRING.6* %15, i1 zeroext true)
  store i32 %16, i32* %9, align 4
  %17 = load i32, i32* %7, align 4
  %18 = icmp sge i32 %17, 0
  br i1 %18, label %19, label %25

19:                                               ; preds = %3
  %20 = load i32, i32* %8, align 4
  %21 = icmp sge i32 %20, 0
  br i1 %21, label %22, label %25

22:                                               ; preds = %19
  %23 = load i32, i32* %9, align 4
  %24 = icmp sge i32 %23, 0
  br label %25

25:                                               ; preds = %22, %19, %3
  %26 = phi i1 [ false, %19 ], [ false, %3 ], [ %24, %22 ]
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %10, align 1
  %28 = load i8, i8* %10, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %44

30:                                               ; preds = %25
  %31 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %32 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %33 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_WSTRING@@@@YA_NPEBUax_ST_WSTRING@@0@Z"(%WSTRING.6* %32, %WSTRING.6* %31)
  br i1 %33, label %42, label %34

34:                                               ; preds = %30
  %35 = load %WSTRING.6*, %WSTRING.6** %4, align 8
  %36 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %37 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_WSTRING@@@@YA_NPEBUax_ST_WSTRING@@0@Z"(%WSTRING.6* %36, %WSTRING.6* %35)
  br i1 %37, label %42, label %38

38:                                               ; preds = %34
  %39 = load %WSTRING.6*, %WSTRING.6** %4, align 8
  %40 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %41 = call zeroext i1 @"??$are_strings_overlapping@Uax_ST_WSTRING@@@@YA_NPEBUax_ST_WSTRING@@0@Z"(%WSTRING.6* %40, %WSTRING.6* %39)
  br i1 %41, label %42, label %43

42:                                               ; preds = %38, %34, %30
  store i8 0, i8* %10, align 1
  br label %43

43:                                               ; preds = %42, %38
  br label %44

44:                                               ; preds = %43, %25
  %45 = load i8, i8* %10, align 1
  %46 = trunc i8 %45 to i1
  br i1 %46, label %53, label %47

47:                                               ; preds = %44
  %48 = load i32, i32* %9, align 4
  %49 = icmp sge i32 %48, -2
  br i1 %49, label %50, label %53

50:                                               ; preds = %47
  %51 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %52 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %51, i32 0, i32 1
  store i16 0, i16* %52, align 2
  br label %53

53:                                               ; preds = %50, %47, %44
  %54 = load i8, i8* %10, align 1
  %55 = trunc i8 %54 to i1
  ret i1 %55
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i16 @"??$safe_add@Uax_ST_WSTRING@@@@YAGGG@Z"(i16 %0, i16 %1) #13 comdat {
  %3 = alloca i16, align 2
  %4 = alloca i16, align 2
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  store i16 %1, i16* %4, align 2
  store i16 %0, i16* %5, align 2
  %7 = load i16, i16* %5, align 2
  %8 = load i16, i16* %4, align 2
  %9 = call { i16, i1 } @llvm.uadd.with.overflow.i16(i16 %7, i16 %8)
  %10 = extractvalue { i16, i1 } %9, 1
  %11 = extractvalue { i16, i1 } %9, 0
  store i16 %11, i16* %6, align 2
  br i1 %10, label %12, label %13

12:                                               ; preds = %2
  store i16 254, i16* %3, align 2
  br label %16

13:                                               ; preds = %2
  %14 = load i16, i16* %6, align 2
  %15 = call i16 @"??$cap@Uax_ST_WSTRING@@@@YAGG@Z"(i16 %14)
  store i16 %15, i16* %3, align 2
  br label %16

16:                                               ; preds = %13, %12
  %17 = load i16, i16* %3, align 2
  ret i16 %17
}

; Function Attrs: nounwind readnone speculatable willreturn
declare { i16, i1 } @llvm.uadd.with.overflow.i16(i16, i16) #0

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local i16 @"??$cap@Uax_ST_WSTRING@@@@YAGG@Z"(i16 %0) #14 comdat {
  %2 = alloca i16, align 2
  %3 = alloca i16, align 2
  store i16 %0, i16* %2, align 2
  store i16 254, i16* %3, align 2
  %4 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %2, i16* dereferenceable(2) %3) #5
  %5 = load i16, i16* %4, align 2
  ret i16 %5
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %0, i16* dereferenceable(2) %1) #14 comdat {
  %3 = alloca i16*, align 8
  %4 = alloca i16*, align 8
  %5 = alloca i16*, align 8
  store i16* %1, i16** %4, align 8
  store i16* %0, i16** %5, align 8
  %6 = load i16*, i16** %4, align 8
  %7 = load i16, i16* %6, align 2
  %8 = zext i16 %7 to i32
  %9 = load i16*, i16** %5, align 8
  %10 = load i16, i16* %9, align 2
  %11 = zext i16 %10 to i32
  %12 = icmp slt i32 %8, %11
  br i1 %12, label %13, label %15

13:                                               ; preds = %2
  %14 = load i16*, i16** %4, align 8
  store i16* %14, i16** %3, align 8
  br label %17

15:                                               ; preds = %2
  %16 = load i16*, i16** %5, align 8
  store i16* %16, i16** %3, align 8
  br label %17

17:                                               ; preds = %15, %13
  %18 = load i16*, i16** %3, align 8
  ret i16* %18
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i32 @"??$get_string_sign@Uax_ST_WSTRING@@@@YAHPEBUax_ST_WSTRING@@_N@Z"(%WSTRING.6* %0, i1 zeroext %1) #13 comdat {
  %3 = alloca i32, align 4
  %4 = alloca i8, align 1
  %5 = alloca %WSTRING.6*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = zext i1 %1 to i8
  store i8 %10, i8* %4, align 1
  store %WSTRING.6* %0, %WSTRING.6** %5, align 8
  %11 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %12 = icmp eq %WSTRING.6* %11, null
  br i1 %12, label %13, label %15

13:                                               ; preds = %2
  %14 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @"??_C@_03IGPHLJKL@NIL?$AA@", i64 0, i64 0))
  store i32 -4, i32* %3, align 4
  br label %39

15:                                               ; preds = %2
  store i32 255, i32* %6, align 4
  store i32 254, i32* %7, align 4
  %16 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %17 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %16, i32 0, i32 0
  %18 = load i16, i16* %17, align 2
  %19 = zext i16 %18 to i32
  store i32 %19, i32* %8, align 4
  %20 = load %WSTRING.6*, %WSTRING.6** %5, align 8
  %21 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %20, i32 0, i32 1
  %22 = load i16, i16* %21, align 2
  %23 = zext i16 %22 to i32
  store i32 %23, i32* %9, align 4
  %24 = load i32, i32* %8, align 4
  %25 = load i32, i32* %6, align 4
  %26 = icmp sgt i32 %24, %25
  br i1 %26, label %35, label %27

27:                                               ; preds = %15
  %28 = load i32, i32* %8, align 4
  %29 = load i32, i32* %7, align 4
  %30 = icmp sgt i32 %28, %29
  br i1 %30, label %35, label %31

31:                                               ; preds = %27
  %32 = load i32, i32* %9, align 4
  %33 = load i32, i32* %8, align 4
  %34 = icmp sgt i32 %32, %33
  br i1 %34, label %35, label %37

35:                                               ; preds = %31, %27, %15
  %36 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @"??_C@_0P@EALMCFKA@STRING_CORRUPT?$AA@", i64 0, i64 0))
  store i32 -1, i32* %6, align 4
  br label %37

37:                                               ; preds = %35, %31
  %38 = load i32, i32* %6, align 4
  store i32 %38, i32* %3, align 4
  br label %39

39:                                               ; preds = %37, %13
  %40 = load i32, i32* %3, align 4
  ret i32 %40
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local zeroext i1 @"??$are_strings_overlapping@Uax_ST_WSTRING@@@@YA_NPEBUax_ST_WSTRING@@0@Z"(%WSTRING.6* %0, %WSTRING.6* %1) #14 comdat {
  %3 = alloca %WSTRING.6*, align 8
  %4 = alloca %WSTRING.6*, align 8
  store %WSTRING.6* %1, %WSTRING.6** %3, align 8
  store %WSTRING.6* %0, %WSTRING.6** %4, align 8
  %5 = load %WSTRING.6*, %WSTRING.6** %4, align 8
  %6 = load %WSTRING.6*, %WSTRING.6** %3, align 8
  %7 = icmp eq %WSTRING.6* %5, %6
  ret i1 %7
}

define %WSTRING.6 @"System.Strings.Concat$I@V@WSTRING@string1?I@V@WSTRING@string2?I@V@WSTRING@string3?I@V@WSTRING@string4"(i16* %string1, i16* %string2, i16* %string3, i16* %string4) {
Entry:
  %Concat.ret = alloca %WSTRING.6
  %string1.addr = alloca %WSTRING.6
  %string2.addr = alloca %WSTRING.6
  %string3.addr = alloca %WSTRING.6
  %string4.addr = alloca %WSTRING.6
  %0 = alloca %WSTRING.6
  %1 = alloca %WSTRING.6
  %2 = alloca %WSTRING.6
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %Concat.ret
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string1.addr
  %3 = bitcast %WSTRING.6* %string1.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %3, i16* %string1)
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string2.addr
  %4 = bitcast %WSTRING.6* %string2.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %4, i16* %string2)
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string3.addr
  %5 = bitcast %WSTRING.6* %string3.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %5, i16* %string3)
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %string4.addr
  %6 = bitcast %WSTRING.6* %string4.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %6, i16* %string4)
  br label %bb1

bb1:                                              ; preds = %Entry
  %7 = bitcast %WSTRING.6* %string1.addr to i16*
  %8 = bitcast %WSTRING.6* %string2.addr to i16*
  %9 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i16*)* @ax_Concat_WString to %WSTRING.6 (i16*, i16*)*)(i16* %7, i16* %8)
  store %WSTRING.6 %9, %WSTRING.6* %0
  %10 = bitcast %WSTRING.6* %0 to i16*
  %11 = bitcast %WSTRING.6* %string3.addr to i16*
  %12 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i16*)* @ax_Concat_WString to %WSTRING.6 (i16*, i16*)*)(i16* %10, i16* %11)
  store %WSTRING.6 %12, %WSTRING.6* %1
  %13 = bitcast %WSTRING.6* %1 to i16*
  %14 = bitcast %WSTRING.6* %string4.addr to i16*
  %15 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i16*)* @ax_Concat_WString to %WSTRING.6 (i16*, i16*)*)(i16* %13, i16* %14)
  store %WSTRING.6 %15, %WSTRING.6* %2
  %16 = bitcast %WSTRING.6* %Concat.ret to i16*
  %17 = bitcast %WSTRING.6* %2 to i16*
  call void @"$ax.AssignST_WString"(i16* %16, i16* %17)
  %18 = load %WSTRING.6, %WSTRING.6* %Concat.ret
  ret %WSTRING.6 %18
}

define %STRING.0 @"System.Strings.EndOf$I@V@STRING@value?I@V@Int16@length"(i8* %value, i16 %length) {
Entry:
  %EndOf.ret = alloca %STRING.0
  %value.addr = alloca %STRING.0
  %length.addr = alloca i16
  %startPos = alloca i16
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %EndOf.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %value.addr
  %1 = bitcast %STRING.0* %value.addr to i8*
  call void @"$ax.AssignST_String"(i8* %1, i8* %value)
  store i16 %length, i16* %length.addr
  store i16 0, i16* %startPos
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %STRING.0* %value.addr to i8*
  %3 = call i16 @ax_LenST_String(i8* %2)
  %4 = load i16, i16* %length.addr
  %5 = sub i16 %3, %4
  %6 = add i16 %5, 1
  store i16 %6, i16* %startPos
  %7 = load i16, i16* %startPos
  %8 = icmp sle i16 %7, 0
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = bitcast %STRING.0* %value.addr to i8*
  %10 = load i16, i16* %startPos
  %11 = load i16, i16* %length.addr
  %12 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i16, i16)* @ax_Substring_String to %STRING.0 (i8*, i16, i16)*)(i8* %9, i16 %10, i16 %11)
  store %STRING.0 %12, %STRING.0* %0
  %13 = bitcast %STRING.0* %EndOf.ret to i8*
  %14 = bitcast %STRING.0* %0 to i8*
  call void @"$ax.AssignST_String"(i8* %13, i8* %14)
  %15 = load %STRING.0, %STRING.0* %EndOf.ret
  ret %STRING.0 %15

bb4:                                              ; preds = %bb1
  store i16 1, i16* %startPos
  br label %bb2
}

; Function Attrs: noinline optnone uwtable
define dso_local i16 @ax_LenST_String(i8* %0) #13 {
  %2 = alloca i8*, align 8
  store i8* %0, i8** %2, align 8
  %3 = load i8*, i8** %2, align 8
  %4 = call i32 @"??$ax_StrLen@Uax_ST_STRING@@@@YAHPEBD@Z"(i8* %3)
  %5 = trunc i32 %4 to i16
  ret i16 %5
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Substring_String(%STRING.0* noalias sret %0, i8* %1, i16 %2, i16 %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i8*, align 8
  %9 = bitcast %STRING.0* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i16 %3, i16* %6, align 2
  store i16 %2, i16* %7, align 2
  store i8* %1, i8** %8, align 8
  %10 = load i16, i16* %6, align 2
  %11 = sext i16 %10 to i32
  %12 = load i16, i16* %7, align 2
  %13 = sext i16 %12 to i32
  %14 = load i8*, i8** %8, align 8
  call void @"??$ax_Substring@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z"(%STRING.0* sret %0, i8* %14, i32 %13, i32 %11)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local void @"??$ax_Substring@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z"(%STRING.0* noalias sret %0, i8* %1, i32 %2, i32 %3) #14 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i8*, align 8
  %9 = alloca %STRING.0*, align 8
  %10 = alloca i8, align 1
  %11 = alloca i8, align 1
  %12 = bitcast %STRING.0* %0 to i8*
  store i8* %12, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i8* %1, i8** %8, align 8
  %13 = load i8*, i8** %8, align 8
  %14 = bitcast i8* %13 to %STRING.0*
  store %STRING.0* %14, %STRING.0** %9, align 8
  %15 = bitcast %STRING.0* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %15, i8 0, i64 257, i1 false)
  %16 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 0
  store i8 -2, i8* %16, align 1
  %17 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 0, i8* %17, align 1
  %18 = load i32, i32* %7, align 4
  %19 = icmp sle i32 %18, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %4
  %21 = load i32, i32* %7, align 4
  %22 = load %STRING.0*, %STRING.0** %9, align 8
  %23 = getelementptr inbounds %STRING.0, %STRING.0* %22, i32 0, i32 1
  %24 = load i8, i8* %23, align 1
  %25 = zext i8 %24 to i32
  %26 = icmp sge i32 %21, %25
  br i1 %26, label %30, label %27

27:                                               ; preds = %20
  %28 = load i32, i32* %6, align 4
  %29 = icmp slt i32 %28, 0
  br i1 %29, label %30, label %31

30:                                               ; preds = %27, %20, %4
  br label %65

31:                                               ; preds = %27
  %32 = load %STRING.0*, %STRING.0** %9, align 8
  %33 = getelementptr inbounds %STRING.0, %STRING.0* %32, i32 0, i32 1
  %34 = load i8, i8* %33, align 1
  %35 = zext i8 %34 to i32
  %36 = load i32, i32* %7, align 4
  %37 = sub nsw i32 %36, 1
  %38 = sub nsw i32 %35, %37
  %39 = trunc i32 %38 to i8
  store i8 %39, i8* %10, align 1
  %40 = load i32, i32* %6, align 4
  %41 = trunc i32 %40 to i8
  store i8 %41, i8* %11, align 1
  %42 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %11, i8* dereferenceable(1) %10) #5
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i32
  store i32 %44, i32* %6, align 4
  %45 = load i32, i32* %6, align 4
  %46 = trunc i32 %45 to i8
  %47 = call i8 @"??$cap@Uax_ST_STRING@@@@YAEE@Z"(i8 %46)
  %48 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 %47, i8* %48, align 1
  %49 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %50 = getelementptr inbounds [255 x i8], [255 x i8]* %49, i64 0, i64 0
  %51 = load %STRING.0*, %STRING.0** %9, align 8
  %52 = getelementptr inbounds %STRING.0, %STRING.0* %51, i32 0, i32 2
  %53 = load i32, i32* %7, align 4
  %54 = sub nsw i32 %53, 1
  %55 = sext i32 %54 to i64
  %56 = getelementptr inbounds [255 x i8], [255 x i8]* %52, i64 0, i64 %55
  %57 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %58 = load i8, i8* %57, align 1
  %59 = zext i8 %58 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %50, i8* align 1 %56, i64 %59, i1 false)
  %60 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %61 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %62 = load i8, i8* %61, align 1
  %63 = zext i8 %62 to i64
  %64 = getelementptr inbounds [255 x i8], [255 x i8]* %60, i64 0, i64 %63
  store i8 0, i8* %64, align 1
  br label %65

65:                                               ; preds = %31, %30
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local i32 @"??$ax_StrLen@Uax_ST_STRING@@@@YAHPEBD@Z"(i8* %0) #14 comdat {
  %2 = alloca i8*, align 8
  %3 = alloca %STRING.0*, align 8
  store i8* %0, i8** %2, align 8
  %4 = load i8*, i8** %2, align 8
  %5 = bitcast i8* %4 to %STRING.0*
  store %STRING.0* %5, %STRING.0** %3, align 8
  %6 = load %STRING.0*, %STRING.0** %3, align 8
  %7 = getelementptr inbounds %STRING.0, %STRING.0* %6, i32 0, i32 1
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  ret i32 %9
}

define %WSTRING.6 @"System.Strings.EndOf$I@V@WSTRING@value?I@V@Int32@length"(i16* %value, i32 %length) {
Entry:
  %EndOf.ret = alloca %WSTRING.6
  %value.addr = alloca %WSTRING.6
  %length.addr = alloca i32
  %startPos = alloca i32
  %0 = alloca %WSTRING.6
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %EndOf.ret
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %value.addr
  %1 = bitcast %WSTRING.6* %value.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %1, i16* %value)
  store i32 %length, i32* %length.addr
  store i32 0, i32* %startPos
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %WSTRING.6* %value.addr to i16*
  %3 = call i32 @ax_LenST_WString(i16* %2)
  %4 = load i32, i32* %length.addr
  %5 = sub i32 %3, %4
  %6 = add i32 %5, 1
  store i32 %6, i32* %startPos
  %7 = load i32, i32* %startPos
  %8 = icmp sle i32 %7, 0
  br i1 %8, label %bb4, label %bb2

bb2:                                              ; preds = %bb4, %bb1
  br label %bb3

bb3:                                              ; preds = %bb2
  %9 = bitcast %WSTRING.6* %value.addr to i16*
  %10 = load i32, i32* %startPos
  %11 = load i32, i32* %length.addr
  %12 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i32, i32)* @ax_Substring_WString to %WSTRING.6 (i16*, i32, i32)*)(i16* %9, i32 %10, i32 %11)
  store %WSTRING.6 %12, %WSTRING.6* %0
  %13 = bitcast %WSTRING.6* %EndOf.ret to i16*
  %14 = bitcast %WSTRING.6* %0 to i16*
  call void @"$ax.AssignST_WString"(i16* %13, i16* %14)
  %15 = load %WSTRING.6, %WSTRING.6* %EndOf.ret
  ret %WSTRING.6 %15

bb4:                                              ; preds = %bb1
  store i32 1, i32* %startPos
  br label %bb2
}

; Function Attrs: noinline optnone uwtable
define dso_local i32 @ax_LenST_WString(i16* %0) #13 {
  %2 = alloca i16*, align 8
  store i16* %0, i16** %2, align 8
  %3 = load i16*, i16** %2, align 8
  %4 = call i32 @"??$ax_StrLen@Uax_ST_WSTRING@@@@YAHPEBF@Z"(i16* %3)
  ret i32 %4
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Substring_WString(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i32 %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = bitcast %WSTRING.6* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %10 = load i32, i32* %6, align 4
  %11 = load i32, i32* %7, align 4
  %12 = load i16*, i16** %8, align 8
  call void @"??$ax_Substring@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z"(%WSTRING.6* sret %0, i16* %12, i32 %11, i32 %10)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local void @"??$ax_Substring@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z"(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i32 %3) #14 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = alloca %WSTRING.6*, align 8
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = bitcast %WSTRING.6* %0 to i8*
  store i8* %12, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %13 = load i16*, i16** %8, align 8
  %14 = bitcast i16* %13 to %WSTRING.6*
  store %WSTRING.6* %14, %WSTRING.6** %9, align 8
  %15 = bitcast %WSTRING.6* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 2 %15, i8 0, i64 514, i1 false)
  %16 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 0
  store i16 254, i16* %16, align 2
  %17 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 0, i16* %17, align 2
  %18 = load i32, i32* %7, align 4
  %19 = icmp sle i32 %18, 0
  br i1 %19, label %30, label %20

20:                                               ; preds = %4
  %21 = load i32, i32* %7, align 4
  %22 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %23 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %22, i32 0, i32 1
  %24 = load i16, i16* %23, align 2
  %25 = zext i16 %24 to i32
  %26 = icmp sge i32 %21, %25
  br i1 %26, label %30, label %27

27:                                               ; preds = %20
  %28 = load i32, i32* %6, align 4
  %29 = icmp slt i32 %28, 0
  br i1 %29, label %30, label %31

30:                                               ; preds = %27, %20, %4
  br label %67

31:                                               ; preds = %27
  %32 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %33 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %32, i32 0, i32 1
  %34 = load i16, i16* %33, align 2
  %35 = zext i16 %34 to i32
  %36 = load i32, i32* %7, align 4
  %37 = sub nsw i32 %36, 1
  %38 = sub nsw i32 %35, %37
  %39 = trunc i32 %38 to i16
  store i16 %39, i16* %10, align 2
  %40 = load i32, i32* %6, align 4
  %41 = trunc i32 %40 to i16
  store i16 %41, i16* %11, align 2
  %42 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %11, i16* dereferenceable(2) %10) #5
  %43 = load i16, i16* %42, align 2
  %44 = zext i16 %43 to i32
  store i32 %44, i32* %6, align 4
  %45 = load i32, i32* %6, align 4
  %46 = trunc i32 %45 to i16
  %47 = call i16 @"??$cap@Uax_ST_WSTRING@@@@YAGG@Z"(i16 %46)
  %48 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 %47, i16* %48, align 2
  %49 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %50 = getelementptr inbounds [255 x i16], [255 x i16]* %49, i64 0, i64 0
  %51 = bitcast i16* %50 to i8*
  %52 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %53 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %52, i32 0, i32 2
  %54 = load i32, i32* %7, align 4
  %55 = sub nsw i32 %54, 1
  %56 = sext i32 %55 to i64
  %57 = getelementptr inbounds [255 x i16], [255 x i16]* %53, i64 0, i64 %56
  %58 = bitcast i16* %57 to i8*
  %59 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %60 = load i16, i16* %59, align 2
  %61 = zext i16 %60 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %51, i8* align 2 %58, i64 %61, i1 false)
  %62 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %63 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %64 = load i16, i16* %63, align 2
  %65 = zext i16 %64 to i64
  %66 = getelementptr inbounds [255 x i16], [255 x i16]* %62, i64 0, i64 %65
  store i16 0, i16* %66, align 2
  br label %67

67:                                               ; preds = %31, %30
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local i32 @"??$ax_StrLen@Uax_ST_WSTRING@@@@YAHPEBF@Z"(i16* %0) #14 comdat {
  %2 = alloca i16*, align 8
  %3 = alloca %WSTRING.6*, align 8
  store i16* %0, i16** %2, align 8
  %4 = load i16*, i16** %2, align 8
  %5 = bitcast i16* %4 to %WSTRING.6*
  store %WSTRING.6* %5, %WSTRING.6** %3, align 8
  %6 = load %WSTRING.6*, %WSTRING.6** %3, align 8
  %7 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %6, i32 0, i32 1
  %8 = load i16, i16* %7, align 2
  %9 = zext i16 %8 to i32
  ret i32 %9
}

define %STRING.0 @"System.Strings.Replace$I@V@STRING@value?I@V@Int16@startPosition?I@V@Int16@length?I@V@STRING@replaceValue"(i8* %value, i16 %startPosition, i16 %length, i8* %replaceValue) {
Entry:
  %Replace.ret = alloca %STRING.0
  %value.addr = alloca %STRING.0
  %startPosition.addr = alloca i16
  %length.addr = alloca i16
  %replaceValue.addr = alloca %STRING.0
  %0 = alloca %STRING.0
  %1 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %Replace.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %value.addr
  %2 = bitcast %STRING.0* %value.addr to i8*
  call void @"$ax.AssignST_String"(i8* %2, i8* %value)
  store i16 %startPosition, i16* %startPosition.addr
  store i16 %length, i16* %length.addr
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %replaceValue.addr
  %3 = bitcast %STRING.0* %replaceValue.addr to i8*
  call void @"$ax.AssignST_String"(i8* %3, i8* %replaceValue)
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = bitcast %STRING.0* %value.addr to i8*
  %5 = load i16, i16* %startPosition.addr
  %6 = load i16, i16* %length.addr
  %7 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i16, i16)* @ax_Remove_String to %STRING.0 (i8*, i16, i16)*)(i8* %4, i16 %5, i16 %6)
  store %STRING.0 %7, %STRING.0* %0
  %8 = load i16, i16* %startPosition.addr
  %9 = sub i16 %8, 1
  %10 = bitcast %STRING.0* %0 to i8*
  %11 = bitcast %STRING.0* %replaceValue.addr to i8*
  %12 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i16, i8*)* @ax_Insert_String to %STRING.0 (i8*, i16, i8*)*)(i8* %10, i16 %9, i8* %11)
  store %STRING.0 %12, %STRING.0* %1
  %13 = bitcast %STRING.0* %Replace.ret to i8*
  %14 = bitcast %STRING.0* %1 to i8*
  call void @"$ax.AssignST_String"(i8* %13, i8* %14)
  %15 = load %STRING.0, %STRING.0* %Replace.ret
  ret %STRING.0 %15
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Remove_String(%STRING.0* noalias sret %0, i8* %1, i16 %2, i16 %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i8*, align 8
  %9 = bitcast %STRING.0* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i16 %3, i16* %6, align 2
  store i16 %2, i16* %7, align 2
  store i8* %1, i8** %8, align 8
  %10 = load i16, i16* %6, align 2
  %11 = sext i16 %10 to i32
  %12 = load i16, i16* %7, align 2
  %13 = sext i16 %12 to i32
  %14 = load i8*, i8** %8, align 8
  call void @"??$ax_Remove@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z"(%STRING.0* sret %0, i8* %14, i32 %13, i32 %11)
  ret void
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Insert_String(%STRING.0* noalias sret %0, i8* %1, i16 %2, i8* %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = alloca i16, align 2
  %8 = alloca i8*, align 8
  %9 = bitcast %STRING.0* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i8* %3, i8** %6, align 8
  store i16 %2, i16* %7, align 2
  store i8* %1, i8** %8, align 8
  %10 = load i8*, i8** %6, align 8
  %11 = load i16, i16* %7, align 2
  %12 = sext i16 %11 to i32
  %13 = load i8*, i8** %8, align 8
  call void @"??$ax_Insert@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDH0@Z"(%STRING.0* sret %0, i8* %13, i32 %12, i8* %10)
  ret void
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local void @"??$ax_Insert@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDH0@Z"(%STRING.0* noalias sret %0, i8* %1, i32 %2, i8* %3) #13 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i8*, align 8
  %9 = alloca %STRING.0*, align 8
  %10 = alloca %STRING.0*, align 8
  %11 = alloca i8, align 1
  %12 = alloca i32, align 4
  %13 = alloca i8, align 1
  %14 = alloca i8, align 1
  %15 = alloca i8, align 1
  %16 = alloca i8, align 1
  %17 = alloca i8, align 1
  %18 = bitcast %STRING.0* %0 to i8*
  store i8* %18, i8** %5, align 8
  store i8* %3, i8** %6, align 8
  store i32 %2, i32* %7, align 4
  store i8* %1, i8** %8, align 8
  %19 = load i8*, i8** %8, align 8
  %20 = bitcast i8* %19 to %STRING.0*
  store %STRING.0* %20, %STRING.0** %9, align 8
  %21 = load i8*, i8** %6, align 8
  %22 = bitcast i8* %21 to %STRING.0*
  store %STRING.0* %22, %STRING.0** %10, align 8
  %23 = bitcast %STRING.0* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %23, i8 0, i64 257, i1 false)
  %24 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 0
  store i8 -2, i8* %24, align 1
  %25 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 0, i8* %25, align 1
  %26 = load i32, i32* %7, align 4
  %27 = icmp slt i32 %26, 0
  br i1 %27, label %28, label %29

28:                                               ; preds = %4
  br label %107

29:                                               ; preds = %4
  %30 = load %STRING.0*, %STRING.0** %10, align 8
  %31 = getelementptr inbounds %STRING.0, %STRING.0* %30, i32 0, i32 1
  %32 = load i8, i8* %31, align 1
  %33 = load %STRING.0*, %STRING.0** %9, align 8
  %34 = getelementptr inbounds %STRING.0, %STRING.0* %33, i32 0, i32 1
  %35 = load i8, i8* %34, align 1
  %36 = call i8 @"??$safe_add@Uax_ST_STRING@@@@YAEEE@Z"(i8 %35, i8 %32)
  %37 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 %36, i8* %37, align 1
  %38 = load %STRING.0*, %STRING.0** %9, align 8
  %39 = getelementptr inbounds %STRING.0, %STRING.0* %38, i32 0, i32 1
  %40 = load i32, i32* %7, align 4
  %41 = trunc i32 %40 to i8
  store i8 %41, i8* %11, align 1
  %42 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %11, i8* dereferenceable(1) %39) #5
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i32
  store i32 %44, i32* %7, align 4
  %45 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %46 = getelementptr inbounds [255 x i8], [255 x i8]* %45, i64 0, i64 0
  %47 = load %STRING.0*, %STRING.0** %9, align 8
  %48 = getelementptr inbounds %STRING.0, %STRING.0* %47, i32 0, i32 2
  %49 = getelementptr inbounds [255 x i8], [255 x i8]* %48, i64 0, i64 0
  %50 = load i32, i32* %7, align 4
  %51 = sext i32 %50 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %46, i8* align 1 %49, i64 %51, i1 false)
  %52 = load i32, i32* %7, align 4
  store i32 %52, i32* %12, align 4
  %53 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %54 = load i8, i8* %53, align 1
  %55 = zext i8 %54 to i32
  %56 = load i32, i32* %12, align 4
  %57 = sub nsw i32 %55, %56
  %58 = trunc i32 %57 to i8
  store i8 %58, i8* %14, align 1
  %59 = load %STRING.0*, %STRING.0** %10, align 8
  %60 = getelementptr inbounds %STRING.0, %STRING.0* %59, i32 0, i32 1
  %61 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %60, i8* dereferenceable(1) %14) #5
  %62 = load i8, i8* %61, align 1
  store i8 %62, i8* %13, align 1
  %63 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %64 = load i32, i32* %12, align 4
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds [255 x i8], [255 x i8]* %63, i64 0, i64 %65
  %67 = load %STRING.0*, %STRING.0** %10, align 8
  %68 = getelementptr inbounds %STRING.0, %STRING.0* %67, i32 0, i32 2
  %69 = getelementptr inbounds [255 x i8], [255 x i8]* %68, i64 0, i64 0
  %70 = load i8, i8* %13, align 1
  %71 = zext i8 %70 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %66, i8* align 1 %69, i64 %71, i1 false)
  %72 = load i8, i8* %13, align 1
  %73 = zext i8 %72 to i32
  %74 = load i32, i32* %12, align 4
  %75 = add nsw i32 %74, %73
  store i32 %75, i32* %12, align 4
  %76 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %77 = load i8, i8* %76, align 1
  %78 = zext i8 %77 to i32
  %79 = load i32, i32* %12, align 4
  %80 = sub nsw i32 %78, %79
  %81 = trunc i32 %80 to i8
  store i8 %81, i8* %16, align 1
  %82 = load %STRING.0*, %STRING.0** %9, align 8
  %83 = getelementptr inbounds %STRING.0, %STRING.0* %82, i32 0, i32 1
  %84 = load i8, i8* %83, align 1
  %85 = zext i8 %84 to i32
  %86 = load i32, i32* %7, align 4
  %87 = sub nsw i32 %85, %86
  %88 = trunc i32 %87 to i8
  store i8 %88, i8* %17, align 1
  %89 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %17, i8* dereferenceable(1) %16) #5
  %90 = load i8, i8* %89, align 1
  store i8 %90, i8* %15, align 1
  %91 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %92 = load i32, i32* %12, align 4
  %93 = sext i32 %92 to i64
  %94 = getelementptr inbounds [255 x i8], [255 x i8]* %91, i64 0, i64 %93
  %95 = load %STRING.0*, %STRING.0** %9, align 8
  %96 = getelementptr inbounds %STRING.0, %STRING.0* %95, i32 0, i32 2
  %97 = load i32, i32* %7, align 4
  %98 = sext i32 %97 to i64
  %99 = getelementptr inbounds [255 x i8], [255 x i8]* %96, i64 0, i64 %98
  %100 = load i8, i8* %15, align 1
  %101 = zext i8 %100 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %94, i8* align 1 %99, i64 %101, i1 false)
  %102 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %103 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %104 = load i8, i8* %103, align 1
  %105 = zext i8 %104 to i64
  %106 = getelementptr inbounds [255 x i8], [255 x i8]* %102, i64 0, i64 %105
  store i8 0, i8* %106, align 1
  br label %107

107:                                              ; preds = %29, %28
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local void @"??$ax_Remove@Uax_ST_STRING@@@@YA?AUax_ST_STRING@@PEBDHH@Z"(%STRING.0* noalias sret %0, i8* %1, i32 %2, i32 %3) #14 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i8*, align 8
  %9 = alloca %STRING.0*, align 8
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i8, align 1
  %13 = alloca i8, align 1
  %14 = alloca i8, align 1
  %15 = bitcast %STRING.0* %0 to i8*
  store i8* %15, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i8* %1, i8** %8, align 8
  %16 = load i8*, i8** %8, align 8
  %17 = bitcast i8* %16 to %STRING.0*
  store %STRING.0* %17, %STRING.0** %9, align 8
  %18 = bitcast %STRING.0* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 1 %18, i8 0, i64 257, i1 false)
  %19 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 0
  store i8 -2, i8* %19, align 1
  %20 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 0, i8* %20, align 1
  %21 = load i32, i32* %7, align 4
  %22 = icmp sle i32 %21, 0
  br i1 %22, label %23, label %24

23:                                               ; preds = %4
  br label %99

24:                                               ; preds = %4
  %25 = load i32, i32* %7, align 4
  %26 = load %STRING.0*, %STRING.0** %9, align 8
  %27 = getelementptr inbounds %STRING.0, %STRING.0* %26, i32 0, i32 1
  %28 = load i8, i8* %27, align 1
  %29 = zext i8 %28 to i32
  %30 = icmp sgt i32 %25, %29
  br i1 %30, label %31, label %45

31:                                               ; preds = %24
  %32 = load %STRING.0*, %STRING.0** %9, align 8
  %33 = getelementptr inbounds %STRING.0, %STRING.0* %32, i32 0, i32 1
  %34 = load i8, i8* %33, align 1
  %35 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 %34, i8* %35, align 1
  %36 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %37 = getelementptr inbounds [255 x i8], [255 x i8]* %36, i64 0, i64 0
  %38 = load %STRING.0*, %STRING.0** %9, align 8
  %39 = getelementptr inbounds %STRING.0, %STRING.0* %38, i32 0, i32 2
  %40 = getelementptr inbounds [255 x i8], [255 x i8]* %39, i64 0, i64 0
  %41 = load %STRING.0*, %STRING.0** %9, align 8
  %42 = getelementptr inbounds %STRING.0, %STRING.0* %41, i32 0, i32 1
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %37, i8* align 1 %40, i64 %44, i1 false)
  br label %99

45:                                               ; preds = %24
  %46 = load %STRING.0*, %STRING.0** %9, align 8
  %47 = getelementptr inbounds %STRING.0, %STRING.0* %46, i32 0, i32 1
  %48 = load i8, i8* %47, align 1
  %49 = zext i8 %48 to i32
  %50 = load i32, i32* %6, align 4
  %51 = sub nsw i32 %49, %50
  %52 = trunc i32 %51 to i8
  %53 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  store i8 %52, i8* %53, align 1
  %54 = load i32, i32* %7, align 4
  %55 = sub nsw i32 %54, 1
  store i32 %55, i32* %10, align 4
  %56 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %57 = getelementptr inbounds [255 x i8], [255 x i8]* %56, i64 0, i64 0
  %58 = load %STRING.0*, %STRING.0** %9, align 8
  %59 = getelementptr inbounds %STRING.0, %STRING.0* %58, i32 0, i32 2
  %60 = getelementptr inbounds [255 x i8], [255 x i8]* %59, i64 0, i64 0
  %61 = load i32, i32* %10, align 4
  %62 = sext i32 %61 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 1 %60, i64 %62, i1 false)
  %63 = load i32, i32* %10, align 4
  store i32 %63, i32* %11, align 4
  %64 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %65 = load i8, i8* %64, align 1
  %66 = zext i8 %65 to i32
  %67 = load i32, i32* %11, align 4
  %68 = sub nsw i32 %66, %67
  %69 = trunc i32 %68 to i8
  store i8 %69, i8* %13, align 1
  %70 = load %STRING.0*, %STRING.0** %9, align 8
  %71 = getelementptr inbounds %STRING.0, %STRING.0* %70, i32 0, i32 1
  %72 = load i8, i8* %71, align 1
  %73 = zext i8 %72 to i32
  %74 = load i32, i32* %10, align 4
  %75 = sub nsw i32 %73, %74
  %76 = load i32, i32* %6, align 4
  %77 = sub nsw i32 %75, %76
  %78 = trunc i32 %77 to i8
  store i8 %78, i8* %14, align 1
  %79 = call dereferenceable(1) i8* @"??$min@E@std@@YAAEBEAEBE0@Z"(i8* dereferenceable(1) %14, i8* dereferenceable(1) %13) #5
  %80 = load i8, i8* %79, align 1
  store i8 %80, i8* %12, align 1
  %81 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %82 = load i32, i32* %11, align 4
  %83 = sext i32 %82 to i64
  %84 = getelementptr inbounds [255 x i8], [255 x i8]* %81, i64 0, i64 %83
  %85 = load %STRING.0*, %STRING.0** %9, align 8
  %86 = getelementptr inbounds %STRING.0, %STRING.0* %85, i32 0, i32 2
  %87 = load i32, i32* %10, align 4
  %88 = load i32, i32* %6, align 4
  %89 = add nsw i32 %87, %88
  %90 = sext i32 %89 to i64
  %91 = getelementptr inbounds [255 x i8], [255 x i8]* %86, i64 0, i64 %90
  %92 = load i8, i8* %12, align 1
  %93 = zext i8 %92 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %84, i8* align 1 %91, i64 %93, i1 false)
  %94 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 2
  %95 = getelementptr inbounds %STRING.0, %STRING.0* %0, i32 0, i32 1
  %96 = load i8, i8* %95, align 1
  %97 = zext i8 %96 to i64
  %98 = getelementptr inbounds [255 x i8], [255 x i8]* %94, i64 0, i64 %97
  store i8 0, i8* %98, align 1
  br label %99

99:                                               ; preds = %45, %31, %23
  ret void
}

define %WSTRING.6 @"System.Strings.Replace$I@V@WSTRING@value?I@V@Int32@startPosition?I@V@Int32@length?I@V@WSTRING@replaceValue"(i16* %value, i32 %startPosition, i32 %length, i16* %replaceValue) {
Entry:
  %Replace.ret = alloca %WSTRING.6
  %value.addr = alloca %WSTRING.6
  %startPosition.addr = alloca i32
  %length.addr = alloca i32
  %replaceValue.addr = alloca %WSTRING.6
  %0 = alloca %WSTRING.6
  %1 = alloca %WSTRING.6
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %Replace.ret
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %value.addr
  %2 = bitcast %WSTRING.6* %value.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %2, i16* %value)
  store i32 %startPosition, i32* %startPosition.addr
  store i32 %length, i32* %length.addr
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %replaceValue.addr
  %3 = bitcast %WSTRING.6* %replaceValue.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %3, i16* %replaceValue)
  br label %bb1

bb1:                                              ; preds = %Entry
  %4 = bitcast %WSTRING.6* %value.addr to i16*
  %5 = load i32, i32* %startPosition.addr
  %6 = load i32, i32* %length.addr
  %7 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i32, i32)* @ax_Remove_WString to %WSTRING.6 (i16*, i32, i32)*)(i16* %4, i32 %5, i32 %6)
  store %WSTRING.6 %7, %WSTRING.6* %0
  %8 = load i32, i32* %startPosition.addr
  %9 = sub i32 %8, 1
  %10 = bitcast %WSTRING.6* %0 to i16*
  %11 = bitcast %WSTRING.6* %replaceValue.addr to i16*
  %12 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i32, i16*)* @ax_Insert_WString to %WSTRING.6 (i16*, i32, i16*)*)(i16* %10, i32 %9, i16* %11)
  store %WSTRING.6 %12, %WSTRING.6* %1
  %13 = bitcast %WSTRING.6* %Replace.ret to i16*
  %14 = bitcast %WSTRING.6* %1 to i16*
  call void @"$ax.AssignST_WString"(i16* %13, i16* %14)
  %15 = load %WSTRING.6, %WSTRING.6* %Replace.ret
  ret %WSTRING.6 %15
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Remove_WString(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i32 %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = bitcast %WSTRING.6* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %10 = load i32, i32* %6, align 4
  %11 = load i32, i32* %7, align 4
  %12 = load i16*, i16** %8, align 8
  call void @"??$ax_Remove@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z"(%WSTRING.6* sret %0, i16* %12, i32 %11, i32 %10)
  ret void
}

; Function Attrs: noinline optnone uwtable
define dso_local void @ax_Insert_WString(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i16* %3) #13 {
  %5 = alloca i8*, align 8
  %6 = alloca i16*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = bitcast %WSTRING.6* %0 to i8*
  store i8* %9, i8** %5, align 8
  store i16* %3, i16** %6, align 8
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %10 = load i16*, i16** %6, align 8
  %11 = load i32, i32* %7, align 4
  %12 = load i16*, i16** %8, align 8
  call void @"??$ax_Insert@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFH0@Z"(%WSTRING.6* sret %0, i16* %12, i32 %11, i16* %10)
  ret void
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local void @"??$ax_Insert@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFH0@Z"(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i16* %3) #13 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i16*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = alloca %WSTRING.6*, align 8
  %10 = alloca %WSTRING.6*, align 8
  %11 = alloca i16, align 2
  %12 = alloca i32, align 4
  %13 = alloca i16, align 2
  %14 = alloca i16, align 2
  %15 = alloca i16, align 2
  %16 = alloca i16, align 2
  %17 = alloca i16, align 2
  %18 = bitcast %WSTRING.6* %0 to i8*
  store i8* %18, i8** %5, align 8
  store i16* %3, i16** %6, align 8
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %19 = load i16*, i16** %8, align 8
  %20 = bitcast i16* %19 to %WSTRING.6*
  store %WSTRING.6* %20, %WSTRING.6** %9, align 8
  %21 = load i16*, i16** %6, align 8
  %22 = bitcast i16* %21 to %WSTRING.6*
  store %WSTRING.6* %22, %WSTRING.6** %10, align 8
  %23 = bitcast %WSTRING.6* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 2 %23, i8 0, i64 514, i1 false)
  %24 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 0
  store i16 254, i16* %24, align 2
  %25 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 0, i16* %25, align 2
  %26 = load i32, i32* %7, align 4
  %27 = icmp slt i32 %26, 0
  br i1 %27, label %28, label %29

28:                                               ; preds = %4
  br label %113

29:                                               ; preds = %4
  %30 = load %WSTRING.6*, %WSTRING.6** %10, align 8
  %31 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %30, i32 0, i32 1
  %32 = load i16, i16* %31, align 2
  %33 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %34 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %33, i32 0, i32 1
  %35 = load i16, i16* %34, align 2
  %36 = call i16 @"??$safe_add@Uax_ST_WSTRING@@@@YAGGG@Z"(i16 %35, i16 %32)
  %37 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 %36, i16* %37, align 2
  %38 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %39 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %38, i32 0, i32 1
  %40 = load i32, i32* %7, align 4
  %41 = trunc i32 %40 to i16
  store i16 %41, i16* %11, align 2
  %42 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %11, i16* dereferenceable(2) %39) #5
  %43 = load i16, i16* %42, align 2
  %44 = zext i16 %43 to i32
  store i32 %44, i32* %7, align 4
  %45 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %46 = getelementptr inbounds [255 x i16], [255 x i16]* %45, i64 0, i64 0
  %47 = bitcast i16* %46 to i8*
  %48 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %49 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %48, i32 0, i32 2
  %50 = getelementptr inbounds [255 x i16], [255 x i16]* %49, i64 0, i64 0
  %51 = bitcast i16* %50 to i8*
  %52 = load i32, i32* %7, align 4
  %53 = sext i32 %52 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %47, i8* align 2 %51, i64 %53, i1 false)
  %54 = load i32, i32* %7, align 4
  store i32 %54, i32* %12, align 4
  %55 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %56 = load i16, i16* %55, align 2
  %57 = zext i16 %56 to i32
  %58 = load i32, i32* %12, align 4
  %59 = sub nsw i32 %57, %58
  %60 = trunc i32 %59 to i16
  store i16 %60, i16* %14, align 2
  %61 = load %WSTRING.6*, %WSTRING.6** %10, align 8
  %62 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %61, i32 0, i32 1
  %63 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %62, i16* dereferenceable(2) %14) #5
  %64 = load i16, i16* %63, align 2
  store i16 %64, i16* %13, align 2
  %65 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %66 = load i32, i32* %12, align 4
  %67 = sext i32 %66 to i64
  %68 = getelementptr inbounds [255 x i16], [255 x i16]* %65, i64 0, i64 %67
  %69 = bitcast i16* %68 to i8*
  %70 = load %WSTRING.6*, %WSTRING.6** %10, align 8
  %71 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %70, i32 0, i32 2
  %72 = getelementptr inbounds [255 x i16], [255 x i16]* %71, i64 0, i64 0
  %73 = bitcast i16* %72 to i8*
  %74 = load i16, i16* %13, align 2
  %75 = zext i16 %74 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %69, i8* align 2 %73, i64 %75, i1 false)
  %76 = load i16, i16* %13, align 2
  %77 = zext i16 %76 to i32
  %78 = load i32, i32* %12, align 4
  %79 = add nsw i32 %78, %77
  store i32 %79, i32* %12, align 4
  %80 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %81 = load i16, i16* %80, align 2
  %82 = zext i16 %81 to i32
  %83 = load i32, i32* %12, align 4
  %84 = sub nsw i32 %82, %83
  %85 = trunc i32 %84 to i16
  store i16 %85, i16* %16, align 2
  %86 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %87 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %86, i32 0, i32 1
  %88 = load i16, i16* %87, align 2
  %89 = zext i16 %88 to i32
  %90 = load i32, i32* %7, align 4
  %91 = sub nsw i32 %89, %90
  %92 = trunc i32 %91 to i16
  store i16 %92, i16* %17, align 2
  %93 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %17, i16* dereferenceable(2) %16) #5
  %94 = load i16, i16* %93, align 2
  store i16 %94, i16* %15, align 2
  %95 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %96 = load i32, i32* %12, align 4
  %97 = sext i32 %96 to i64
  %98 = getelementptr inbounds [255 x i16], [255 x i16]* %95, i64 0, i64 %97
  %99 = bitcast i16* %98 to i8*
  %100 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %101 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %100, i32 0, i32 2
  %102 = load i32, i32* %7, align 4
  %103 = sext i32 %102 to i64
  %104 = getelementptr inbounds [255 x i16], [255 x i16]* %101, i64 0, i64 %103
  %105 = bitcast i16* %104 to i8*
  %106 = load i16, i16* %15, align 2
  %107 = zext i16 %106 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %99, i8* align 2 %105, i64 %107, i1 false)
  %108 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %109 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %110 = load i16, i16* %109, align 2
  %111 = zext i16 %110 to i64
  %112 = getelementptr inbounds [255 x i16], [255 x i16]* %108, i64 0, i64 %111
  store i16 0, i16* %112, align 2
  br label %113

113:                                              ; preds = %29, %28
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define linkonce_odr dso_local void @"??$ax_Remove@Uax_ST_WSTRING@@@@YA?AUax_ST_WSTRING@@PEBFHH@Z"(%WSTRING.6* noalias sret %0, i16* %1, i32 %2, i32 %3) #14 comdat {
  %5 = alloca i8*, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i16*, align 8
  %9 = alloca %WSTRING.6*, align 8
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i16, align 2
  %13 = alloca i16, align 2
  %14 = alloca i16, align 2
  %15 = bitcast %WSTRING.6* %0 to i8*
  store i8* %15, i8** %5, align 8
  store i32 %3, i32* %6, align 4
  store i32 %2, i32* %7, align 4
  store i16* %1, i16** %8, align 8
  %16 = load i16*, i16** %8, align 8
  %17 = bitcast i16* %16 to %WSTRING.6*
  store %WSTRING.6* %17, %WSTRING.6** %9, align 8
  %18 = bitcast %WSTRING.6* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 2 %18, i8 0, i64 514, i1 false)
  %19 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 0
  store i16 254, i16* %19, align 2
  %20 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 0, i16* %20, align 2
  %21 = load i32, i32* %7, align 4
  %22 = icmp sle i32 %21, 0
  br i1 %22, label %23, label %24

23:                                               ; preds = %4
  br label %105

24:                                               ; preds = %4
  %25 = load i32, i32* %7, align 4
  %26 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %27 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %26, i32 0, i32 1
  %28 = load i16, i16* %27, align 2
  %29 = zext i16 %28 to i32
  %30 = icmp sgt i32 %25, %29
  br i1 %30, label %31, label %47

31:                                               ; preds = %24
  %32 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %33 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %32, i32 0, i32 1
  %34 = load i16, i16* %33, align 2
  %35 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 %34, i16* %35, align 2
  %36 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %37 = getelementptr inbounds [255 x i16], [255 x i16]* %36, i64 0, i64 0
  %38 = bitcast i16* %37 to i8*
  %39 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %40 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %39, i32 0, i32 2
  %41 = getelementptr inbounds [255 x i16], [255 x i16]* %40, i64 0, i64 0
  %42 = bitcast i16* %41 to i8*
  %43 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %44 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %43, i32 0, i32 1
  %45 = load i16, i16* %44, align 2
  %46 = zext i16 %45 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %38, i8* align 2 %42, i64 %46, i1 false)
  br label %105

47:                                               ; preds = %24
  %48 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %49 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %48, i32 0, i32 1
  %50 = load i16, i16* %49, align 2
  %51 = zext i16 %50 to i32
  %52 = load i32, i32* %6, align 4
  %53 = sub nsw i32 %51, %52
  %54 = trunc i32 %53 to i16
  %55 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  store i16 %54, i16* %55, align 2
  %56 = load i32, i32* %7, align 4
  %57 = sub nsw i32 %56, 1
  store i32 %57, i32* %10, align 4
  %58 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %59 = getelementptr inbounds [255 x i16], [255 x i16]* %58, i64 0, i64 0
  %60 = bitcast i16* %59 to i8*
  %61 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %62 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %61, i32 0, i32 2
  %63 = getelementptr inbounds [255 x i16], [255 x i16]* %62, i64 0, i64 0
  %64 = bitcast i16* %63 to i8*
  %65 = load i32, i32* %10, align 4
  %66 = sext i32 %65 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %60, i8* align 2 %64, i64 %66, i1 false)
  %67 = load i32, i32* %10, align 4
  store i32 %67, i32* %11, align 4
  %68 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %69 = load i16, i16* %68, align 2
  %70 = zext i16 %69 to i32
  %71 = load i32, i32* %11, align 4
  %72 = sub nsw i32 %70, %71
  %73 = trunc i32 %72 to i16
  store i16 %73, i16* %13, align 2
  %74 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %75 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %74, i32 0, i32 1
  %76 = load i16, i16* %75, align 2
  %77 = zext i16 %76 to i32
  %78 = load i32, i32* %10, align 4
  %79 = sub nsw i32 %77, %78
  %80 = load i32, i32* %6, align 4
  %81 = sub nsw i32 %79, %80
  %82 = trunc i32 %81 to i16
  store i16 %82, i16* %14, align 2
  %83 = call dereferenceable(2) i16* @"??$min@G@std@@YAAEBGAEBG0@Z"(i16* dereferenceable(2) %14, i16* dereferenceable(2) %13) #5
  %84 = load i16, i16* %83, align 2
  store i16 %84, i16* %12, align 2
  %85 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %86 = load i32, i32* %11, align 4
  %87 = sext i32 %86 to i64
  %88 = getelementptr inbounds [255 x i16], [255 x i16]* %85, i64 0, i64 %87
  %89 = bitcast i16* %88 to i8*
  %90 = load %WSTRING.6*, %WSTRING.6** %9, align 8
  %91 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %90, i32 0, i32 2
  %92 = load i32, i32* %10, align 4
  %93 = load i32, i32* %6, align 4
  %94 = add nsw i32 %92, %93
  %95 = sext i32 %94 to i64
  %96 = getelementptr inbounds [255 x i16], [255 x i16]* %91, i64 0, i64 %95
  %97 = bitcast i16* %96 to i8*
  %98 = load i16, i16* %12, align 2
  %99 = zext i16 %98 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %89, i8* align 2 %97, i64 %99, i1 false)
  %100 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 2
  %101 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %0, i32 0, i32 1
  %102 = load i16, i16* %101, align 2
  %103 = zext i16 %102 to i64
  %104 = getelementptr inbounds [255 x i16], [255 x i16]* %100, i64 0, i64 %103
  store i16 0, i16* %104, align 2
  br label %105

105:                                              ; preds = %47, %31, %23
  ret void
}

define %STRING.0 @"System.Strings.StartOf$I@V@STRING@value?I@V@Int16@length"(i8* %value, i16 %length) {
Entry:
  %StartOf.ret = alloca %STRING.0
  %value.addr = alloca %STRING.0
  %length.addr = alloca i16
  %0 = alloca %STRING.0
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %StartOf.ret
  store %STRING.0 { i8 -2, i8 0, [255 x i8] zeroinitializer }, %STRING.0* %value.addr
  %1 = bitcast %STRING.0* %value.addr to i8*
  call void @"$ax.AssignST_String"(i8* %1, i8* %value)
  store i16 %length, i16* %length.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %STRING.0* %value.addr to i8*
  %3 = load i16, i16* %length.addr
  %4 = call %STRING.0 bitcast (void (%STRING.0*, i8*, i16, i16)* @ax_Substring_String to %STRING.0 (i8*, i16, i16)*)(i8* %2, i16 1, i16 %3)
  store %STRING.0 %4, %STRING.0* %0
  %5 = bitcast %STRING.0* %StartOf.ret to i8*
  %6 = bitcast %STRING.0* %0 to i8*
  call void @"$ax.AssignST_String"(i8* %5, i8* %6)
  %7 = load %STRING.0, %STRING.0* %StartOf.ret
  ret %STRING.0 %7
}

define %WSTRING.6 @"System.Strings.StartOf$I@V@WSTRING@value?I@V@Int32@length"(i16* %value, i32 %length) {
Entry:
  %StartOf.ret = alloca %WSTRING.6
  %value.addr = alloca %WSTRING.6
  %length.addr = alloca i32
  %0 = alloca %WSTRING.6
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %StartOf.ret
  store %WSTRING.6 { i16 254, i16 0, [255 x i16] zeroinitializer }, %WSTRING.6* %value.addr
  %1 = bitcast %WSTRING.6* %value.addr to i16*
  call void @"$ax.AssignST_WString"(i16* %1, i16* %value)
  store i32 %length, i32* %length.addr
  br label %bb1

bb1:                                              ; preds = %Entry
  %2 = bitcast %WSTRING.6* %value.addr to i16*
  %3 = load i32, i32* %length.addr
  %4 = call %WSTRING.6 bitcast (void (%WSTRING.6*, i16*, i32, i32)* @ax_Substring_WString to %WSTRING.6 (i16*, i32, i32)*)(i16* %2, i32 1, i32 %3)
  store %WSTRING.6 %4, %WSTRING.6* %0
  %5 = bitcast %WSTRING.6* %StartOf.ret to i16*
  %6 = bitcast %WSTRING.6* %0 to i16*
  call void @"$ax.AssignST_WString"(i16* %5, i16* %6)
  %7 = load %WSTRING.6, %WSTRING.6* %StartOf.ret
  ret %WSTRING.6 %7
}

; Function Attrs: noinline optnone uwtable
define dso_local i16 @ax_PositionOf_String(i8* %0, i8* %1) #13 {
  %3 = alloca i8*, align 8
  %4 = alloca i8*, align 8
  store i8* %1, i8** %3, align 8
  store i8* %0, i8** %4, align 8
  %5 = load i8*, i8** %3, align 8
  %6 = load i8*, i8** %4, align 8
  %7 = call i32 @"??$ax_PositionOf@Uax_ST_STRING@@@@YAHPEBD0@Z"(i8* %6, i8* %5)
  %8 = trunc i32 %7 to i16
  ret i16 %8
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i32 @"??$ax_PositionOf@Uax_ST_STRING@@@@YAHPEBD0@Z"(i8* %0, i8* %1) #13 comdat {
  %3 = alloca i32, align 4
  %4 = alloca i8*, align 8
  %5 = alloca i8*, align 8
  %6 = alloca %STRING.0*, align 8
  %7 = alloca %STRING.0*, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  store i8* %1, i8** %4, align 8
  store i8* %0, i8** %5, align 8
  %10 = load i8*, i8** %5, align 8
  %11 = bitcast i8* %10 to %STRING.0*
  store %STRING.0* %11, %STRING.0** %6, align 8
  %12 = load i8*, i8** %4, align 8
  %13 = bitcast i8* %12 to %STRING.0*
  store %STRING.0* %13, %STRING.0** %7, align 8
  %14 = load %STRING.0*, %STRING.0** %6, align 8
  %15 = getelementptr inbounds %STRING.0, %STRING.0* %14, i32 0, i32 1
  %16 = load i8, i8* %15, align 1
  %17 = zext i8 %16 to i32
  %18 = load %STRING.0*, %STRING.0** %7, align 8
  %19 = getelementptr inbounds %STRING.0, %STRING.0* %18, i32 0, i32 1
  %20 = load i8, i8* %19, align 1
  %21 = zext i8 %20 to i32
  %22 = sub nsw i32 %17, %21
  store i32 %22, i32* %8, align 4
  store i32 0, i32* %9, align 4
  br label %23

23:                                               ; preds = %46, %2
  %24 = load i32, i32* %9, align 4
  %25 = load i32, i32* %8, align 4
  %26 = icmp sle i32 %24, %25
  br i1 %26, label %27, label %49

27:                                               ; preds = %23
  %28 = load %STRING.0*, %STRING.0** %7, align 8
  %29 = getelementptr inbounds %STRING.0, %STRING.0* %28, i32 0, i32 1
  %30 = load i8, i8* %29, align 1
  %31 = zext i8 %30 to i64
  %32 = load %STRING.0*, %STRING.0** %7, align 8
  %33 = getelementptr inbounds %STRING.0, %STRING.0* %32, i32 0, i32 2
  %34 = getelementptr inbounds [255 x i8], [255 x i8]* %33, i64 0, i64 0
  %35 = load %STRING.0*, %STRING.0** %6, align 8
  %36 = getelementptr inbounds %STRING.0, %STRING.0* %35, i32 0, i32 2
  %37 = load i32, i32* %9, align 4
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [255 x i8], [255 x i8]* %36, i64 0, i64 %38
  %40 = call i32 @memcmp(i8* %39, i8* %34, i64 %31)
  %41 = icmp eq i32 %40, 0
  br i1 %41, label %42, label %45

42:                                               ; preds = %27
  %43 = load i32, i32* %9, align 4
  %44 = add nsw i32 %43, 1
  store i32 %44, i32* %3, align 4
  br label %50

45:                                               ; preds = %27
  br label %46

46:                                               ; preds = %45
  %47 = load i32, i32* %9, align 4
  %48 = add nsw i32 %47, 1
  store i32 %48, i32* %9, align 4
  br label %23

49:                                               ; preds = %23
  store i32 0, i32* %3, align 4
  br label %50

50:                                               ; preds = %49, %42
  %51 = load i32, i32* %3, align 4
  ret i32 %51
}

declare dso_local i32 @memcmp(i8*, i8*, i64) #6

; Function Attrs: noinline optnone uwtable
define dso_local i32 @ax_PositionOf_WString(i16* %0, i16* %1) #13 {
  %3 = alloca i16*, align 8
  %4 = alloca i16*, align 8
  store i16* %1, i16** %3, align 8
  store i16* %0, i16** %4, align 8
  %5 = load i16*, i16** %3, align 8
  %6 = load i16*, i16** %4, align 8
  %7 = call i32 @"??$ax_PositionOf@Uax_ST_WSTRING@@@@YAHPEBF0@Z"(i16* %6, i16* %5)
  ret i32 %7
}

; Function Attrs: noinline optnone uwtable
define linkonce_odr dso_local i32 @"??$ax_PositionOf@Uax_ST_WSTRING@@@@YAHPEBF0@Z"(i16* %0, i16* %1) #13 comdat {
  %3 = alloca i32, align 4
  %4 = alloca i16*, align 8
  %5 = alloca i16*, align 8
  %6 = alloca %WSTRING.6*, align 8
  %7 = alloca %WSTRING.6*, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  store i16* %1, i16** %4, align 8
  store i16* %0, i16** %5, align 8
  %10 = load i16*, i16** %5, align 8
  %11 = bitcast i16* %10 to %WSTRING.6*
  store %WSTRING.6* %11, %WSTRING.6** %6, align 8
  %12 = load i16*, i16** %4, align 8
  %13 = bitcast i16* %12 to %WSTRING.6*
  store %WSTRING.6* %13, %WSTRING.6** %7, align 8
  %14 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %15 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %14, i32 0, i32 1
  %16 = load i16, i16* %15, align 2
  %17 = zext i16 %16 to i32
  %18 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %19 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %18, i32 0, i32 1
  %20 = load i16, i16* %19, align 2
  %21 = zext i16 %20 to i32
  %22 = sub nsw i32 %17, %21
  store i32 %22, i32* %8, align 4
  store i32 0, i32* %9, align 4
  br label %23

23:                                               ; preds = %48, %2
  %24 = load i32, i32* %9, align 4
  %25 = load i32, i32* %8, align 4
  %26 = icmp sle i32 %24, %25
  br i1 %26, label %27, label %51

27:                                               ; preds = %23
  %28 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %29 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %28, i32 0, i32 1
  %30 = load i16, i16* %29, align 2
  %31 = zext i16 %30 to i64
  %32 = load %WSTRING.6*, %WSTRING.6** %7, align 8
  %33 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %32, i32 0, i32 2
  %34 = getelementptr inbounds [255 x i16], [255 x i16]* %33, i64 0, i64 0
  %35 = bitcast i16* %34 to i8*
  %36 = load %WSTRING.6*, %WSTRING.6** %6, align 8
  %37 = getelementptr inbounds %WSTRING.6, %WSTRING.6* %36, i32 0, i32 2
  %38 = load i32, i32* %9, align 4
  %39 = sext i32 %38 to i64
  %40 = getelementptr inbounds [255 x i16], [255 x i16]* %37, i64 0, i64 %39
  %41 = bitcast i16* %40 to i8*
  %42 = call i32 @memcmp(i8* %41, i8* %35, i64 %31)
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %44, label %47

44:                                               ; preds = %27
  %45 = load i32, i32* %9, align 4
  %46 = add nsw i32 %45, 1
  store i32 %46, i32* %3, align 4
  br label %52

47:                                               ; preds = %27
  br label %48

48:                                               ; preds = %47
  %49 = load i32, i32* %9, align 4
  %50 = add nsw i32 %49, 1
  store i32 %50, i32* %9, align 4
  br label %23

51:                                               ; preds = %23
  store i32 0, i32* %3, align 4
  br label %52

52:                                               ; preds = %51, %44
  %53 = load i32, i32* %3, align 4
  ret i32 %53
}

attributes #0 = { nounwind readnone speculatable willreturn }
attributes #1 = { noreturn uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { inlinehint nobuiltin uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind willreturn }
attributes #5 = { nounwind }
attributes #6 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { nofree norecurse nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { norecurse nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #12 = { nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #13 = { noinline optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #14 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #15 = { noreturn }

!llvm.module.flags = !{!87, !88, !89, !90}
!llvm.dbg.cu = !{!2}
!llvm.linker.options = !{!91, !92, !93, !94, !95, !91, !92, !93, !94, !95, !91, !92, !93, !94, !95, !91, !92, !93, !94, !95}
!llvm.ident = !{!96, !96, !96, !96, !96}

!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
!1 = distinct !DIGlobalVariable(name: "axunit_assertionData", scope: !2, file: !3, type: !81, isLocal: false, isDefinition: true)
!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "AX.Target.LLVM 2.1.36+8362ec5835", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !23, splitDebugInlining: false)
!3 = !DIFile(filename: "none", directory: "\\")
!4 = !{!5, !11}
!5 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "Simatic.Ax.Conversion.ConversionMode", scope: !7, file: !6, line: 3, size: 16, align: 16, elements: !10)
!6 = !DIFile(filename: "ConversionMode.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!7 = !DINamespace(name: "Conversion", scope: !8, exportSymbols: true)
!8 = !DINamespace(name: "Ax", scope: !9, exportSymbols: true)
!9 = !DINamespace(name: "Simatic", scope: null, exportSymbols: true)
!10 = !{}
!11 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "Simatic.Ax.Json.JsonValueKind", scope: !13, file: !12, line: 3, size: 16, align: 16, elements: !14)
!12 = !DIFile(filename: "JsonValueKind.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src")
!13 = !DINamespace(name: "Json", scope: !8, exportSymbols: true)
!14 = !{!15, !16, !17, !18, !19, !20, !21, !22}
!15 = !DIEnumerator(name: "_Array", value: 2)
!16 = !DIEnumerator(name: "_False", value: 6)
!17 = !DIEnumerator(name: "_Null", value: 7)
!18 = !DIEnumerator(name: "_Number", value: 4)
!19 = !DIEnumerator(name: "_Object", value: 1)
!20 = !DIEnumerator(name: "_String", value: 3)
!21 = !DIEnumerator(name: "_True", value: 5)
!22 = !DIEnumerator(name: "_Undefined", value: 0)
!23 = !{!0, !24, !28, !30, !34, !38, !40, !42, !44, !79}
!24 = !DIGlobalVariableExpression(var: !25, expr: !DIExpression())
!25 = distinct !DIGlobalVariable(name: "axunit_globalSectionPosName", scope: !2, file: !3, type: !26, isLocal: false, isDefinition: true)
!26 = !DIDerivedType(tag: DW_TAG_typedef, name: "UInt16", baseType: !27, align: 16)
!27 = !DIBasicType(name: "UInt16", size: 16, encoding: DW_ATE_unsigned)
!28 = !DIGlobalVariableExpression(var: !29, expr: !DIExpression())
!29 = distinct !DIGlobalVariable(name: "axunit_globalTestIdPos", scope: !2, file: !3, type: !26, isLocal: false, isDefinition: true)
!30 = !DIGlobalVariableExpression(var: !31, expr: !DIExpression())
!31 = distinct !DIGlobalVariable(name: "axunit_TestsExecuted", scope: !2, file: !3, type: !32, isLocal: false, isDefinition: true)
!32 = !DIDerivedType(tag: DW_TAG_typedef, name: "INT", baseType: !33, align: 16)
!33 = !DIBasicType(name: "Int16", size: 16, encoding: DW_ATE_signed)
!34 = !DIGlobalVariableExpression(var: !35, expr: !DIExpression())
!35 = distinct !DIGlobalVariable(name: "axunit_Test_0_Result", scope: !2, file: !3, type: !36, isLocal: false, isDefinition: true)
!36 = !DIDerivedType(tag: DW_TAG_typedef, name: "USINT", baseType: !37, align: 8)
!37 = !DIBasicType(name: "UInt8", size: 8, encoding: DW_ATE_unsigned)
!38 = !DIGlobalVariableExpression(var: !39, expr: !DIExpression())
!39 = distinct !DIGlobalVariable(name: "axunit_Test_1_Result", scope: !2, file: !3, type: !36, isLocal: false, isDefinition: true)
!40 = !DIGlobalVariableExpression(var: !41, expr: !DIExpression())
!41 = distinct !DIGlobalVariable(name: "axunit_Test_2_Result", scope: !2, file: !3, type: !36, isLocal: false, isDefinition: true)
!42 = !DIGlobalVariableExpression(var: !43, expr: !DIExpression())
!43 = distinct !DIGlobalVariable(name: "axunit_Test_3_Result", scope: !2, file: !3, type: !36, isLocal: false, isDefinition: true)
!44 = !DIGlobalVariableExpression(var: !45, expr: !DIExpression())
!45 = distinct !DIGlobalVariable(name: "axunit_testfixture_instance_UsingDeserializer", scope: !2, file: !3, type: !46, isLocal: false, isDefinition: true)
!46 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "UsingDeserializer", file: !47, line: 7, size: 12416, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !48, vtableHolder: !46)
!47 = !DIFile(filename: "UsingDeserializer.st", directory: "d:\\workspace\\JSONShowcase\\JSONShowcase\\src")
!48 = !{!49, !50, !64, !65, !72, !73, !76}
!49 = !DIDerivedType(tag: DW_TAG_member, name: "$cd", scope: !46, file: !47, baseType: null, size: 64, align: 64, flags: DIFlagArtificial)
!50 = !DIDerivedType(tag: DW_TAG_member, name: "deserializer", scope: !46, file: !47, line: 9, baseType: !51, size: 128, align: 64, offset: 64)
!51 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "Deserializer", scope: !13, file: !52, line: 5, size: 128, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !53, vtableHolder: !51)
!52 = !DIFile(filename: "Deserializer.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Document")
!53 = !{!54, !55}
!54 = !DIDerivedType(tag: DW_TAG_member, name: "$cd", scope: !51, file: !52, baseType: null, size: 64, align: 64, flags: DIFlagArtificial)
!55 = !DIDerivedType(tag: DW_TAG_member, name: "buffer", scope: !51, file: !52, line: 8, baseType: !56, size: 64, align: 64, offset: 64)
!56 = !DIDerivedType(tag: DW_TAG_typedef, name: "REF_TO ARRAY [0..999] OF CHAR", baseType: !57, align: 64)
!57 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !58, size: 64, align: 64, dwarfAddressSpace: 0)
!58 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..999] OF CHAR", file: !52, line: 8, baseType: !59, align: 8)
!59 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 8000, align: 8, elements: !62)
!60 = !DIDerivedType(tag: DW_TAG_typedef, name: "CHAR", baseType: !61, align: 8)
!61 = !DIBasicType(name: "Char", size: 8, encoding: DW_ATE_signed_char)
!62 = !{!63}
!63 = !DISubrange(count: 1000)
!64 = !DIDerivedType(tag: DW_TAG_member, name: "buffer", scope: !46, file: !47, line: 10, baseType: !58, size: 8000, align: 8, offset: 192)
!65 = !DIDerivedType(tag: DW_TAG_member, name: "JSON_Entry", scope: !46, file: !47, line: 12, baseType: !66, size: 2056, align: 8, offset: 8192)
!66 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING", file: !3, size: 2056, align: 8, flags: DIFlagTypePassByValue, elements: !67)
!67 = !{!68}
!68 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !66, file: !3, baseType: !69, size: 2040, align: 8, offset: 16)
!69 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 2040, align: 8, elements: !70)
!70 = !{!71}
!71 = !DISubrange(count: 255)
!72 = !DIDerivedType(tag: DW_TAG_member, name: "key", scope: !46, file: !47, line: 13, baseType: !66, size: 2056, align: 8, offset: 10248)
!73 = !DIDerivedType(tag: DW_TAG_member, name: "len", scope: !46, file: !47, line: 14, baseType: !74, size: 32, align: 32, offset: 12320)
!74 = !DIDerivedType(tag: DW_TAG_typedef, name: "DINT", baseType: !75, align: 32)
!75 = !DIBasicType(name: "Int32", size: 32, encoding: DW_ATE_signed)
!76 = !DIDerivedType(tag: DW_TAG_member, name: "keyFound", scope: !46, file: !47, line: 15, baseType: !77, size: 1, align: 8, offset: 12352)
!77 = !DIDerivedType(tag: DW_TAG_typedef, name: "BOOL", baseType: !78, align: 8)
!78 = !DIBasicType(name: "Int1", size: 8, encoding: DW_ATE_boolean)
!79 = !DIGlobalVariableExpression(var: !80, expr: !DIExpression())
!80 = distinct !DIGlobalVariable(name: "axunit_testfixture_instance_default_valuesUsingDeserializer", scope: !2, file: !3, type: !46, isLocal: false, isDefinition: true)
!81 = !DIDerivedType(tag: DW_TAG_typedef, name: "axunit_assertionData_type", file: !3, baseType: !82, align: 8)
!82 = !DICompositeType(tag: DW_TAG_array_type, baseType: !83, size: 2400, align: 8, elements: !85)
!83 = !DIDerivedType(tag: DW_TAG_typedef, name: "Byte8", baseType: !84, align: 8)
!84 = !DIBasicType(name: "Byte8", size: 8, encoding: DW_ATE_unsigned)
!85 = !{!86}
!86 = !DISubrange(count: 300)
!87 = !{i32 2, !"Debug Info Version", i32 3}
!88 = !{i32 2, !"Dwarf Version", i32 4}
!89 = !{i32 1, !"wchar_size", i32 2}
!90 = !{i32 7, !"PIC Level", i32 2}
!91 = !{!"/FAILIFMISMATCH:\22_MSC_VER=1900\22"}
!92 = !{!"/FAILIFMISMATCH:\22_ITERATOR_DEBUG_LEVEL=0\22"}
!93 = !{!"/FAILIFMISMATCH:\22RuntimeLibrary=MT_StaticRelease\22"}
!94 = !{!"/DEFAULTLIB:libcpmt.lib"}
!95 = !{!"/FAILIFMISMATCH:\22_CRT_STDIO_ISO_WIDE_SPECIFIERS=0\22"}
!96 = !{!"clang version 10.0.0 "}
!97 = distinct !DISubprogram(name: "GetValue_BASIC_DATA_TYPES", linkageName: "UsingDeserializer.GetValue_BASIC_DATA_TYPES$I@R@UsingDeserializer@this", scope: !46, file: !47, line: 20, type: !98, scopeLine: 20, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!98 = !DISubroutineType(types: !99)
!99 = !{null, !100}
!100 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !46, size: 64, align: 64, dwarfAddressSpace: 0)
!101 = !DILocalVariable(name: "this", arg: 1, scope: !97, type: !100, flags: DIFlagArtificial | DIFlagObjectPointer)
!102 = !DILocation(line: 20, column: 19, scope: !97)
!103 = !DILocalVariable(name: "stringValue", scope: !97, file: !47, line: 22, type: !66)
!104 = !DILocation(line: 22, column: 13, scope: !97)
!105 = !DILocalVariable(name: "usintValue", scope: !97, file: !47, line: 23, type: !36)
!106 = !DILocation(line: 23, column: 13, scope: !97)
!107 = !DILocalVariable(name: "intValue", scope: !97, file: !47, line: 24, type: !32)
!108 = !DILocation(line: 24, column: 13, scope: !97)
!109 = !DILocation(line: 28, column: 9, scope: !97)
!110 = !DILocation(line: 29, column: 9, scope: !97)
!111 = !DILocation(line: 32, column: 9, scope: !97)
!112 = !DILocation(line: 35, column: 9, scope: !97)
!113 = !DILocation(line: 36, column: 9, scope: !97)
!114 = !DILocation(line: 38, column: 9, scope: !97)
!115 = !DILocation(line: 39, column: 9, scope: !97)
!116 = !DILocation(line: 42, column: 9, scope: !97)
!117 = !DILocation(line: 43, column: 9, scope: !97)
!118 = !DILocation(line: 45, column: 9, scope: !97)
!119 = !DILocation(line: 46, column: 9, scope: !97)
!120 = !DILocation(line: 49, column: 9, scope: !97)
!121 = !DILocation(line: 50, column: 9, scope: !97)
!122 = !DILocation(line: 52, column: 9, scope: !97)
!123 = !DILocation(line: 53, column: 9, scope: !97)
!124 = !DILocation(line: 56, column: 9, scope: !97)
!125 = !DILocation(line: 57, column: 9, scope: !97)
!126 = !DILocation(line: 59, column: 9, scope: !97)
!127 = !DILocation(line: 60, column: 9, scope: !97)
!128 = !DILocation(line: 64, column: 9, scope: !97)
!129 = !DILocation(line: 65, column: 9, scope: !97)
!130 = !DILocation(line: 67, column: 9, scope: !97)
!131 = !DILocation(line: 68, column: 9, scope: !97)
!132 = !DILocation(line: 71, column: 9, scope: !97)
!133 = !DILocation(line: 72, column: 9, scope: !97)
!134 = !DILocation(line: 74, column: 9, scope: !97)
!135 = !DILocation(line: 75, column: 9, scope: !97)
!136 = !DILocation(line: 78, column: 10, scope: !97)
!137 = !DILocation(line: 79, column: 10, scope: !97)
!138 = !DILocation(line: 81, column: 10, scope: !97)
!139 = !DILocation(line: 82, column: 10, scope: !97)
!140 = !DILocation(line: 83, column: 15, scope: !97)
!141 = distinct !DISubprogram(name: "GetValue_ARRAY", linkageName: "UsingDeserializer.GetValue_ARRAY$I@R@UsingDeserializer@this", scope: !46, file: !47, line: 87, type: !98, scopeLine: 87, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!142 = !DILocalVariable(name: "this", arg: 1, scope: !141, type: !100, flags: DIFlagArtificial | DIFlagObjectPointer)
!143 = !DILocation(line: 87, column: 19, scope: !141)
!144 = !DILocalVariable(name: "stringValue", scope: !141, file: !47, line: 89, type: !66)
!145 = !DILocation(line: 89, column: 13, scope: !141)
!146 = !DILocation(line: 92, column: 9, scope: !141)
!147 = !DILocation(line: 94, column: 9, scope: !141)
!148 = !DILocation(line: 95, column: 9, scope: !141)
!149 = !DILocation(line: 97, column: 9, scope: !141)
!150 = !DILocation(line: 98, column: 9, scope: !141)
!151 = !DILocation(line: 100, column: 9, scope: !141)
!152 = !DILocation(line: 101, column: 9, scope: !141)
!153 = !DILocation(line: 102, column: 15, scope: !141)
!154 = distinct !DISubprogram(name: "GetValue_Nested", linkageName: "UsingDeserializer.GetValue_Nested$I@R@UsingDeserializer@this", scope: !46, file: !47, line: 106, type: !98, scopeLine: 106, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!155 = !DILocalVariable(name: "this", arg: 1, scope: !154, type: !100, flags: DIFlagArtificial | DIFlagObjectPointer)
!156 = !DILocation(line: 106, column: 19, scope: !154)
!157 = !DILocalVariable(name: "stringValue", scope: !154, file: !47, line: 108, type: !66)
!158 = !DILocation(line: 108, column: 13, scope: !154)
!159 = !DILocalVariable(name: "keyArray", scope: !154, file: !47, line: 109, type: !160)
!160 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..1] OF STRING", file: !47, line: 109, baseType: !161, align: 8)
!161 = !DICompositeType(tag: DW_TAG_array_type, baseType: !66, size: 4112, align: 8, elements: !162)
!162 = !{!163}
!163 = !DISubrange(count: 2)
!164 = !DILocation(line: 109, column: 13, scope: !154)
!165 = !DILocation(line: 112, column: 9, scope: !154)
!166 = !DILocation(line: 114, column: 9, scope: !154)
!167 = !DILocation(line: 115, column: 9, scope: !154)
!168 = !DILocation(line: 119, column: 9, scope: !154)
!169 = !DILocation(line: 120, column: 9, scope: !154)
!170 = !DILocation(line: 122, column: 9, scope: !154)
!171 = !DILocation(line: 123, column: 9, scope: !154)
!172 = !DILocation(line: 127, column: 9, scope: !154)
!173 = !DILocation(line: 128, column: 9, scope: !154)
!174 = !DILocation(line: 130, column: 9, scope: !154)
!175 = !DILocation(line: 132, column: 9, scope: !154)
!176 = !DILocation(line: 133, column: 9, scope: !154)
!177 = !DILocation(line: 134, column: 15, scope: !154)
!178 = distinct !DISubprogram(name: "GetValue_Nested_in_Nested", linkageName: "UsingDeserializer.GetValue_Nested_in_Nested$I@R@UsingDeserializer@this", scope: !46, file: !47, line: 138, type: !98, scopeLine: 138, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!179 = !DILocalVariable(name: "this", arg: 1, scope: !178, type: !100, flags: DIFlagArtificial | DIFlagObjectPointer)
!180 = !DILocation(line: 138, column: 19, scope: !178)
!181 = !DILocalVariable(name: "stringValue", scope: !178, file: !47, line: 140, type: !66)
!182 = !DILocation(line: 140, column: 13, scope: !178)
!183 = !DILocalVariable(name: "keyArray", scope: !178, file: !47, line: 141, type: !184)
!184 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..2] OF STRING", file: !47, line: 141, baseType: !185, align: 8)
!185 = !DICompositeType(tag: DW_TAG_array_type, baseType: !66, size: 6168, align: 8, elements: !186)
!186 = !{!187}
!187 = !DISubrange(count: 3)
!188 = !DILocation(line: 141, column: 13, scope: !178)
!189 = !DILocalVariable(name: "intValue", scope: !178, file: !47, line: 142, type: !32)
!190 = !DILocation(line: 142, column: 13, scope: !178)
!191 = !DILocation(line: 145, column: 9, scope: !178)
!192 = !DILocation(line: 147, column: 9, scope: !178)
!193 = !DILocation(line: 148, column: 9, scope: !178)
!194 = !DILocation(line: 151, column: 9, scope: !178)
!195 = !DILocation(line: 152, column: 9, scope: !178)
!196 = !DILocation(line: 153, column: 9, scope: !178)
!197 = !DILocation(line: 155, column: 9, scope: !178)
!198 = !DILocation(line: 157, column: 9, scope: !178)
!199 = !DILocation(line: 158, column: 9, scope: !178)
!200 = !DILocation(line: 159, column: 15, scope: !178)
!201 = distinct !DISubprogram(name: "SetBuffer", linkageName: "Simatic.Ax.Json.Deserializer.SetBuffer$I@R@Simatic.Ax.Json.Deserializer@this?I@V@REF_TO ARRAY [0..999] OF CHAR@_buffer", scope: !51, file: !52, line: 12, type: !202, scopeLine: 12, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!202 = !DISubroutineType(types: !203)
!203 = !{null, !204, !56}
!204 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !51, size: 64, align: 64, dwarfAddressSpace: 0)
!205 = !DILocalVariable(name: "_buffer", arg: 2, scope: !201, file: !52, line: 14, type: !56, flags: DIFlagTypePassByValue)
!206 = !DILocation(line: 14, column: 17, scope: !201)
!207 = !DILocalVariable(name: "this", arg: 1, scope: !201, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!208 = !DILocation(line: 12, column: 23, scope: !201)
!209 = !DILocation(line: 17, column: 13, scope: !201)
!210 = !DILocation(line: 18, column: 19, scope: !201)
!211 = distinct !DISubprogram(name: "KeyIsInIndexSpan", linkageName: "Simatic.Ax.Json.Deserializer.KeyIsInIndexSpan$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?I@V@Int16@startIndex?I@V@Int16@endIndex", scope: !51, file: !52, line: 20, type: !212, scopeLine: 20, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!212 = !DISubroutineType(types: !213)
!213 = !{!77, !204, !214, !32, !32}
!214 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !60, size: 64, align: 64, dwarfAddressSpace: 0)
!215 = !DILocalVariable(name: "key", arg: 2, scope: !211, file: !52, line: 22, type: !66, flags: DIFlagTypePassByValue)
!216 = !DILocation(line: 22, column: 17, scope: !211)
!217 = !DILocalVariable(name: "startIndex", arg: 3, scope: !211, file: !52, line: 23, type: !32, flags: DIFlagTypePassByValue)
!218 = !DILocation(line: 23, column: 17, scope: !211)
!219 = !DILocalVariable(name: "endIndex", arg: 4, scope: !211, file: !52, line: 24, type: !32, flags: DIFlagTypePassByValue)
!220 = !DILocation(line: 24, column: 17, scope: !211)
!221 = !DILocalVariable(name: "this", arg: 1, scope: !211, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!222 = !DILocation(line: 20, column: 25, scope: !211)
!223 = !DILocalVariable(name: "keyIndex", scope: !211, file: !52, line: 27, type: !32)
!224 = !DILocation(line: 27, column: 17, scope: !211)
!225 = !DILocalVariable(name: "loopIndex", scope: !211, file: !52, line: 28, type: !32)
!226 = !DILocation(line: 28, column: 17, scope: !211)
!227 = !DILocalVariable(name: "KeyIsInIndexSpan", scope: !211, file: !52, line: 20, type: !77)
!228 = !DILocation(line: 31, column: 44, scope: !211)
!229 = !DILocation(line: 31, column: 17, scope: !211)
!230 = !DILocation(line: 31, column: 13, scope: !211)
!231 = !DILocation(line: 38, column: 20, scope: !211)
!232 = !DILocation(line: 40, column: 13, scope: !211)
!233 = !DILocation(line: 42, column: 19, scope: !211)
!234 = !DILocation(line: 32, column: 17, scope: !211)
!235 = !DILocation(line: 35, column: 23, scope: !211)
!236 = !DILocation(line: 37, column: 17, scope: !211)
!237 = !DILocation(line: 33, column: 21, scope: !211)
!238 = !DILocation(line: 34, column: 21, scope: !211)
!239 = distinct !DISubprogram(name: "GetValueFromIndex", linkageName: "Simatic.Ax.Json.Deserializer.GetValueFromIndex$I@R@Simatic.Ax.Json.Deserializer@this?I@V@Int16@startIndex?I@V@Int16@endIndex", scope: !51, file: !52, line: 44, type: !240, scopeLine: 44, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!240 = !DISubroutineType(types: !241)
!241 = !{!66, !204, !32, !32}
!242 = !DILocalVariable(name: "startIndex", arg: 2, scope: !239, file: !52, line: 46, type: !32, flags: DIFlagTypePassByValue)
!243 = !DILocation(line: 46, column: 16, scope: !239)
!244 = !DILocalVariable(name: "endIndex", arg: 3, scope: !239, file: !52, line: 47, type: !32, flags: DIFlagTypePassByValue)
!245 = !DILocation(line: 47, column: 16, scope: !239)
!246 = !DILocalVariable(name: "this", arg: 1, scope: !239, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!247 = !DILocation(line: 44, column: 24, scope: !239)
!248 = !DILocalVariable(name: "index", scope: !239, file: !52, line: 50, type: !32)
!249 = !DILocation(line: 50, column: 17, scope: !239)
!250 = !DILocalVariable(name: "realStartIndex", scope: !239, file: !52, line: 51, type: !32)
!251 = !DILocation(line: 51, column: 17, scope: !239)
!252 = !DILocalVariable(name: "realEndIndex", scope: !239, file: !52, line: 52, type: !32)
!253 = !DILocation(line: 52, column: 17, scope: !239)
!254 = !DILocalVariable(name: "incrementBackwards", scope: !239, file: !52, line: 54, type: !32)
!255 = !DILocation(line: 54, column: 17, scope: !239)
!256 = !DILocalVariable(name: "GetValueFromIndex", scope: !239, file: !52, line: 44, type: !66)
!257 = !DILocation(line: 57, column: 40, scope: !239)
!258 = !DILocation(line: 57, column: 17, scope: !239)
!259 = !DILocation(line: 57, column: 13, scope: !239)
!260 = !DILocation(line: 62, column: 20, scope: !239)
!261 = !DILocation(line: 65, column: 56, scope: !239)
!262 = !DILocation(line: 65, column: 38, scope: !239)
!263 = !DILocation(line: 65, column: 17, scope: !239)
!264 = !DILocation(line: 58, column: 17, scope: !239)
!265 = !DILocation(line: 61, column: 23, scope: !239)
!266 = !DILocation(line: 59, column: 21, scope: !239)
!267 = !DILocation(line: 60, column: 21, scope: !239)
!268 = !DILocation(line: 71, column: 20, scope: !239)
!269 = !DILocation(line: 73, column: 13, scope: !239)
!270 = !DILocation(line: 74, column: 19, scope: !239)
!271 = !DILocation(line: 65, column: 13, scope: !239)
!272 = !DILocation(line: 66, column: 17, scope: !239)
!273 = !DILocation(line: 69, column: 23, scope: !239)
!274 = !DILocation(line: 67, column: 21, scope: !239)
!275 = !DILocation(line: 68, column: 21, scope: !239)
!276 = distinct !DISubprogram(name: "GetBufferIndizes", linkageName: "Simatic.Ax.Json.Deserializer.GetBufferIndizes$I@R@Simatic.Ax.Json.Deserializer@this?O@V@Int16@bufferStart?O@V@Int16@bufferEnd", scope: !51, file: !52, line: 76, type: !277, scopeLine: 76, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!277 = !DISubroutineType(types: !278)
!278 = !{null, !204, !279, !279}
!279 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !32, size: 64, align: 64, dwarfAddressSpace: 0)
!280 = !DILocalVariable(name: "bufferStart", arg: 2, scope: !276, file: !52, line: 78, type: !279, flags: DIFlagTypePassByValue)
!281 = !DILocation(line: 78, column: 17, scope: !276)
!282 = !DILocalVariable(name: "bufferEnd", arg: 3, scope: !276, file: !52, line: 79, type: !279, flags: DIFlagTypePassByValue)
!283 = !DILocation(line: 79, column: 17, scope: !276)
!284 = !DILocalVariable(name: "this", arg: 1, scope: !276, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!285 = !DILocation(line: 76, column: 24, scope: !276)
!286 = !DILocalVariable(name: "index", scope: !276, file: !52, line: 82, type: !32)
!287 = !DILocation(line: 82, column: 17, scope: !276)
!288 = !DILocalVariable(name: "incrementBackwards", scope: !276, file: !52, line: 83, type: !32)
!289 = !DILocation(line: 83, column: 17, scope: !276)
!290 = !DILocation(line: 86, column: 31, scope: !276)
!291 = !DILocation(line: 86, column: 17, scope: !276)
!292 = !DILocation(line: 86, column: 13, scope: !276)
!293 = !DILocation(line: 91, column: 20, scope: !276)
!294 = !DILocation(line: 93, column: 38, scope: !276)
!295 = !DILocation(line: 93, column: 33, scope: !276)
!296 = !DILocation(line: 93, column: 17, scope: !276)
!297 = !DILocation(line: 87, column: 17, scope: !276)
!298 = !DILocation(line: 90, column: 23, scope: !276)
!299 = !DILocation(line: 88, column: 21, scope: !276)
!300 = !DILocation(line: 89, column: 21, scope: !276)
!301 = !DILocation(line: 98, column: 20, scope: !276)
!302 = !DILocation(line: 99, column: 19, scope: !276)
!303 = !DILocation(line: 93, column: 13, scope: !276)
!304 = !DILocation(line: 94, column: 17, scope: !276)
!305 = !DILocation(line: 97, column: 23, scope: !276)
!306 = !DILocation(line: 95, column: 21, scope: !276)
!307 = !DILocation(line: 96, column: 21, scope: !276)
!308 = distinct !DISubprogram(name: "GetValue_WithKeyArray", linkageName: "Simatic.Ax.Json.Deserializer.GetValue_WithKeyArray$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@areaStartIndex?O@V@Int16@areaEndIndex", scope: !51, file: !52, line: 101, type: !309, scopeLine: 101, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!309 = !DISubroutineType(types: !310)
!310 = !{!77, !204, !311, !279, !279}
!311 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !66, size: 64, align: 64, dwarfAddressSpace: 0)
!312 = !DILocalVariable(name: "keyArray", arg: 2, scope: !308, file: !52, line: 103, type: !311, flags: DIFlagTypePassByValue)
!313 = !DILocation(line: 103, column: 17, scope: !308)
!314 = !DILocalVariable(name: "areaStartIndex", arg: 3, scope: !308, file: !52, line: 129, type: !279, flags: DIFlagTypePassByValue)
!315 = !DILocation(line: 129, column: 17, scope: !308)
!316 = !DILocalVariable(name: "areaEndIndex", arg: 4, scope: !308, file: !52, line: 130, type: !279, flags: DIFlagTypePassByValue)
!317 = !DILocation(line: 130, column: 17, scope: !308)
!318 = !DILocalVariable(name: "this", arg: 1, scope: !308, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!319 = !DILocation(line: 101, column: 24, scope: !308)
!320 = !DILocalVariable(name: "key", scope: !308, file: !52, line: 106, type: !66)
!321 = !DILocation(line: 106, column: 17, scope: !308)
!322 = !DILocalVariable(name: "keyFound", scope: !308, file: !52, line: 107, type: !77)
!323 = !DILocation(line: 107, column: 17, scope: !308)
!324 = !DILocalVariable(name: "valueFound", scope: !308, file: !52, line: 108, type: !77)
!325 = !DILocation(line: 108, column: 17, scope: !308)
!326 = !DILocalVariable(name: "keyIndex", scope: !308, file: !52, line: 110, type: !74)
!327 = !DILocation(line: 110, column: 17, scope: !308)
!328 = !DILocalVariable(name: "index", scope: !308, file: !52, line: 111, type: !32)
!329 = !DILocation(line: 111, column: 17, scope: !308)
!330 = !DILocalVariable(name: "quotationMarkCount", scope: !308, file: !52, line: 113, type: !32)
!331 = !DILocation(line: 113, column: 17, scope: !308)
!332 = !DILocalVariable(name: "bracesCount", scope: !308, file: !52, line: 114, type: !32)
!333 = !DILocation(line: 114, column: 17, scope: !308)
!334 = !DILocalVariable(name: "squareBrakedCount", scope: !308, file: !52, line: 115, type: !32)
!335 = !DILocation(line: 115, column: 17, scope: !308)
!336 = !DILocalVariable(name: "inKeyArea", scope: !308, file: !52, line: 117, type: !77)
!337 = !DILocation(line: 117, column: 17, scope: !308)
!338 = !DILocalVariable(name: "inValueArea", scope: !308, file: !52, line: 118, type: !77)
!339 = !DILocation(line: 118, column: 17, scope: !308)
!340 = !DILocalVariable(name: "inArrayArea", scope: !308, file: !52, line: 119, type: !77)
!341 = !DILocation(line: 119, column: 17, scope: !308)
!342 = !DILocalVariable(name: "inNestedArea", scope: !308, file: !52, line: 120, type: !77)
!343 = !DILocation(line: 120, column: 17, scope: !308)
!344 = !DILocalVariable(name: "documentStartIndex", scope: !308, file: !52, line: 122, type: !32)
!345 = !DILocation(line: 122, column: 17, scope: !308)
!346 = !DILocalVariable(name: "documentEndIndex", scope: !308, file: !52, line: 123, type: !32)
!347 = !DILocation(line: 123, column: 17, scope: !308)
!348 = !DILocalVariable(name: "keyArrayLower", scope: !308, file: !52, line: 125, type: !74)
!349 = !DILocation(line: 125, column: 17, scope: !308)
!350 = !DILocalVariable(name: "keyArrayUpper", scope: !308, file: !52, line: 126, type: !74)
!351 = !DILocation(line: 126, column: 17, scope: !308)
!352 = !DILocalVariable(name: "GetValue_WithKeyArray", scope: !308, file: !52, line: 101, type: !77)
!353 = !DILocation(line: 133, column: 13, scope: !308)
!354 = !DILocation(line: 135, column: 13, scope: !308)
!355 = !DILocation(line: 136, column: 13, scope: !308)
!356 = !DILocation(line: 139, column: 46, scope: !308)
!357 = !DILocation(line: 139, column: 17, scope: !308)
!358 = !DILocation(line: 139, column: 13, scope: !308)
!359 = !DILocation(line: 279, column: 20, scope: !308)
!360 = !DILocation(line: 280, column: 19, scope: !308)
!361 = !DILocation(line: 140, column: 17, scope: !308)
!362 = !DILocation(line: 142, column: 52, scope: !308)
!363 = !DILocation(line: 142, column: 21, scope: !308)
!364 = !DILocation(line: 142, column: 17, scope: !308)
!365 = !DILocation(line: 263, column: 24, scope: !308)
!366 = !DILocation(line: 265, column: 17, scope: !308)
!367 = !DILocation(line: 145, column: 21, scope: !308)
!368 = !DILocation(line: 166, column: 27, scope: !308)
!369 = !DILocation(line: 169, column: 21, scope: !308)
!370 = !DILocation(line: 146, column: 25, scope: !308)
!371 = !DILocation(line: 165, column: 31, scope: !308)
!372 = !DILocation(line: 147, column: 29, scope: !308)
!373 = !DILocation(line: 149, column: 29, scope: !308)
!374 = !DILocation(line: 151, column: 35, scope: !308)
!375 = !DILocation(line: 153, column: 29, scope: !308)
!376 = !DILocation(line: 150, column: 33, scope: !308)
!377 = !DILocation(line: 162, column: 35, scope: !308)
!378 = !DILocation(line: 164, column: 29, scope: !308)
!379 = !DILocation(line: 154, column: 33, scope: !308)
!380 = !DILocation(line: 156, column: 33, scope: !308)
!381 = !DILocation(line: 157, column: 33, scope: !308)
!382 = !DILocation(line: 159, column: 33, scope: !308)
!383 = !DILocation(line: 161, column: 39, scope: !308)
!384 = !DILocation(line: 160, column: 37, scope: !308)
!385 = !DILocation(line: 199, column: 27, scope: !308)
!386 = !DILocation(line: 202, column: 21, scope: !308)
!387 = !DILocation(line: 170, column: 25, scope: !308)
!388 = !DILocation(line: 183, column: 31, scope: !308)
!389 = !DILocation(line: 185, column: 25, scope: !308)
!390 = !DILocation(line: 171, column: 29, scope: !308)
!391 = !DILocation(line: 173, column: 29, scope: !308)
!392 = !DILocation(line: 180, column: 35, scope: !308)
!393 = !DILocation(line: 182, column: 29, scope: !308)
!394 = !DILocation(line: 174, column: 33, scope: !308)
!395 = !DILocation(line: 175, column: 33, scope: !308)
!396 = !DILocation(line: 176, column: 33, scope: !308)
!397 = !DILocation(line: 177, column: 33, scope: !308)
!398 = !DILocation(line: 179, column: 33, scope: !308)
!399 = !DILocation(line: 198, column: 31, scope: !308)
!400 = !DILocation(line: 186, column: 29, scope: !308)
!401 = !DILocation(line: 188, column: 29, scope: !308)
!402 = !DILocation(line: 196, column: 35, scope: !308)
!403 = !DILocation(line: 189, column: 33, scope: !308)
!404 = !DILocation(line: 190, column: 33, scope: !308)
!405 = !DILocation(line: 191, column: 33, scope: !308)
!406 = !DILocation(line: 192, column: 33, scope: !308)
!407 = !DILocation(line: 194, column: 33, scope: !308)
!408 = !DILocation(line: 195, column: 33, scope: !308)
!409 = !DILocation(line: 232, column: 27, scope: !308)
!410 = !DILocation(line: 235, column: 21, scope: !308)
!411 = !DILocation(line: 203, column: 25, scope: !308)
!412 = !DILocation(line: 216, column: 31, scope: !308)
!413 = !DILocation(line: 218, column: 25, scope: !308)
!414 = !DILocation(line: 204, column: 29, scope: !308)
!415 = !DILocation(line: 206, column: 29, scope: !308)
!416 = !DILocation(line: 213, column: 35, scope: !308)
!417 = !DILocation(line: 215, column: 29, scope: !308)
!418 = !DILocation(line: 207, column: 33, scope: !308)
!419 = !DILocation(line: 208, column: 33, scope: !308)
!420 = !DILocation(line: 209, column: 33, scope: !308)
!421 = !DILocation(line: 210, column: 33, scope: !308)
!422 = !DILocation(line: 212, column: 33, scope: !308)
!423 = !DILocation(line: 231, column: 31, scope: !308)
!424 = !DILocation(line: 219, column: 29, scope: !308)
!425 = !DILocation(line: 221, column: 29, scope: !308)
!426 = !DILocation(line: 229, column: 35, scope: !308)
!427 = !DILocation(line: 222, column: 33, scope: !308)
!428 = !DILocation(line: 223, column: 33, scope: !308)
!429 = !DILocation(line: 224, column: 33, scope: !308)
!430 = !DILocation(line: 225, column: 33, scope: !308)
!431 = !DILocation(line: 227, column: 33, scope: !308)
!432 = !DILocation(line: 228, column: 33, scope: !308)
!433 = !DILocation(line: 255, column: 27, scope: !308)
!434 = !DILocation(line: 257, column: 21, scope: !308)
!435 = !DILocation(line: 236, column: 25, scope: !308)
!436 = !DILocation(line: 244, column: 31, scope: !308)
!437 = !DILocation(line: 246, column: 25, scope: !308)
!438 = !DILocation(line: 237, column: 29, scope: !308)
!439 = !DILocation(line: 238, column: 29, scope: !308)
!440 = !DILocation(line: 239, column: 29, scope: !308)
!441 = !DILocation(line: 240, column: 29, scope: !308)
!442 = !DILocation(line: 242, column: 29, scope: !308)
!443 = !DILocation(line: 243, column: 29, scope: !308)
!444 = !DILocation(line: 254, column: 31, scope: !308)
!445 = !DILocation(line: 247, column: 29, scope: !308)
!446 = !DILocation(line: 248, column: 29, scope: !308)
!447 = !DILocation(line: 249, column: 29, scope: !308)
!448 = !DILocation(line: 250, column: 29, scope: !308)
!449 = !DILocation(line: 252, column: 29, scope: !308)
!450 = !DILocation(line: 253, column: 29, scope: !308)
!451 = !DILocation(line: 259, column: 27, scope: !308)
!452 = !DILocation(line: 261, column: 21, scope: !308)
!453 = !DILocation(line: 258, column: 25, scope: !308)
!454 = !DILocation(line: 275, column: 21, scope: !308)
!455 = !DILocation(line: 276, column: 21, scope: !308)
!456 = !DILocation(line: 277, column: 23, scope: !308)
!457 = !DILocation(line: 267, column: 21, scope: !308)
!458 = !DILocation(line: 268, column: 21, scope: !308)
!459 = !DILocation(line: 269, column: 21, scope: !308)
!460 = !DILocation(line: 271, column: 21, scope: !308)
!461 = !DILocation(line: 272, column: 21, scope: !308)
!462 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@STRING@value", scope: !51, file: !52, line: 282, type: !463, scopeLine: 282, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!463 = !DISubroutineType(types: !464)
!464 = !{!77, !204, !214, !214}
!465 = !DILocalVariable(name: "key", arg: 2, scope: !462, file: !52, line: 284, type: !66, flags: DIFlagTypePassByValue)
!466 = !DILocation(line: 284, column: 17, scope: !462)
!467 = !DILocalVariable(name: "value", arg: 3, scope: !462, file: !52, line: 292, type: !311, flags: DIFlagTypePassByValue)
!468 = !DILocation(line: 292, column: 17, scope: !462)
!469 = !DILocalVariable(name: "this", arg: 1, scope: !462, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!470 = !DILocation(line: 282, column: 23, scope: !462)
!471 = !DILocalVariable(name: "keyArray", scope: !462, file: !52, line: 287, type: !472)
!472 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..0] OF STRING", file: !52, line: 287, baseType: !473, align: 8)
!473 = !DICompositeType(tag: DW_TAG_array_type, baseType: !66, size: 2056, align: 8, elements: !474)
!474 = !{!475}
!475 = !DISubrange(count: 1)
!476 = !DILocation(line: 287, column: 17, scope: !462)
!477 = !DILocalVariable(name: "valueStartIndex", scope: !462, file: !52, line: 288, type: !32)
!478 = !DILocation(line: 288, column: 17, scope: !462)
!479 = !DILocalVariable(name: "valueEndIndex", scope: !462, file: !52, line: 289, type: !32)
!480 = !DILocation(line: 289, column: 17, scope: !462)
!481 = !DILocalVariable(name: "TryParse", scope: !462, file: !52, line: 282, type: !77)
!482 = !DILocation(line: 295, column: 13, scope: !462)
!483 = !DILocation(line: 297, column: 13, scope: !462)
!484 = !DILocation(line: 299, column: 13, scope: !462)
!485 = !DILocation(line: 302, column: 17, scope: !462)
!486 = !DILocation(line: 303, column: 19, scope: !462)
!487 = !DILocation(line: 305, column: 19, scope: !462)
!488 = !DILocation(line: 300, column: 17, scope: !462)
!489 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@STRING@value", scope: !51, file: !52, line: 307, type: !490, scopeLine: 307, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!490 = !DISubroutineType(types: !491)
!491 = !{!77, !204, !311, !214}
!492 = !DILocalVariable(name: "keyArray", arg: 2, scope: !489, file: !52, line: 309, type: !311, flags: DIFlagTypePassByValue)
!493 = !DILocation(line: 309, column: 17, scope: !489)
!494 = !DILocalVariable(name: "value", arg: 3, scope: !489, file: !52, line: 316, type: !311, flags: DIFlagTypePassByValue)
!495 = !DILocation(line: 316, column: 17, scope: !489)
!496 = !DILocalVariable(name: "this", arg: 1, scope: !489, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!497 = !DILocation(line: 307, column: 23, scope: !489)
!498 = !DILocalVariable(name: "valueStartIndex", scope: !489, file: !52, line: 312, type: !32)
!499 = !DILocation(line: 312, column: 17, scope: !489)
!500 = !DILocalVariable(name: "valueEndIndex", scope: !489, file: !52, line: 313, type: !32)
!501 = !DILocation(line: 313, column: 17, scope: !489)
!502 = !DILocalVariable(name: "TryParse", scope: !489, file: !52, line: 307, type: !77)
!503 = !DILocation(line: 319, column: 13, scope: !489)
!504 = !DILocation(line: 321, column: 13, scope: !489)
!505 = !DILocation(line: 324, column: 17, scope: !489)
!506 = !DILocation(line: 325, column: 19, scope: !489)
!507 = !DILocation(line: 327, column: 19, scope: !489)
!508 = !DILocation(line: 322, column: 17, scope: !489)
!509 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int8@value", scope: !51, file: !52, line: 329, type: !510, scopeLine: 329, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!510 = !DISubroutineType(types: !511)
!511 = !{!77, !204, !214, !512}
!512 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !513, size: 64, align: 64, dwarfAddressSpace: 0)
!513 = !DIDerivedType(tag: DW_TAG_typedef, name: "SINT", baseType: !514, align: 8)
!514 = !DIBasicType(name: "Int8", size: 8, encoding: DW_ATE_signed)
!515 = !DILocalVariable(name: "key", arg: 2, scope: !509, file: !52, line: 331, type: !66, flags: DIFlagTypePassByValue)
!516 = !DILocation(line: 331, column: 17, scope: !509)
!517 = !DILocalVariable(name: "value", arg: 3, scope: !509, file: !52, line: 339, type: !512, flags: DIFlagTypePassByValue)
!518 = !DILocation(line: 339, column: 17, scope: !509)
!519 = !DILocalVariable(name: "this", arg: 1, scope: !509, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!520 = !DILocation(line: 329, column: 23, scope: !509)
!521 = !DILocalVariable(name: "keyArray", scope: !509, file: !52, line: 334, type: !472)
!522 = !DILocation(line: 334, column: 17, scope: !509)
!523 = !DILocalVariable(name: "valueStartIndex", scope: !509, file: !52, line: 335, type: !32)
!524 = !DILocation(line: 335, column: 17, scope: !509)
!525 = !DILocalVariable(name: "valueEndIndex", scope: !509, file: !52, line: 336, type: !32)
!526 = !DILocation(line: 336, column: 17, scope: !509)
!527 = !DILocalVariable(name: "TryParse", scope: !509, file: !52, line: 329, type: !77)
!528 = !DILocation(line: 342, column: 13, scope: !509)
!529 = !DILocation(line: 344, column: 13, scope: !509)
!530 = !DILocation(line: 346, column: 13, scope: !509)
!531 = !DILocation(line: 348, column: 19, scope: !509)
!532 = !DILocation(line: 350, column: 13, scope: !509)
!533 = !DILocation(line: 347, column: 17, scope: !509)
!534 = !DILocation(line: 352, column: 19, scope: !509)
!535 = !DILocation(line: 354, column: 19, scope: !509)
!536 = !DILocation(line: 351, column: 17, scope: !509)
!537 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int8@value", scope: !51, file: !52, line: 356, type: !538, scopeLine: 356, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!538 = !DISubroutineType(types: !539)
!539 = !{!77, !204, !311, !512}
!540 = !DILocalVariable(name: "keyArray", arg: 2, scope: !537, file: !52, line: 358, type: !311, flags: DIFlagTypePassByValue)
!541 = !DILocation(line: 358, column: 17, scope: !537)
!542 = !DILocalVariable(name: "value", arg: 3, scope: !537, file: !52, line: 365, type: !512, flags: DIFlagTypePassByValue)
!543 = !DILocation(line: 365, column: 17, scope: !537)
!544 = !DILocalVariable(name: "this", arg: 1, scope: !537, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!545 = !DILocation(line: 356, column: 23, scope: !537)
!546 = !DILocalVariable(name: "valueStartIndex", scope: !537, file: !52, line: 361, type: !32)
!547 = !DILocation(line: 361, column: 17, scope: !537)
!548 = !DILocalVariable(name: "valueEndIndex", scope: !537, file: !52, line: 362, type: !32)
!549 = !DILocation(line: 362, column: 17, scope: !537)
!550 = !DILocalVariable(name: "TryParse", scope: !537, file: !52, line: 356, type: !77)
!551 = !DILocation(line: 368, column: 13, scope: !537)
!552 = !DILocation(line: 370, column: 13, scope: !537)
!553 = !DILocation(line: 372, column: 19, scope: !537)
!554 = !DILocation(line: 374, column: 13, scope: !537)
!555 = !DILocation(line: 371, column: 17, scope: !537)
!556 = !DILocation(line: 376, column: 19, scope: !537)
!557 = !DILocation(line: 378, column: 19, scope: !537)
!558 = !DILocation(line: 375, column: 17, scope: !537)
!559 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int64@value", scope: !51, file: !52, line: 380, type: !560, scopeLine: 380, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!560 = !DISubroutineType(types: !561)
!561 = !{!77, !204, !214, !562}
!562 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !563, size: 64, align: 64, dwarfAddressSpace: 0)
!563 = !DIDerivedType(tag: DW_TAG_typedef, name: "LINT", baseType: !564, align: 64)
!564 = !DIBasicType(name: "Int64", size: 64, encoding: DW_ATE_signed)
!565 = !DILocalVariable(name: "key", arg: 2, scope: !559, file: !52, line: 382, type: !66, flags: DIFlagTypePassByValue)
!566 = !DILocation(line: 382, column: 17, scope: !559)
!567 = !DILocalVariable(name: "value", arg: 3, scope: !559, file: !52, line: 390, type: !562, flags: DIFlagTypePassByValue)
!568 = !DILocation(line: 390, column: 17, scope: !559)
!569 = !DILocalVariable(name: "this", arg: 1, scope: !559, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!570 = !DILocation(line: 380, column: 23, scope: !559)
!571 = !DILocalVariable(name: "keyArray", scope: !559, file: !52, line: 385, type: !472)
!572 = !DILocation(line: 385, column: 17, scope: !559)
!573 = !DILocalVariable(name: "valueStartIndex", scope: !559, file: !52, line: 386, type: !32)
!574 = !DILocation(line: 386, column: 17, scope: !559)
!575 = !DILocalVariable(name: "valueEndIndex", scope: !559, file: !52, line: 387, type: !32)
!576 = !DILocation(line: 387, column: 17, scope: !559)
!577 = !DILocalVariable(name: "TryParse", scope: !559, file: !52, line: 380, type: !77)
!578 = !DILocation(line: 393, column: 13, scope: !559)
!579 = !DILocation(line: 395, column: 13, scope: !559)
!580 = !DILocation(line: 397, column: 13, scope: !559)
!581 = !DILocation(line: 399, column: 19, scope: !559)
!582 = !DILocation(line: 401, column: 13, scope: !559)
!583 = !DILocation(line: 398, column: 17, scope: !559)
!584 = !DILocation(line: 403, column: 19, scope: !559)
!585 = !DILocation(line: 405, column: 19, scope: !559)
!586 = !DILocation(line: 402, column: 17, scope: !559)
!587 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int64@value", scope: !51, file: !52, line: 407, type: !588, scopeLine: 407, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!588 = !DISubroutineType(types: !589)
!589 = !{!77, !204, !311, !562}
!590 = !DILocalVariable(name: "keyArray", arg: 2, scope: !587, file: !52, line: 409, type: !311, flags: DIFlagTypePassByValue)
!591 = !DILocation(line: 409, column: 17, scope: !587)
!592 = !DILocalVariable(name: "value", arg: 3, scope: !587, file: !52, line: 416, type: !562, flags: DIFlagTypePassByValue)
!593 = !DILocation(line: 416, column: 17, scope: !587)
!594 = !DILocalVariable(name: "this", arg: 1, scope: !587, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!595 = !DILocation(line: 407, column: 23, scope: !587)
!596 = !DILocalVariable(name: "valueStartIndex", scope: !587, file: !52, line: 412, type: !32)
!597 = !DILocation(line: 412, column: 17, scope: !587)
!598 = !DILocalVariable(name: "valueEndIndex", scope: !587, file: !52, line: 413, type: !32)
!599 = !DILocation(line: 413, column: 17, scope: !587)
!600 = !DILocalVariable(name: "TryParse", scope: !587, file: !52, line: 407, type: !77)
!601 = !DILocation(line: 419, column: 13, scope: !587)
!602 = !DILocation(line: 421, column: 13, scope: !587)
!603 = !DILocation(line: 423, column: 19, scope: !587)
!604 = !DILocation(line: 425, column: 13, scope: !587)
!605 = !DILocation(line: 422, column: 17, scope: !587)
!606 = !DILocation(line: 427, column: 19, scope: !587)
!607 = !DILocation(line: 429, column: 19, scope: !587)
!608 = !DILocation(line: 426, column: 17, scope: !587)
!609 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int32@value", scope: !51, file: !52, line: 431, type: !610, scopeLine: 431, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!610 = !DISubroutineType(types: !611)
!611 = !{!77, !204, !214, !612}
!612 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !74, size: 64, align: 64, dwarfAddressSpace: 0)
!613 = !DILocalVariable(name: "key", arg: 2, scope: !609, file: !52, line: 433, type: !66, flags: DIFlagTypePassByValue)
!614 = !DILocation(line: 433, column: 17, scope: !609)
!615 = !DILocalVariable(name: "value", arg: 3, scope: !609, file: !52, line: 441, type: !612, flags: DIFlagTypePassByValue)
!616 = !DILocation(line: 441, column: 17, scope: !609)
!617 = !DILocalVariable(name: "this", arg: 1, scope: !609, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!618 = !DILocation(line: 431, column: 23, scope: !609)
!619 = !DILocalVariable(name: "keyArray", scope: !609, file: !52, line: 436, type: !472)
!620 = !DILocation(line: 436, column: 17, scope: !609)
!621 = !DILocalVariable(name: "valueStartIndex", scope: !609, file: !52, line: 437, type: !32)
!622 = !DILocation(line: 437, column: 17, scope: !609)
!623 = !DILocalVariable(name: "valueEndIndex", scope: !609, file: !52, line: 438, type: !32)
!624 = !DILocation(line: 438, column: 17, scope: !609)
!625 = !DILocalVariable(name: "TryParse", scope: !609, file: !52, line: 431, type: !77)
!626 = !DILocation(line: 444, column: 13, scope: !609)
!627 = !DILocation(line: 446, column: 13, scope: !609)
!628 = !DILocation(line: 448, column: 13, scope: !609)
!629 = !DILocation(line: 450, column: 19, scope: !609)
!630 = !DILocation(line: 452, column: 13, scope: !609)
!631 = !DILocation(line: 449, column: 17, scope: !609)
!632 = !DILocation(line: 454, column: 19, scope: !609)
!633 = !DILocation(line: 456, column: 19, scope: !609)
!634 = !DILocation(line: 453, column: 17, scope: !609)
!635 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int32@value", scope: !51, file: !52, line: 458, type: !636, scopeLine: 458, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!636 = !DISubroutineType(types: !637)
!637 = !{!77, !204, !311, !612}
!638 = !DILocalVariable(name: "keyArray", arg: 2, scope: !635, file: !52, line: 460, type: !311, flags: DIFlagTypePassByValue)
!639 = !DILocation(line: 460, column: 17, scope: !635)
!640 = !DILocalVariable(name: "value", arg: 3, scope: !635, file: !52, line: 467, type: !612, flags: DIFlagTypePassByValue)
!641 = !DILocation(line: 467, column: 17, scope: !635)
!642 = !DILocalVariable(name: "this", arg: 1, scope: !635, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!643 = !DILocation(line: 458, column: 23, scope: !635)
!644 = !DILocalVariable(name: "valueStartIndex", scope: !635, file: !52, line: 463, type: !32)
!645 = !DILocation(line: 463, column: 17, scope: !635)
!646 = !DILocalVariable(name: "valueEndIndex", scope: !635, file: !52, line: 464, type: !32)
!647 = !DILocation(line: 464, column: 17, scope: !635)
!648 = !DILocalVariable(name: "TryParse", scope: !635, file: !52, line: 458, type: !77)
!649 = !DILocation(line: 470, column: 13, scope: !635)
!650 = !DILocation(line: 472, column: 13, scope: !635)
!651 = !DILocation(line: 474, column: 19, scope: !635)
!652 = !DILocation(line: 476, column: 13, scope: !635)
!653 = !DILocation(line: 473, column: 17, scope: !635)
!654 = !DILocation(line: 478, column: 19, scope: !635)
!655 = !DILocation(line: 480, column: 19, scope: !635)
!656 = !DILocation(line: 477, column: 17, scope: !635)
!657 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@Int16@value", scope: !51, file: !52, line: 482, type: !658, scopeLine: 482, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!658 = !DISubroutineType(types: !659)
!659 = !{!77, !204, !214, !279}
!660 = !DILocalVariable(name: "key", arg: 2, scope: !657, file: !52, line: 484, type: !66, flags: DIFlagTypePassByValue)
!661 = !DILocation(line: 484, column: 17, scope: !657)
!662 = !DILocalVariable(name: "value", arg: 3, scope: !657, file: !52, line: 492, type: !279, flags: DIFlagTypePassByValue)
!663 = !DILocation(line: 492, column: 17, scope: !657)
!664 = !DILocalVariable(name: "this", arg: 1, scope: !657, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!665 = !DILocation(line: 482, column: 23, scope: !657)
!666 = !DILocalVariable(name: "keyArray", scope: !657, file: !52, line: 487, type: !472)
!667 = !DILocation(line: 487, column: 17, scope: !657)
!668 = !DILocalVariable(name: "valueStartIndex", scope: !657, file: !52, line: 488, type: !32)
!669 = !DILocation(line: 488, column: 17, scope: !657)
!670 = !DILocalVariable(name: "valueEndIndex", scope: !657, file: !52, line: 489, type: !32)
!671 = !DILocation(line: 489, column: 17, scope: !657)
!672 = !DILocalVariable(name: "TryParse", scope: !657, file: !52, line: 482, type: !77)
!673 = !DILocation(line: 495, column: 13, scope: !657)
!674 = !DILocation(line: 497, column: 13, scope: !657)
!675 = !DILocation(line: 499, column: 13, scope: !657)
!676 = !DILocation(line: 501, column: 19, scope: !657)
!677 = !DILocation(line: 503, column: 13, scope: !657)
!678 = !DILocation(line: 500, column: 17, scope: !657)
!679 = !DILocation(line: 505, column: 19, scope: !657)
!680 = !DILocation(line: 507, column: 19, scope: !657)
!681 = !DILocation(line: 504, column: 17, scope: !657)
!682 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@Int16@value", scope: !51, file: !52, line: 509, type: !683, scopeLine: 509, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!683 = !DISubroutineType(types: !684)
!684 = !{!77, !204, !311, !279}
!685 = !DILocalVariable(name: "keyArray", arg: 2, scope: !682, file: !52, line: 511, type: !311, flags: DIFlagTypePassByValue)
!686 = !DILocation(line: 511, column: 17, scope: !682)
!687 = !DILocalVariable(name: "value", arg: 3, scope: !682, file: !52, line: 518, type: !279, flags: DIFlagTypePassByValue)
!688 = !DILocation(line: 518, column: 17, scope: !682)
!689 = !DILocalVariable(name: "this", arg: 1, scope: !682, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!690 = !DILocation(line: 509, column: 23, scope: !682)
!691 = !DILocalVariable(name: "valueStartIndex", scope: !682, file: !52, line: 514, type: !32)
!692 = !DILocation(line: 514, column: 17, scope: !682)
!693 = !DILocalVariable(name: "valueEndIndex", scope: !682, file: !52, line: 515, type: !32)
!694 = !DILocation(line: 515, column: 17, scope: !682)
!695 = !DILocalVariable(name: "TryParse", scope: !682, file: !52, line: 509, type: !77)
!696 = !DILocation(line: 521, column: 13, scope: !682)
!697 = !DILocation(line: 523, column: 13, scope: !682)
!698 = !DILocation(line: 525, column: 19, scope: !682)
!699 = !DILocation(line: 527, column: 13, scope: !682)
!700 = !DILocation(line: 524, column: 17, scope: !682)
!701 = !DILocation(line: 529, column: 19, scope: !682)
!702 = !DILocation(line: 531, column: 19, scope: !682)
!703 = !DILocation(line: 528, column: 17, scope: !682)
!704 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt8@value", scope: !51, file: !52, line: 533, type: !705, scopeLine: 533, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!705 = !DISubroutineType(types: !706)
!706 = !{!77, !204, !214, !707}
!707 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !36, size: 64, align: 64, dwarfAddressSpace: 0)
!708 = !DILocalVariable(name: "key", arg: 2, scope: !704, file: !52, line: 535, type: !66, flags: DIFlagTypePassByValue)
!709 = !DILocation(line: 535, column: 17, scope: !704)
!710 = !DILocalVariable(name: "value", arg: 3, scope: !704, file: !52, line: 543, type: !707, flags: DIFlagTypePassByValue)
!711 = !DILocation(line: 543, column: 17, scope: !704)
!712 = !DILocalVariable(name: "this", arg: 1, scope: !704, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!713 = !DILocation(line: 533, column: 23, scope: !704)
!714 = !DILocalVariable(name: "keyArray", scope: !704, file: !52, line: 538, type: !472)
!715 = !DILocation(line: 538, column: 17, scope: !704)
!716 = !DILocalVariable(name: "valueStartIndex", scope: !704, file: !52, line: 539, type: !32)
!717 = !DILocation(line: 539, column: 17, scope: !704)
!718 = !DILocalVariable(name: "valueEndIndex", scope: !704, file: !52, line: 540, type: !32)
!719 = !DILocation(line: 540, column: 17, scope: !704)
!720 = !DILocalVariable(name: "TryParse", scope: !704, file: !52, line: 533, type: !77)
!721 = !DILocation(line: 546, column: 13, scope: !704)
!722 = !DILocation(line: 548, column: 13, scope: !704)
!723 = !DILocation(line: 550, column: 13, scope: !704)
!724 = !DILocation(line: 552, column: 19, scope: !704)
!725 = !DILocation(line: 554, column: 13, scope: !704)
!726 = !DILocation(line: 551, column: 17, scope: !704)
!727 = !DILocation(line: 556, column: 19, scope: !704)
!728 = !DILocation(line: 558, column: 19, scope: !704)
!729 = !DILocation(line: 555, column: 17, scope: !704)
!730 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt8@value", scope: !51, file: !52, line: 560, type: !731, scopeLine: 560, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!731 = !DISubroutineType(types: !732)
!732 = !{!77, !204, !311, !707}
!733 = !DILocalVariable(name: "keyArray", arg: 2, scope: !730, file: !52, line: 562, type: !311, flags: DIFlagTypePassByValue)
!734 = !DILocation(line: 562, column: 17, scope: !730)
!735 = !DILocalVariable(name: "value", arg: 3, scope: !730, file: !52, line: 569, type: !707, flags: DIFlagTypePassByValue)
!736 = !DILocation(line: 569, column: 17, scope: !730)
!737 = !DILocalVariable(name: "this", arg: 1, scope: !730, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!738 = !DILocation(line: 560, column: 23, scope: !730)
!739 = !DILocalVariable(name: "valueStartIndex", scope: !730, file: !52, line: 565, type: !32)
!740 = !DILocation(line: 565, column: 17, scope: !730)
!741 = !DILocalVariable(name: "valueEndIndex", scope: !730, file: !52, line: 566, type: !32)
!742 = !DILocation(line: 566, column: 17, scope: !730)
!743 = !DILocalVariable(name: "TryParse", scope: !730, file: !52, line: 560, type: !77)
!744 = !DILocation(line: 572, column: 13, scope: !730)
!745 = !DILocation(line: 574, column: 13, scope: !730)
!746 = !DILocation(line: 576, column: 19, scope: !730)
!747 = !DILocation(line: 578, column: 13, scope: !730)
!748 = !DILocation(line: 575, column: 17, scope: !730)
!749 = !DILocation(line: 580, column: 19, scope: !730)
!750 = !DILocation(line: 582, column: 19, scope: !730)
!751 = !DILocation(line: 579, column: 17, scope: !730)
!752 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt16@value", scope: !51, file: !52, line: 584, type: !753, scopeLine: 584, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!753 = !DISubroutineType(types: !754)
!754 = !{!77, !204, !214, !755}
!755 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !756, size: 64, align: 64, dwarfAddressSpace: 0)
!756 = !DIDerivedType(tag: DW_TAG_typedef, name: "UINT", baseType: !27, align: 16)
!757 = !DILocalVariable(name: "key", arg: 2, scope: !752, file: !52, line: 586, type: !66, flags: DIFlagTypePassByValue)
!758 = !DILocation(line: 586, column: 17, scope: !752)
!759 = !DILocalVariable(name: "value", arg: 3, scope: !752, file: !52, line: 594, type: !755, flags: DIFlagTypePassByValue)
!760 = !DILocation(line: 594, column: 17, scope: !752)
!761 = !DILocalVariable(name: "this", arg: 1, scope: !752, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!762 = !DILocation(line: 584, column: 23, scope: !752)
!763 = !DILocalVariable(name: "keyArray", scope: !752, file: !52, line: 589, type: !472)
!764 = !DILocation(line: 589, column: 17, scope: !752)
!765 = !DILocalVariable(name: "valueStartIndex", scope: !752, file: !52, line: 590, type: !32)
!766 = !DILocation(line: 590, column: 17, scope: !752)
!767 = !DILocalVariable(name: "valueEndIndex", scope: !752, file: !52, line: 591, type: !32)
!768 = !DILocation(line: 591, column: 17, scope: !752)
!769 = !DILocalVariable(name: "TryParse", scope: !752, file: !52, line: 584, type: !77)
!770 = !DILocation(line: 597, column: 13, scope: !752)
!771 = !DILocation(line: 599, column: 13, scope: !752)
!772 = !DILocation(line: 601, column: 13, scope: !752)
!773 = !DILocation(line: 603, column: 19, scope: !752)
!774 = !DILocation(line: 605, column: 13, scope: !752)
!775 = !DILocation(line: 602, column: 17, scope: !752)
!776 = !DILocation(line: 607, column: 19, scope: !752)
!777 = !DILocation(line: 609, column: 19, scope: !752)
!778 = !DILocation(line: 606, column: 17, scope: !752)
!779 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt16@value", scope: !51, file: !52, line: 611, type: !780, scopeLine: 611, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!780 = !DISubroutineType(types: !781)
!781 = !{!77, !204, !311, !755}
!782 = !DILocalVariable(name: "keyArray", arg: 2, scope: !779, file: !52, line: 613, type: !311, flags: DIFlagTypePassByValue)
!783 = !DILocation(line: 613, column: 17, scope: !779)
!784 = !DILocalVariable(name: "value", arg: 3, scope: !779, file: !52, line: 620, type: !755, flags: DIFlagTypePassByValue)
!785 = !DILocation(line: 620, column: 17, scope: !779)
!786 = !DILocalVariable(name: "this", arg: 1, scope: !779, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!787 = !DILocation(line: 611, column: 23, scope: !779)
!788 = !DILocalVariable(name: "valueStartIndex", scope: !779, file: !52, line: 616, type: !32)
!789 = !DILocation(line: 616, column: 17, scope: !779)
!790 = !DILocalVariable(name: "valueEndIndex", scope: !779, file: !52, line: 617, type: !32)
!791 = !DILocation(line: 617, column: 17, scope: !779)
!792 = !DILocalVariable(name: "TryParse", scope: !779, file: !52, line: 611, type: !77)
!793 = !DILocation(line: 623, column: 13, scope: !779)
!794 = !DILocation(line: 625, column: 13, scope: !779)
!795 = !DILocation(line: 627, column: 19, scope: !779)
!796 = !DILocation(line: 629, column: 13, scope: !779)
!797 = !DILocation(line: 626, column: 17, scope: !779)
!798 = !DILocation(line: 631, column: 19, scope: !779)
!799 = !DILocation(line: 633, column: 19, scope: !779)
!800 = !DILocation(line: 630, column: 17, scope: !779)
!801 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt32@value", scope: !51, file: !52, line: 635, type: !802, scopeLine: 635, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!802 = !DISubroutineType(types: !803)
!803 = !{!77, !204, !214, !804}
!804 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !805, size: 64, align: 64, dwarfAddressSpace: 0)
!805 = !DIDerivedType(tag: DW_TAG_typedef, name: "UDINT", baseType: !806, align: 32)
!806 = !DIBasicType(name: "UInt32", size: 32, encoding: DW_ATE_unsigned)
!807 = !DILocalVariable(name: "key", arg: 2, scope: !801, file: !52, line: 637, type: !66, flags: DIFlagTypePassByValue)
!808 = !DILocation(line: 637, column: 17, scope: !801)
!809 = !DILocalVariable(name: "value", arg: 3, scope: !801, file: !52, line: 645, type: !804, flags: DIFlagTypePassByValue)
!810 = !DILocation(line: 645, column: 17, scope: !801)
!811 = !DILocalVariable(name: "this", arg: 1, scope: !801, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!812 = !DILocation(line: 635, column: 23, scope: !801)
!813 = !DILocalVariable(name: "keyArray", scope: !801, file: !52, line: 640, type: !472)
!814 = !DILocation(line: 640, column: 17, scope: !801)
!815 = !DILocalVariable(name: "valueStartIndex", scope: !801, file: !52, line: 641, type: !32)
!816 = !DILocation(line: 641, column: 17, scope: !801)
!817 = !DILocalVariable(name: "valueEndIndex", scope: !801, file: !52, line: 642, type: !32)
!818 = !DILocation(line: 642, column: 17, scope: !801)
!819 = !DILocalVariable(name: "TryParse", scope: !801, file: !52, line: 635, type: !77)
!820 = !DILocation(line: 648, column: 13, scope: !801)
!821 = !DILocation(line: 650, column: 13, scope: !801)
!822 = !DILocation(line: 652, column: 13, scope: !801)
!823 = !DILocation(line: 654, column: 19, scope: !801)
!824 = !DILocation(line: 656, column: 13, scope: !801)
!825 = !DILocation(line: 653, column: 17, scope: !801)
!826 = !DILocation(line: 658, column: 19, scope: !801)
!827 = !DILocation(line: 660, column: 19, scope: !801)
!828 = !DILocation(line: 657, column: 17, scope: !801)
!829 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt32@value", scope: !51, file: !52, line: 662, type: !830, scopeLine: 662, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!830 = !DISubroutineType(types: !831)
!831 = !{!77, !204, !311, !804}
!832 = !DILocalVariable(name: "keyArray", arg: 2, scope: !829, file: !52, line: 664, type: !311, flags: DIFlagTypePassByValue)
!833 = !DILocation(line: 664, column: 17, scope: !829)
!834 = !DILocalVariable(name: "value", arg: 3, scope: !829, file: !52, line: 671, type: !804, flags: DIFlagTypePassByValue)
!835 = !DILocation(line: 671, column: 17, scope: !829)
!836 = !DILocalVariable(name: "this", arg: 1, scope: !829, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!837 = !DILocation(line: 662, column: 23, scope: !829)
!838 = !DILocalVariable(name: "valueStartIndex", scope: !829, file: !52, line: 667, type: !32)
!839 = !DILocation(line: 667, column: 17, scope: !829)
!840 = !DILocalVariable(name: "valueEndIndex", scope: !829, file: !52, line: 668, type: !32)
!841 = !DILocation(line: 668, column: 17, scope: !829)
!842 = !DILocalVariable(name: "TryParse", scope: !829, file: !52, line: 662, type: !77)
!843 = !DILocation(line: 674, column: 13, scope: !829)
!844 = !DILocation(line: 676, column: 13, scope: !829)
!845 = !DILocation(line: 678, column: 19, scope: !829)
!846 = !DILocation(line: 680, column: 13, scope: !829)
!847 = !DILocation(line: 677, column: 17, scope: !829)
!848 = !DILocation(line: 682, column: 19, scope: !829)
!849 = !DILocation(line: 684, column: 19, scope: !829)
!850 = !DILocation(line: 681, column: 17, scope: !829)
!851 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@STRING@key?O@V@UInt64@value", scope: !51, file: !52, line: 686, type: !852, scopeLine: 686, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!852 = !DISubroutineType(types: !853)
!853 = !{!77, !204, !214, !854}
!854 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !855, size: 64, align: 64, dwarfAddressSpace: 0)
!855 = !DIDerivedType(tag: DW_TAG_typedef, name: "ULINT", baseType: !856, align: 64)
!856 = !DIBasicType(name: "UInt64", size: 64, encoding: DW_ATE_unsigned)
!857 = !DILocalVariable(name: "key", arg: 2, scope: !851, file: !52, line: 688, type: !66, flags: DIFlagTypePassByValue)
!858 = !DILocation(line: 688, column: 17, scope: !851)
!859 = !DILocalVariable(name: "value", arg: 3, scope: !851, file: !52, line: 696, type: !854, flags: DIFlagTypePassByValue)
!860 = !DILocation(line: 696, column: 17, scope: !851)
!861 = !DILocalVariable(name: "this", arg: 1, scope: !851, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!862 = !DILocation(line: 686, column: 23, scope: !851)
!863 = !DILocalVariable(name: "keyArray", scope: !851, file: !52, line: 691, type: !472)
!864 = !DILocation(line: 691, column: 17, scope: !851)
!865 = !DILocalVariable(name: "valueStartIndex", scope: !851, file: !52, line: 692, type: !32)
!866 = !DILocation(line: 692, column: 17, scope: !851)
!867 = !DILocalVariable(name: "valueEndIndex", scope: !851, file: !52, line: 693, type: !32)
!868 = !DILocation(line: 693, column: 17, scope: !851)
!869 = !DILocalVariable(name: "TryParse", scope: !851, file: !52, line: 686, type: !77)
!870 = !DILocation(line: 699, column: 13, scope: !851)
!871 = !DILocation(line: 701, column: 13, scope: !851)
!872 = !DILocation(line: 703, column: 13, scope: !851)
!873 = !DILocation(line: 705, column: 19, scope: !851)
!874 = !DILocation(line: 707, column: 13, scope: !851)
!875 = !DILocation(line: 704, column: 17, scope: !851)
!876 = !DILocation(line: 709, column: 19, scope: !851)
!877 = !DILocation(line: 711, column: 19, scope: !851)
!878 = !DILocation(line: 708, column: 17, scope: !851)
!879 = distinct !DISubprogram(name: "TryParse", linkageName: "Simatic.Ax.Json.Deserializer.TryParse$I@R@Simatic.Ax.Json.Deserializer@this?I@V@ARRAY [*] OF STRING@keyArray?O@V@UInt64@value", scope: !51, file: !52, line: 713, type: !880, scopeLine: 713, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!880 = !DISubroutineType(types: !881)
!881 = !{!77, !204, !311, !854}
!882 = !DILocalVariable(name: "keyArray", arg: 2, scope: !879, file: !52, line: 715, type: !311, flags: DIFlagTypePassByValue)
!883 = !DILocation(line: 715, column: 17, scope: !879)
!884 = !DILocalVariable(name: "value", arg: 3, scope: !879, file: !52, line: 722, type: !854, flags: DIFlagTypePassByValue)
!885 = !DILocation(line: 722, column: 17, scope: !879)
!886 = !DILocalVariable(name: "this", arg: 1, scope: !879, type: !204, flags: DIFlagArtificial | DIFlagObjectPointer)
!887 = !DILocation(line: 713, column: 23, scope: !879)
!888 = !DILocalVariable(name: "valueStartIndex", scope: !879, file: !52, line: 718, type: !32)
!889 = !DILocation(line: 718, column: 17, scope: !879)
!890 = !DILocalVariable(name: "valueEndIndex", scope: !879, file: !52, line: 719, type: !32)
!891 = !DILocation(line: 719, column: 17, scope: !879)
!892 = !DILocalVariable(name: "TryParse", scope: !879, file: !52, line: 713, type: !77)
!893 = !DILocation(line: 725, column: 13, scope: !879)
!894 = !DILocation(line: 727, column: 13, scope: !879)
!895 = !DILocation(line: 729, column: 19, scope: !879)
!896 = !DILocation(line: 731, column: 13, scope: !879)
!897 = !DILocation(line: 728, column: 17, scope: !879)
!898 = !DILocation(line: 733, column: 19, scope: !879)
!899 = !DILocation(line: 735, column: 19, scope: !879)
!900 = !DILocation(line: 732, column: 17, scope: !879)
!901 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonDocument.ToString$I@R@Simatic.Ax.Json.JsonDocument@this", scope: !903, file: !902, line: 17, type: !916, scopeLine: 17, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!902 = !DIFile(filename: "JsonDocument.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Document")
!903 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "JsonDocument", scope: !13, file: !902, line: 4, size: 8384, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !904, vtableHolder: !903)
!904 = !{!905, !906, !907, !910, !911, !913, !914, !915}
!905 = !DIDerivedType(tag: DW_TAG_member, name: "$cd", scope: !903, file: !902, baseType: null, size: 64, align: 64, flags: DIFlagArtificial)
!906 = !DIDerivedType(tag: DW_TAG_member, name: "buffer", scope: !903, file: !902, line: 6, baseType: !58, size: 8000, align: 8, offset: 64)
!907 = !DIDerivedType(tag: DW_TAG_member, name: "_firstElement", scope: !903, file: !902, line: 9, baseType: !908, size: 64, align: 64, offset: 8064)
!908 = !DIDerivedType(tag: DW_TAG_typedef, name: "IJsonElementMuteable", scope: !13, baseType: !909, align: 64)
!909 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: null, size: 64, align: 64, dwarfAddressSpace: 0)
!910 = !DIDerivedType(tag: DW_TAG_member, name: "_lastElement", scope: !903, file: !902, line: 10, baseType: !908, size: 64, align: 64, offset: 8128)
!911 = !DIDerivedType(tag: DW_TAG_member, name: "_rootElement", scope: !903, file: !902, line: 11, baseType: !912, size: 64, align: 64, offset: 8192)
!912 = !DIDerivedType(tag: DW_TAG_typedef, name: "IJsonElement", scope: !13, baseType: !909, align: 64)
!913 = !DIDerivedType(tag: DW_TAG_member, name: "_lentgh", scope: !903, file: !902, line: 12, baseType: !74, size: 32, align: 32, offset: 8256)
!914 = !DIDerivedType(tag: DW_TAG_member, name: "_bufLowerBound", scope: !903, file: !902, line: 13, baseType: !74, size: 32, align: 32, offset: 8288)
!915 = !DIDerivedType(tag: DW_TAG_member, name: "_bufIndex", scope: !903, file: !902, line: 14, baseType: !74, size: 32, align: 32, offset: 8320)
!916 = !DISubroutineType(types: !917)
!917 = !{!66, !918}
!918 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !903, size: 64, align: 64, dwarfAddressSpace: 0)
!919 = !DILocalVariable(name: "this", arg: 1, scope: !901, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!920 = !DILocation(line: 17, column: 23, scope: !901)
!921 = !DILocalVariable(name: "_str", scope: !901, file: !902, line: 19, type: !66)
!922 = !DILocation(line: 19, column: 17, scope: !901)
!923 = !DILocalVariable(name: "_to", scope: !901, file: !902, line: 20, type: !908)
!924 = !DILocation(line: 20, column: 17, scope: !901)
!925 = !DILocalVariable(name: "_elem", scope: !901, file: !902, line: 21, type: !912)
!926 = !DILocation(line: 21, column: 17, scope: !901)
!927 = !DILocalVariable(name: "ToString", scope: !901, file: !902, line: 17, type: !66)
!928 = !DILocation(line: 24, column: 13, scope: !901)
!929 = !DILocation(line: 25, column: 13, scope: !901)
!930 = !DILocation(line: 26, column: 13, scope: !901)
!931 = !DILocation(line: 27, column: 13, scope: !901)
!932 = !DILocation(line: 28, column: 17, scope: !901)
!933 = !DILocation(line: 29, column: 17, scope: !901)
!934 = !DILocation(line: 30, column: 17, scope: !901)
!935 = !DILocation(line: 31, column: 17, scope: !901)
!936 = !DILocation(line: 34, column: 22, scope: !901)
!937 = !DILocation(line: 35, column: 13, scope: !901)
!938 = !DILocation(line: 36, column: 13, scope: !901)
!939 = !DILocation(line: 37, column: 19, scope: !901)
!940 = !DILocation(line: 33, column: 23, scope: !901)
!941 = !DILocation(line: 32, column: 21, scope: !901)
!942 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.JsonDocument.Serialize$I@R@Simatic.Ax.Json.JsonDocument@this?I@R@ARRAY [*] OF CHAR@buf", scope: !903, file: !902, line: 39, type: !943, scopeLine: 39, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!943 = !DISubroutineType(types: !944)
!944 = !{!77, !918, !945}
!945 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !214, size: 64, align: 64, dwarfAddressSpace: 0)
!946 = !DILocalVariable(name: "buf", arg: 2, scope: !942, file: !902, line: 41, type: !945, flags: DIFlagTypePassByReference)
!947 = !DILocation(line: 41, column: 17, scope: !942)
!948 = !DILocalVariable(name: "this", arg: 1, scope: !942, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!949 = !DILocation(line: 39, column: 23, scope: !942)
!950 = !DILocalVariable(name: "_to", scope: !942, file: !902, line: 44, type: !908)
!951 = !DILocation(line: 44, column: 17, scope: !942)
!952 = !DILocalVariable(name: "_elem", scope: !942, file: !902, line: 45, type: !912)
!953 = !DILocation(line: 45, column: 17, scope: !942)
!954 = !DILocalVariable(name: "Serialize", scope: !942, file: !902, line: 39, type: !77)
!955 = !DILocation(line: 47, column: 13, scope: !942)
!956 = !DILocation(line: 48, column: 13, scope: !942)
!957 = !DILocation(line: 49, column: 13, scope: !942)
!958 = !DILocation(line: 51, column: 13, scope: !942)
!959 = !DILocation(line: 52, column: 13, scope: !942)
!960 = !DILocation(line: 53, column: 13, scope: !942)
!961 = !DILocation(line: 54, column: 17, scope: !942)
!962 = !DILocation(line: 55, column: 17, scope: !942)
!963 = !DILocation(line: 56, column: 17, scope: !942)
!964 = !DILocation(line: 57, column: 17, scope: !942)
!965 = !DILocation(line: 60, column: 22, scope: !942)
!966 = !DILocation(line: 61, column: 13, scope: !942)
!967 = !DILocation(line: 62, column: 13, scope: !942)
!968 = !DILocation(line: 63, column: 19, scope: !942)
!969 = !DILocation(line: 59, column: 23, scope: !942)
!970 = !DILocation(line: 58, column: 21, scope: !942)
!971 = distinct !DISubprogram(name: "AddChar", linkageName: "Simatic.Ax.Json.JsonDocument.AddChar$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@Char@c", scope: !903, file: !902, line: 65, type: !972, scopeLine: 65, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!972 = !DISubroutineType(types: !973)
!973 = !{!77, !918, !60}
!974 = !DILocalVariable(name: "c", arg: 2, scope: !971, file: !902, line: 67, type: !60, flags: DIFlagTypePassByValue)
!975 = !DILocation(line: 67, column: 17, scope: !971)
!976 = !DILocalVariable(name: "this", arg: 1, scope: !971, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!977 = !DILocation(line: 65, column: 23, scope: !971)
!978 = !DILocalVariable(name: "AddChar", scope: !971, file: !902, line: 65, type: !77)
!979 = !DILocation(line: 69, column: 13, scope: !971)
!980 = !DILocation(line: 70, column: 13, scope: !971)
!981 = !DILocation(line: 71, column: 13, scope: !971)
!982 = !DILocation(line: 72, column: 13, scope: !971)
!983 = !DILocation(line: 73, column: 19, scope: !971)
!984 = distinct !DISubprogram(name: "AddString", linkageName: "Simatic.Ax.Json.JsonDocument.AddString$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@STRING@s", scope: !903, file: !902, line: 75, type: !985, scopeLine: 75, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!985 = !DISubroutineType(types: !986)
!986 = !{!77, !918, !214}
!987 = !DILocalVariable(name: "s", arg: 2, scope: !984, file: !902, line: 77, type: !66, flags: DIFlagTypePassByValue)
!988 = !DILocation(line: 77, column: 17, scope: !984)
!989 = !DILocalVariable(name: "this", arg: 1, scope: !984, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!990 = !DILocation(line: 75, column: 23, scope: !984)
!991 = !DILocalVariable(name: "i", scope: !984, file: !902, line: 80, type: !32)
!992 = !DILocation(line: 80, column: 17, scope: !984)
!993 = !DILocalVariable(name: "AddString", scope: !984, file: !902, line: 75, type: !77)
!994 = !DILocation(line: 82, column: 27, scope: !984)
!995 = !DILocation(line: 82, column: 17, scope: !984)
!996 = !DILocation(line: 82, column: 13, scope: !984)
!997 = !DILocation(line: 86, column: 20, scope: !984)
!998 = !DILocation(line: 87, column: 13, scope: !984)
!999 = !DILocation(line: 88, column: 19, scope: !984)
!1000 = !DILocation(line: 83, column: 17, scope: !984)
!1001 = !DILocation(line: 84, column: 17, scope: !984)
!1002 = !DILocation(line: 85, column: 17, scope: !984)
!1003 = distinct !DISubprogram(name: "GetLength", linkageName: "Simatic.Ax.Json.JsonDocument.GetLength$I@R@Simatic.Ax.Json.JsonDocument@this", scope: !903, file: !902, line: 90, type: !1004, scopeLine: 90, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1004 = !DISubroutineType(types: !1005)
!1005 = !{!74, !918}
!1006 = !DILocalVariable(name: "this", arg: 1, scope: !1003, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!1007 = !DILocation(line: 90, column: 23, scope: !1003)
!1008 = !DILocalVariable(name: "GetLength", scope: !1003, file: !902, line: 90, type: !74)
!1009 = !DILocation(line: 91, column: 13, scope: !1003)
!1010 = !DILocation(line: 92, column: 19, scope: !1003)
!1011 = distinct !DISubprogram(name: "GetRootElement", linkageName: "Simatic.Ax.Json.JsonDocument.GetRootElement$I@R@Simatic.Ax.Json.JsonDocument@this", scope: !903, file: !902, line: 95, type: !1012, scopeLine: 95, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1012 = !DISubroutineType(types: !1013)
!1013 = !{!912, !918}
!1014 = !DILocalVariable(name: "this", arg: 1, scope: !1011, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!1015 = !DILocation(line: 95, column: 23, scope: !1011)
!1016 = !DILocalVariable(name: "GetRootElement", scope: !1011, file: !902, line: 95, type: !912)
!1017 = !DILocation(line: 96, column: 13, scope: !1011)
!1018 = !DILocation(line: 97, column: 19, scope: !1011)
!1019 = distinct !DISubprogram(name: "AddElement", linkageName: "Simatic.Ax.Json.JsonDocument.AddElement$I@R@Simatic.Ax.Json.JsonDocument@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: !903, file: !902, line: 99, type: !1020, scopeLine: 99, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1020 = !DISubroutineType(types: !1021)
!1021 = !{null, !918, !912}
!1022 = !DILocalVariable(name: "elem", arg: 2, scope: !1019, file: !902, line: 101, type: !912, flags: DIFlagTypePassByValue)
!1023 = !DILocation(line: 101, column: 17, scope: !1019)
!1024 = !DILocalVariable(name: "this", arg: 1, scope: !1019, type: !918, flags: DIFlagArtificial | DIFlagObjectPointer)
!1025 = !DILocation(line: 99, column: 23, scope: !1019)
!1026 = !DILocalVariable(name: "_elemMuted", scope: !1019, file: !902, line: 104, type: !908)
!1027 = !DILocation(line: 104, column: 17, scope: !1019)
!1028 = !DILocation(line: 106, column: 13, scope: !1019)
!1029 = !DILocation(line: 107, column: 13, scope: !1019)
!1030 = !DILocation(line: 112, column: 17, scope: !1019)
!1031 = !DILocation(line: 113, column: 17, scope: !1019)
!1032 = !DILocation(line: 114, column: 17, scope: !1019)
!1033 = !DILocation(line: 115, column: 19, scope: !1019)
!1034 = !DILocation(line: 117, column: 19, scope: !1019)
!1035 = !DILocation(line: 108, column: 17, scope: !1019)
!1036 = !DILocation(line: 109, column: 17, scope: !1019)
!1037 = !DILocation(line: 110, column: 17, scope: !1019)
!1038 = distinct !DISubprogram(name: "ToStringHelper", linkageName: "Simatic.Ax.Json.AbstractJsonElement.ToStringHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@STRING@valueAsString", scope: !1040, file: !1039, line: 23, type: !1047, scopeLine: 23, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1039 = !DIFile(filename: "AbstractJsonElement.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements")
!1040 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "AbstractJsonElement", scope: !13, file: !1039, line: 5, size: 2368, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1041, vtableHolder: !1040)
!1041 = !{!1042, !1043, !1044, !1045, !1046}
!1042 = !DIDerivedType(tag: DW_TAG_member, name: "$cd", scope: !1040, file: !1039, baseType: null, size: 64, align: 64, flags: DIFlagArtificial)
!1043 = !DIDerivedType(tag: DW_TAG_member, name: "$iDesc_Simatic.Ax.Json.IJsonElementMuteable", scope: !1040, file: !1039, baseType: null, size: 64, align: 64, offset: 64, flags: DIFlagArtificial)
!1044 = !DIDerivedType(tag: DW_TAG_member, name: "$iDesc_Simatic.Ax.Json.IJsonElement", scope: !1040, file: !1039, baseType: null, size: 64, align: 64, offset: 128, flags: DIFlagArtificial)
!1045 = !DIDerivedType(tag: DW_TAG_member, name: "Key", scope: !1040, file: !1039, line: 7, baseType: !66, size: 2056, align: 8, offset: 192)
!1046 = !DIDerivedType(tag: DW_TAG_member, name: "_next", scope: !1040, file: !1039, line: 11, baseType: !908, size: 64, align: 64, offset: 2304)
!1047 = !DISubroutineType(types: !1048)
!1048 = !{!66, !1049, !214}
!1049 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1040, size: 64, align: 64, dwarfAddressSpace: 0)
!1050 = !DILocalVariable(name: "valueAsString", arg: 2, scope: !1038, file: !1039, line: 25, type: !66, flags: DIFlagTypePassByValue)
!1051 = !DILocation(line: 25, column: 17, scope: !1038)
!1052 = !DILocalVariable(name: "this", arg: 1, scope: !1038, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1053 = !DILocation(line: 23, column: 26, scope: !1038)
!1054 = !DILocalVariable(name: "_str", scope: !1038, file: !1039, line: 28, type: !66)
!1055 = !DILocation(line: 28, column: 17, scope: !1038)
!1056 = !DILocalVariable(name: "ToStringHelper", scope: !1038, file: !1039, line: 23, type: !66)
!1057 = !DILocation(line: 30, column: 13, scope: !1038)
!1058 = !DILocation(line: 31, column: 13, scope: !1038)
!1059 = !DILocation(line: 32, column: 13, scope: !1038)
!1060 = !DILocation(line: 33, column: 19, scope: !1038)
!1061 = distinct !DISubprogram(name: "SerializeHelper", linkageName: "Simatic.Ax.Json.AbstractJsonElement.SerializeHelper$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc?I@V@STRING@valueAsString", scope: !1040, file: !1039, line: 35, type: !1062, scopeLine: 35, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1062 = !DISubroutineType(types: !1063)
!1063 = !{!74, !1049, !1064, !214}
!1064 = !DIDerivedType(tag: DW_TAG_typedef, name: "REF_TO Simatic.Ax.Json.JsonDocument", baseType: !918, align: 64)
!1065 = !DILocalVariable(name: "doc", arg: 2, scope: !1061, file: !1039, line: 37, type: !1064, flags: DIFlagTypePassByValue)
!1066 = !DILocation(line: 37, column: 17, scope: !1061)
!1067 = !DILocalVariable(name: "valueAsString", arg: 3, scope: !1061, file: !1039, line: 38, type: !66, flags: DIFlagTypePassByValue)
!1068 = !DILocation(line: 38, column: 17, scope: !1061)
!1069 = !DILocalVariable(name: "this", arg: 1, scope: !1061, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1070 = !DILocation(line: 35, column: 23, scope: !1061)
!1071 = !DILocalVariable(name: "_i", scope: !1061, file: !1039, line: 41, type: !74)
!1072 = !DILocation(line: 41, column: 17, scope: !1061)
!1073 = !DILocalVariable(name: "SerializeHelper", scope: !1061, file: !1039, line: 35, type: !74)
!1074 = !DILocation(line: 43, column: 28, scope: !1061)
!1075 = !DILocation(line: 43, column: 17, scope: !1061)
!1076 = !DILocation(line: 43, column: 13, scope: !1061)
!1077 = !DILocation(line: 45, column: 20, scope: !1061)
!1078 = !DILocation(line: 46, column: 19, scope: !1061)
!1079 = !DILocation(line: 44, column: 17, scope: !1061)
!1080 = distinct !DISubprogram(name: "HasNext", linkageName: "Simatic.Ax.Json.AbstractJsonElement.HasNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this", scope: !1040, file: !1039, line: 48, type: !1081, scopeLine: 48, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1081 = !DISubroutineType(types: !1082)
!1082 = !{!77, !1049}
!1083 = !DILocalVariable(name: "this", arg: 1, scope: !1080, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1084 = !DILocation(line: 48, column: 23, scope: !1080)
!1085 = !DILocalVariable(name: "HasNext", scope: !1080, file: !1039, line: 48, type: !77)
!1086 = !DILocation(line: 49, column: 13, scope: !1080)
!1087 = !DILocation(line: 50, column: 19, scope: !1080)
!1088 = distinct !DISubprogram(name: "GetNext", linkageName: "Simatic.Ax.Json.AbstractJsonElement.GetNext$I@R@Simatic.Ax.Json.AbstractJsonElement@this", scope: !1040, file: !1039, line: 52, type: !1089, scopeLine: 52, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1089 = !DISubroutineType(types: !1090)
!1090 = !{!908, !1049}
!1091 = !DILocalVariable(name: "this", arg: 1, scope: !1088, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1092 = !DILocation(line: 52, column: 23, scope: !1088)
!1093 = !DILocalVariable(name: "GetNext", scope: !1088, file: !1039, line: 52, type: !908)
!1094 = !DILocation(line: 53, column: 13, scope: !1088)
!1095 = !DILocation(line: 54, column: 19, scope: !1088)
!1096 = distinct !DISubprogram(name: "AddElement", linkageName: "Simatic.Ax.Json.AbstractJsonElement.AddElement$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: !1040, file: !1039, line: 56, type: !1097, scopeLine: 56, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1097 = !DISubroutineType(types: !1098)
!1098 = !{null, !1049, !912}
!1099 = !DILocalVariable(name: "elem", arg: 2, scope: !1096, file: !1039, line: 58, type: !912, flags: DIFlagTypePassByValue)
!1100 = !DILocation(line: 58, column: 17, scope: !1096)
!1101 = !DILocalVariable(name: "this", arg: 1, scope: !1096, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1102 = !DILocation(line: 56, column: 23, scope: !1096)
!1103 = !DILocation(line: 60, column: 13, scope: !1096)
!1104 = !DILocation(line: 61, column: 19, scope: !1096)
!1105 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.AbstractJsonElement.ToString$I@R@Simatic.Ax.Json.AbstractJsonElement@this", scope: !1040, file: !1039, line: 14, type: !1106, scopeLine: 14, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1106 = !DISubroutineType(types: !1107)
!1107 = !{!66, !1049}
!1108 = !DILocalVariable(name: "this", arg: 1, scope: !1105, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1109 = !DILocation(line: 14, column: 32, scope: !1105)
!1110 = !DILocalVariable(name: "ToString", scope: !1105, file: !1039, line: 14, type: !66)
!1111 = !DILocation(line: 15, column: 19, scope: !1105)
!1112 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.AbstractJsonElement.Serialize$I@R@Simatic.Ax.Json.AbstractJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: !1040, file: !1039, line: 17, type: !1113, scopeLine: 17, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1113 = !DISubroutineType(types: !1114)
!1114 = !{!77, !1049, !1064}
!1115 = !DILocalVariable(name: "doc", arg: 2, scope: !1112, file: !1039, line: 19, type: !1064, flags: DIFlagTypePassByValue)
!1116 = !DILocation(line: 19, column: 17, scope: !1112)
!1117 = !DILocalVariable(name: "this", arg: 1, scope: !1112, type: !1049, flags: DIFlagArtificial | DIFlagObjectPointer)
!1118 = !DILocation(line: 17, column: 32, scope: !1112)
!1119 = !DILocalVariable(name: "Serialize", scope: !1112, file: !1039, line: 17, type: !77)
!1120 = !DILocation(line: 21, column: 19, scope: !1112)
!1121 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonBoolean.ToString$I@R@Simatic.Ax.Json.JsonBoolean@this", scope: !1123, file: !1122, line: 10, type: !1131, scopeLine: 10, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1122 = !DIFile(filename: "JsonBoolean.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Boolean")
!1123 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonBoolean", scope: !13, file: !1122, line: 2, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1128, vtableHolder: !1040)
!1124 = !DICompositeType(tag: DW_TAG_structure_type, name: "BaseJsonNumber", scope: !13, file: !1125, line: 4, baseType: !1040, size: 2368, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1126, vtableHolder: !1040)
!1125 = !DIFile(filename: "BaseJsonNumber.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1126 = !{!1127}
!1127 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1124, baseType: !1040, flags: DIFlagPublic, extraData: i32 0)
!1128 = !{!1129, !1130}
!1129 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1123, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1130 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1123, file: !1122, line: 4, baseType: !77, size: 1, align: 8, offset: 2368)
!1131 = !DISubroutineType(types: !1132)
!1132 = !{!66, !1133}
!1133 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1123, size: 64, align: 64, dwarfAddressSpace: 0)
!1134 = !DILocalVariable(name: "this", arg: 1, scope: !1121, type: !1133, flags: DIFlagArtificial | DIFlagObjectPointer)
!1135 = !DILocation(line: 10, column: 32, scope: !1121)
!1136 = !DILocalVariable(name: "ToString", scope: !1121, file: !1122, line: 10, type: !66)
!1137 = !DILocation(line: 11, column: 13, scope: !1121)
!1138 = !DILocation(line: 14, column: 17, scope: !1121)
!1139 = !DILocation(line: 15, column: 19, scope: !1121)
!1140 = !DILocation(line: 16, column: 19, scope: !1121)
!1141 = !DILocation(line: 12, column: 17, scope: !1121)
!1142 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.JsonBoolean.Serialize$I@R@Simatic.Ax.Json.JsonBoolean@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: !1123, file: !1122, line: 18, type: !1143, scopeLine: 18, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1143 = !DISubroutineType(types: !1144)
!1144 = !{!77, !1133, !1064}
!1145 = !DILocalVariable(name: "doc", arg: 2, scope: !1142, file: !1122, line: 20, type: !1064, flags: DIFlagTypePassByValue)
!1146 = !DILocation(line: 20, column: 17, scope: !1142)
!1147 = !DILocalVariable(name: "this", arg: 1, scope: !1142, type: !1133, flags: DIFlagArtificial | DIFlagObjectPointer)
!1148 = !DILocation(line: 18, column: 32, scope: !1142)
!1149 = !DILocalVariable(name: "Serialize", scope: !1142, file: !1122, line: 18, type: !77)
!1150 = !DILocation(line: 22, column: 13, scope: !1142)
!1151 = !DILocation(line: 23, column: 13, scope: !1142)
!1152 = !DILocation(line: 24, column: 19, scope: !1142)
!1153 = distinct !DISubprogram(name: "ToStringHelper", linkageName: "Simatic.Ax.Json.BaseJsonNumber.ToStringHelper$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@STRING@valueAsString", scope: !1124, file: !1125, line: 6, type: !1154, scopeLine: 6, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1154 = !DISubroutineType(types: !1155)
!1155 = !{!66, !1156, !214}
!1156 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1124, size: 64, align: 64, dwarfAddressSpace: 0)
!1157 = !DILocalVariable(name: "valueAsString", arg: 2, scope: !1153, file: !1125, line: 8, type: !66, flags: DIFlagTypePassByValue)
!1158 = !DILocation(line: 8, column: 17, scope: !1153)
!1159 = !DILocalVariable(name: "this", arg: 1, scope: !1153, type: !1156, flags: DIFlagArtificial | DIFlagObjectPointer)
!1160 = !DILocation(line: 6, column: 35, scope: !1153)
!1161 = !DILocalVariable(name: "_str", scope: !1153, file: !1125, line: 11, type: !66)
!1162 = !DILocation(line: 11, column: 17, scope: !1153)
!1163 = !DILocalVariable(name: "ToStringHelper", scope: !1153, file: !1125, line: 6, type: !66)
!1164 = !DILocation(line: 13, column: 13, scope: !1153)
!1165 = !DILocation(line: 14, column: 13, scope: !1153)
!1166 = !DILocation(line: 15, column: 19, scope: !1153)
!1167 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.BaseJsonNumber.ToString$I@R@Simatic.Ax.Json.BaseJsonNumber@this", scope: !1124, file: !1125, line: 17, type: !1168, scopeLine: 17, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1168 = !DISubroutineType(types: !1169)
!1169 = !{!66, !1156}
!1170 = !DILocalVariable(name: "this", arg: 1, scope: !1167, type: !1156, flags: DIFlagArtificial | DIFlagObjectPointer)
!1171 = !DILocation(line: 17, column: 32, scope: !1167)
!1172 = !DILocalVariable(name: "ToString", scope: !1167, file: !1125, line: 17, type: !66)
!1173 = !DILocation(line: 19, column: 19, scope: !1167)
!1174 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.BaseJsonNumber.Serialize$I@R@Simatic.Ax.Json.BaseJsonNumber@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: !1124, file: !1125, line: 21, type: !1175, scopeLine: 21, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1175 = !DISubroutineType(types: !1176)
!1176 = !{!77, !1156, !1064}
!1177 = !DILocalVariable(name: "doc", arg: 2, scope: !1174, file: !1125, line: 23, type: !1064, flags: DIFlagTypePassByValue)
!1178 = !DILocation(line: 23, column: 17, scope: !1174)
!1179 = !DILocalVariable(name: "this", arg: 1, scope: !1174, type: !1156, flags: DIFlagArtificial | DIFlagObjectPointer)
!1180 = !DILocation(line: 21, column: 32, scope: !1174)
!1181 = !DILocalVariable(name: "Serialize", scope: !1174, file: !1125, line: 21, type: !77)
!1182 = !DILocation(line: 25, column: 13, scope: !1174)
!1183 = !DILocation(line: 26, column: 13, scope: !1174)
!1184 = !DILocation(line: 27, column: 19, scope: !1174)
!1185 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonDInt.ToString$I@R@Simatic.Ax.Json.JsonDInt@this", scope: !1187, file: !1186, line: 9, type: !1191, scopeLine: 9, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1186 = !DIFile(filename: "JsonDInt.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1187 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonDInt", scope: !13, file: !1186, line: 4, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1188, vtableHolder: !1040)
!1188 = !{!1189, !1190}
!1189 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1187, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1190 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1187, file: !1186, line: 6, baseType: !74, size: 32, align: 32, offset: 2368)
!1191 = !DISubroutineType(types: !1192)
!1192 = !{!66, !1193}
!1193 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1187, size: 64, align: 64, dwarfAddressSpace: 0)
!1194 = !DILocalVariable(name: "this", arg: 1, scope: !1185, type: !1193, flags: DIFlagArtificial | DIFlagObjectPointer)
!1195 = !DILocation(line: 9, column: 32, scope: !1185)
!1196 = !DILocalVariable(name: "ToString", scope: !1185, file: !1186, line: 9, type: !66)
!1197 = !DILocation(line: 10, column: 13, scope: !1185)
!1198 = !DILocation(line: 11, column: 19, scope: !1185)
!1199 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonInt.ToString$I@R@Simatic.Ax.Json.JsonInt@this", scope: !1201, file: !1200, line: 10, type: !1205, scopeLine: 10, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1200 = !DIFile(filename: "JsonInt.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1201 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonInt", scope: !13, file: !1200, line: 5, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1202, vtableHolder: !1040)
!1202 = !{!1203, !1204}
!1203 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1201, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1204 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1201, file: !1200, line: 7, baseType: !32, size: 16, align: 16, offset: 2368)
!1205 = !DISubroutineType(types: !1206)
!1206 = !{!66, !1207}
!1207 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1201, size: 64, align: 64, dwarfAddressSpace: 0)
!1208 = !DILocalVariable(name: "this", arg: 1, scope: !1199, type: !1207, flags: DIFlagArtificial | DIFlagObjectPointer)
!1209 = !DILocation(line: 10, column: 32, scope: !1199)
!1210 = !DILocalVariable(name: "ToString", scope: !1199, file: !1200, line: 10, type: !66)
!1211 = !DILocation(line: 11, column: 13, scope: !1199)
!1212 = !DILocation(line: 12, column: 19, scope: !1199)
!1213 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonLInt.ToString$I@R@Simatic.Ax.Json.JsonLInt@this", scope: !1215, file: !1214, line: 9, type: !1219, scopeLine: 9, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1214 = !DIFile(filename: "JsonLInt.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1215 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonLInt", scope: !13, file: !1214, line: 4, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1216, vtableHolder: !1040)
!1216 = !{!1217, !1218}
!1217 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1215, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1218 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1215, file: !1214, line: 6, baseType: !563, size: 64, align: 64, offset: 2368)
!1219 = !DISubroutineType(types: !1220)
!1220 = !{!66, !1221}
!1221 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1215, size: 64, align: 64, dwarfAddressSpace: 0)
!1222 = !DILocalVariable(name: "this", arg: 1, scope: !1213, type: !1221, flags: DIFlagArtificial | DIFlagObjectPointer)
!1223 = !DILocation(line: 9, column: 32, scope: !1213)
!1224 = !DILocalVariable(name: "ToString", scope: !1213, file: !1214, line: 9, type: !66)
!1225 = !DILocation(line: 10, column: 13, scope: !1213)
!1226 = !DILocation(line: 11, column: 19, scope: !1213)
!1227 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonUSInt.ToString$I@R@Simatic.Ax.Json.JsonUSInt@this", scope: !1229, file: !1228, line: 9, type: !1233, scopeLine: 9, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1228 = !DIFile(filename: "JsonSint.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1229 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonUSInt", scope: !13, file: !1228, line: 4, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1230, vtableHolder: !1040)
!1230 = !{!1231, !1232}
!1231 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1229, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1232 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1229, file: !1228, line: 6, baseType: !36, size: 8, align: 8, offset: 2368)
!1233 = !DISubroutineType(types: !1234)
!1234 = !{!66, !1235}
!1235 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1229, size: 64, align: 64, dwarfAddressSpace: 0)
!1236 = !DILocalVariable(name: "this", arg: 1, scope: !1227, type: !1235, flags: DIFlagArtificial | DIFlagObjectPointer)
!1237 = !DILocation(line: 9, column: 32, scope: !1227)
!1238 = !DILocalVariable(name: "ToString", scope: !1227, file: !1228, line: 9, type: !66)
!1239 = !DILocation(line: 10, column: 13, scope: !1227)
!1240 = !DILocation(line: 11, column: 19, scope: !1227)
!1241 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonSInt.ToString$I@R@Simatic.Ax.Json.JsonSInt@this", scope: !1243, file: !1242, line: 9, type: !1247, scopeLine: 9, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1242 = !DIFile(filename: "JsonUint.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Numbers")
!1243 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonSInt", scope: !13, file: !1242, line: 4, baseType: !1124, size: 2432, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1244, vtableHolder: !1040)
!1244 = !{!1245, !1246}
!1245 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1243, baseType: !1124, flags: DIFlagPublic, extraData: i32 0)
!1246 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1243, file: !1242, line: 6, baseType: !513, size: 8, align: 8, offset: 2368)
!1247 = !DISubroutineType(types: !1248)
!1248 = !{!66, !1249}
!1249 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1243, size: 64, align: 64, dwarfAddressSpace: 0)
!1250 = !DILocalVariable(name: "this", arg: 1, scope: !1241, type: !1249, flags: DIFlagArtificial | DIFlagObjectPointer)
!1251 = !DILocation(line: 9, column: 32, scope: !1241)
!1252 = !DILocalVariable(name: "ToString", scope: !1241, file: !1242, line: 9, type: !66)
!1253 = !DILocation(line: 10, column: 13, scope: !1241)
!1254 = !DILocation(line: 11, column: 19, scope: !1241)
!1255 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonObject.ToString$I@R@Simatic.Ax.Json.JsonObject@this", scope: !1257, file: !1256, line: 11, type: !1262, scopeLine: 11, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1256 = !DIFile(filename: "JsonObject.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Object")
!1257 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonObject", scope: !13, file: !1256, line: 4, baseType: !1040, size: 2496, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1258, vtableHolder: !1040)
!1258 = !{!1259, !1260, !1261}
!1259 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1257, baseType: !1040, flags: DIFlagPublic, extraData: i32 0)
!1260 = !DIDerivedType(tag: DW_TAG_member, name: "_lastElement", scope: !1257, file: !1256, line: 7, baseType: !908, size: 64, align: 64, offset: 2368)
!1261 = !DIDerivedType(tag: DW_TAG_member, name: "_firstElement", scope: !1257, file: !1256, line: 8, baseType: !908, size: 64, align: 64, offset: 2432)
!1262 = !DISubroutineType(types: !1263)
!1263 = !{!66, !1264}
!1264 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1257, size: 64, align: 64, dwarfAddressSpace: 0)
!1265 = !DILocalVariable(name: "this", arg: 1, scope: !1255, type: !1264, flags: DIFlagArtificial | DIFlagObjectPointer)
!1266 = !DILocation(line: 11, column: 32, scope: !1255)
!1267 = !DILocalVariable(name: "_str", scope: !1255, file: !1256, line: 13, type: !66)
!1268 = !DILocation(line: 13, column: 17, scope: !1255)
!1269 = !DILocalVariable(name: "_to", scope: !1255, file: !1256, line: 14, type: !908)
!1270 = !DILocation(line: 14, column: 17, scope: !1255)
!1271 = !DILocalVariable(name: "_elem", scope: !1255, file: !1256, line: 15, type: !912)
!1272 = !DILocation(line: 15, column: 17, scope: !1255)
!1273 = !DILocalVariable(name: "ToString", scope: !1255, file: !1256, line: 11, type: !66)
!1274 = !DILocation(line: 19, column: 13, scope: !1255)
!1275 = !DILocation(line: 21, column: 19, scope: !1255)
!1276 = !DILocation(line: 23, column: 13, scope: !1255)
!1277 = !DILocation(line: 25, column: 13, scope: !1255)
!1278 = !DILocation(line: 26, column: 13, scope: !1255)
!1279 = !DILocation(line: 20, column: 17, scope: !1255)
!1280 = !DILocation(line: 27, column: 13, scope: !1255)
!1281 = !DILocation(line: 28, column: 17, scope: !1255)
!1282 = !DILocation(line: 29, column: 17, scope: !1255)
!1283 = !DILocation(line: 30, column: 17, scope: !1255)
!1284 = !DILocation(line: 31, column: 17, scope: !1255)
!1285 = !DILocation(line: 34, column: 22, scope: !1255)
!1286 = !DILocation(line: 35, column: 13, scope: !1255)
!1287 = !DILocation(line: 36, column: 13, scope: !1255)
!1288 = !DILocation(line: 37, column: 19, scope: !1255)
!1289 = !DILocation(line: 33, column: 23, scope: !1255)
!1290 = !DILocation(line: 32, column: 21, scope: !1255)
!1291 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.JsonObject.Serialize$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: !1257, file: !1256, line: 39, type: !1292, scopeLine: 39, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1292 = !DISubroutineType(types: !1293)
!1293 = !{!77, !1264, !1064}
!1294 = !DILocalVariable(name: "doc", arg: 2, scope: !1291, file: !1256, line: 41, type: !1064, flags: DIFlagTypePassByValue)
!1295 = !DILocation(line: 41, column: 17, scope: !1291)
!1296 = !DILocalVariable(name: "this", arg: 1, scope: !1291, type: !1264, flags: DIFlagArtificial | DIFlagObjectPointer)
!1297 = !DILocation(line: 39, column: 32, scope: !1291)
!1298 = !DILocalVariable(name: "_str", scope: !1291, file: !1256, line: 44, type: !66)
!1299 = !DILocation(line: 44, column: 17, scope: !1291)
!1300 = !DILocalVariable(name: "_to", scope: !1291, file: !1256, line: 45, type: !908)
!1301 = !DILocation(line: 45, column: 17, scope: !1291)
!1302 = !DILocalVariable(name: "_elem", scope: !1291, file: !1256, line: 46, type: !912)
!1303 = !DILocation(line: 46, column: 17, scope: !1291)
!1304 = !DILocalVariable(name: "Serialize", scope: !1291, file: !1256, line: 39, type: !77)
!1305 = !DILocation(line: 49, column: 13, scope: !1291)
!1306 = !DILocation(line: 51, column: 13, scope: !1291)
!1307 = !DILocation(line: 55, column: 19, scope: !1291)
!1308 = !DILocation(line: 57, column: 13, scope: !1291)
!1309 = !DILocation(line: 60, column: 13, scope: !1291)
!1310 = !DILocation(line: 61, column: 13, scope: !1291)
!1311 = !DILocation(line: 53, column: 17, scope: !1291)
!1312 = !DILocation(line: 54, column: 17, scope: !1291)
!1313 = !DILocation(line: 62, column: 13, scope: !1291)
!1314 = !DILocation(line: 63, column: 17, scope: !1291)
!1315 = !DILocation(line: 64, column: 17, scope: !1291)
!1316 = !DILocation(line: 65, column: 17, scope: !1291)
!1317 = !DILocation(line: 66, column: 17, scope: !1291)
!1318 = !DILocation(line: 69, column: 22, scope: !1291)
!1319 = !DILocation(line: 70, column: 13, scope: !1291)
!1320 = !DILocation(line: 71, column: 13, scope: !1291)
!1321 = !DILocation(line: 72, column: 19, scope: !1291)
!1322 = !DILocation(line: 68, column: 23, scope: !1291)
!1323 = !DILocation(line: 67, column: 21, scope: !1291)
!1324 = distinct !DISubprogram(name: "AddElement", linkageName: "Simatic.Ax.Json.JsonObject.AddElement$I@R@Simatic.Ax.Json.JsonObject@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: !1257, file: !1256, line: 74, type: !1325, scopeLine: 74, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1325 = !DISubroutineType(types: !1326)
!1326 = !{null, !1264, !912}
!1327 = !DILocalVariable(name: "elem", arg: 2, scope: !1324, file: !1256, line: 76, type: !912, flags: DIFlagTypePassByValue)
!1328 = !DILocation(line: 76, column: 17, scope: !1324)
!1329 = !DILocalVariable(name: "this", arg: 1, scope: !1324, type: !1264, flags: DIFlagArtificial | DIFlagObjectPointer)
!1330 = !DILocation(line: 74, column: 32, scope: !1324)
!1331 = !DILocalVariable(name: "_elemMuted", scope: !1324, file: !1256, line: 79, type: !908)
!1332 = !DILocation(line: 79, column: 17, scope: !1324)
!1333 = !DILocation(line: 81, column: 13, scope: !1324)
!1334 = !DILocation(line: 86, column: 17, scope: !1324)
!1335 = !DILocation(line: 87, column: 17, scope: !1324)
!1336 = !DILocation(line: 88, column: 17, scope: !1324)
!1337 = !DILocation(line: 89, column: 19, scope: !1324)
!1338 = !DILocation(line: 91, column: 19, scope: !1324)
!1339 = !DILocation(line: 82, column: 17, scope: !1324)
!1340 = !DILocation(line: 83, column: 17, scope: !1324)
!1341 = !DILocation(line: 84, column: 17, scope: !1324)
!1342 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Json.JsonString.ToString$I@R@Simatic.Ax.Json.JsonString@this", scope: !1344, file: !1343, line: 12, type: !1348, scopeLine: 12, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1343 = !DIFile(filename: "JsonString.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\json\\src\\Elements\\Strings")
!1344 = !DICompositeType(tag: DW_TAG_structure_type, name: "JsonString", scope: !13, file: !1343, line: 4, baseType: !1040, size: 4480, align: 64, flags: DIFlagTypePassByReference | DIFlagNonTrivial, elements: !1345, vtableHolder: !1040)
!1345 = !{!1346, !1347}
!1346 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !1344, baseType: !1040, flags: DIFlagPublic, extraData: i32 0)
!1347 = !DIDerivedType(tag: DW_TAG_member, name: "Value", scope: !1344, file: !1343, line: 6, baseType: !66, size: 2056, align: 8, offset: 2368)
!1348 = !DISubroutineType(types: !1349)
!1349 = !{!66, !1350}
!1350 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !1344, size: 64, align: 64, dwarfAddressSpace: 0)
!1351 = !DILocalVariable(name: "this", arg: 1, scope: !1342, type: !1350, flags: DIFlagArtificial | DIFlagObjectPointer)
!1352 = !DILocation(line: 12, column: 32, scope: !1342)
!1353 = !DILocalVariable(name: "_S", scope: !1342, file: !1343, line: 14, type: !66)
!1354 = !DILocation(line: 14, column: 17, scope: !1342)
!1355 = !DILocalVariable(name: "ToString", scope: !1342, file: !1343, line: 12, type: !66)
!1356 = !DILocation(line: 16, column: 13, scope: !1342)
!1357 = !DILocation(line: 17, column: 13, scope: !1342)
!1358 = !DILocation(line: 18, column: 19, scope: !1342)
!1359 = distinct !DISubprogram(name: "Serialize", linkageName: "Simatic.Ax.Json.JsonString.Serialize$I@R@Simatic.Ax.Json.JsonString@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: !1344, file: !1343, line: 20, type: !1360, scopeLine: 20, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1360 = !DISubroutineType(types: !1361)
!1361 = !{!77, !1350, !1064}
!1362 = !DILocalVariable(name: "doc", arg: 2, scope: !1359, file: !1343, line: 22, type: !1064, flags: DIFlagTypePassByValue)
!1363 = !DILocation(line: 22, column: 17, scope: !1359)
!1364 = !DILocalVariable(name: "this", arg: 1, scope: !1359, type: !1350, flags: DIFlagArtificial | DIFlagObjectPointer)
!1365 = !DILocation(line: 20, column: 32, scope: !1359)
!1366 = !DILocalVariable(name: "_s", scope: !1359, file: !1343, line: 25, type: !66)
!1367 = !DILocation(line: 25, column: 17, scope: !1359)
!1368 = !DILocalVariable(name: "Serialize", scope: !1359, file: !1343, line: 20, type: !77)
!1369 = !DILocation(line: 27, column: 13, scope: !1359)
!1370 = !DILocation(line: 28, column: 13, scope: !1359)
!1371 = !DILocation(line: 30, column: 13, scope: !1359)
!1372 = !DILocation(line: 31, column: 19, scope: !1359)
!1373 = distinct !DISubprogram(name: "MyProgram", linkageName: "MyProgram", scope: null, file: !1374, line: 1, type: !1375, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1374 = !DIFile(filename: "MyProgram.st", directory: "d:\\workspace\\JSONShowcase\\JSONShowcase\\src")
!1375 = !DISubroutineType(types: !1376)
!1376 = !{null}
!1377 = !DILocation(line: 16, column: 12, scope: !1373)
!1378 = distinct !DISubprogram(name: "AnyIntToString", linkageName: "Simatic.Ax.Conversion.AnyIntToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !7, file: !1379, line: 5, type: !1380, scopeLine: 5, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1379 = !DIFile(filename: "AnyIntToString.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1380 = !DISubroutineType(types: !1381)
!1381 = !{!66, !563, !5}
!1382 = !DILocalVariable(name: "value", arg: 1, scope: !1378, file: !1379, line: 7, type: !563, flags: DIFlagTypePassByValue)
!1383 = !DILocation(line: 7, column: 13, scope: !1378)
!1384 = !DILocalVariable(name: "mode", arg: 2, scope: !1378, file: !1379, line: 8, type: !5, flags: DIFlagTypePassByValue)
!1385 = !DILocation(line: 8, column: 13, scope: !1378)
!1386 = !DILocalVariable(name: "_value", scope: !1378, file: !1379, line: 11, type: !563)
!1387 = !DILocation(line: 11, column: 13, scope: !1378)
!1388 = !DILocalVariable(name: "digit", scope: !1378, file: !1379, line: 12, type: !32)
!1389 = !DILocation(line: 12, column: 13, scope: !1378)
!1390 = !DILocalVariable(name: "c", scope: !1378, file: !1379, line: 13, type: !36)
!1391 = !DILocation(line: 13, column: 13, scope: !1378)
!1392 = !DILocalVariable(name: "i", scope: !1378, file: !1379, line: 14, type: !32)
!1393 = !DILocation(line: 14, column: 13, scope: !1378)
!1394 = !DILocalVariable(name: "digits", scope: !1378, file: !1379, line: 15, type: !32)
!1395 = !DILocation(line: 15, column: 13, scope: !1378)
!1396 = !DILocalVariable(name: "offset", scope: !1378, file: !1379, line: 16, type: !32)
!1397 = !DILocation(line: 16, column: 13, scope: !1378)
!1398 = !DILocalVariable(name: "AnyIntToString", scope: !1378, file: !1379, line: 5, type: !66)
!1399 = !DILocation(line: 5, column: 23, scope: !1378)
!1400 = !DILocation(line: 22, column: 9, scope: !1378)
!1401 = !DILocation(line: 19, column: 9, scope: !1378)
!1402 = !DILocation(line: 21, column: 9, scope: !1378)
!1403 = !DILocation(line: 24, column: 9, scope: !1378)
!1404 = !DILocation(line: 33, column: 13, scope: !1378)
!1405 = !DILocation(line: 28, column: 9, scope: !1378)
!1406 = !DILocation(line: 34, column: 15, scope: !1378)
!1407 = !DILocation(line: 36, column: 23, scope: !1378)
!1408 = !DILocation(line: 36, column: 13, scope: !1378)
!1409 = !DILocation(line: 36, column: 9, scope: !1378)
!1410 = !DILocation(line: 25, column: 13, scope: !1378)
!1411 = !DILocation(line: 26, column: 13, scope: !1378)
!1412 = !DILocation(line: 27, column: 13, scope: !1378)
!1413 = !DILocation(line: 29, column: 13, scope: !1378)
!1414 = !DILocation(line: 30, column: 13, scope: !1378)
!1415 = !DILocation(line: 31, column: 13, scope: !1378)
!1416 = !DILocation(line: 41, column: 16, scope: !1378)
!1417 = !DILocation(line: 42, column: 17, scope: !1378)
!1418 = !DILocation(line: 37, column: 13, scope: !1378)
!1419 = !DILocation(line: 38, column: 13, scope: !1378)
!1420 = !DILocation(line: 39, column: 13, scope: !1378)
!1421 = !DILocation(line: 40, column: 13, scope: !1378)
!1422 = distinct !DISubprogram(name: "ULintToString", linkageName: "Simatic.Ax.Conversion.ULintToString$I@V@UInt64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !7, file: !1379, line: 44, type: !1423, scopeLine: 44, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1423 = !DISubroutineType(types: !1424)
!1424 = !{!66, !855, !5}
!1425 = !DILocalVariable(name: "value", arg: 1, scope: !1422, file: !1379, line: 46, type: !855, flags: DIFlagTypePassByValue)
!1426 = !DILocation(line: 46, column: 13, scope: !1422)
!1427 = !DILocalVariable(name: "mode", arg: 2, scope: !1422, file: !1379, line: 47, type: !5, flags: DIFlagTypePassByValue)
!1428 = !DILocation(line: 47, column: 13, scope: !1422)
!1429 = !DILocalVariable(name: "_value", scope: !1422, file: !1379, line: 50, type: !855)
!1430 = !DILocation(line: 50, column: 13, scope: !1422)
!1431 = !DILocalVariable(name: "digit", scope: !1422, file: !1379, line: 51, type: !32)
!1432 = !DILocation(line: 51, column: 13, scope: !1422)
!1433 = !DILocalVariable(name: "c", scope: !1422, file: !1379, line: 52, type: !36)
!1434 = !DILocation(line: 52, column: 13, scope: !1422)
!1435 = !DILocalVariable(name: "i", scope: !1422, file: !1379, line: 53, type: !32)
!1436 = !DILocation(line: 53, column: 13, scope: !1422)
!1437 = !DILocalVariable(name: "digits", scope: !1422, file: !1379, line: 54, type: !32)
!1438 = !DILocation(line: 54, column: 13, scope: !1422)
!1439 = !DILocalVariable(name: "offset", scope: !1422, file: !1379, line: 55, type: !32)
!1440 = !DILocation(line: 55, column: 13, scope: !1422)
!1441 = !DILocalVariable(name: "ULintToString", scope: !1422, file: !1379, line: 44, type: !66)
!1442 = !DILocation(line: 44, column: 23, scope: !1422)
!1443 = !DILocation(line: 61, column: 9, scope: !1422)
!1444 = !DILocation(line: 58, column: 9, scope: !1422)
!1445 = !DILocation(line: 60, column: 9, scope: !1422)
!1446 = !DILocation(line: 63, column: 9, scope: !1422)
!1447 = !DILocation(line: 68, column: 13, scope: !1422)
!1448 = !DILocation(line: 69, column: 15, scope: !1422)
!1449 = !DILocation(line: 71, column: 23, scope: !1422)
!1450 = !DILocation(line: 71, column: 13, scope: !1422)
!1451 = !DILocation(line: 71, column: 9, scope: !1422)
!1452 = !DILocation(line: 64, column: 13, scope: !1422)
!1453 = !DILocation(line: 65, column: 13, scope: !1422)
!1454 = !DILocation(line: 66, column: 13, scope: !1422)
!1455 = !DILocation(line: 76, column: 16, scope: !1422)
!1456 = !DILocation(line: 77, column: 17, scope: !1422)
!1457 = !DILocation(line: 72, column: 13, scope: !1422)
!1458 = !DILocation(line: 73, column: 13, scope: !1422)
!1459 = !DILocation(line: 74, column: 13, scope: !1422)
!1460 = !DILocation(line: 75, column: 13, scope: !1422)
!1461 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Arrays.ToString$I@V@ARRAY [*] OF CHAR@arr?I@V@Int16@startIdx?I@V@Int16@endIdx", scope: !1463, file: !1462, line: 4, type: !1464, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1462 = !DIFile(filename: "ArrayToString.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1463 = !DINamespace(name: "Arrays", scope: !7, exportSymbols: true)
!1464 = !DISubroutineType(types: !1465)
!1465 = !{!66, !214, !32, !32}
!1466 = !DILocalVariable(name: "arr", arg: 1, scope: !1461, file: !1462, line: 6, type: !214, flags: DIFlagTypePassByValue)
!1467 = !DILocation(line: 6, column: 13, scope: !1461)
!1468 = !DILocalVariable(name: "startIdx", arg: 2, scope: !1461, file: !1462, line: 7, type: !32, flags: DIFlagTypePassByValue)
!1469 = !DILocation(line: 7, column: 13, scope: !1461)
!1470 = !DILocalVariable(name: "endIdx", arg: 3, scope: !1461, file: !1462, line: 8, type: !32, flags: DIFlagTypePassByValue)
!1471 = !DILocation(line: 8, column: 13, scope: !1461)
!1472 = !DILocalVariable(name: "i", scope: !1461, file: !1462, line: 14, type: !74)
!1473 = !DILocation(line: 14, column: 13, scope: !1461)
!1474 = !DILocalVariable(name: "_lb", scope: !1461, file: !1462, line: 15, type: !74)
!1475 = !DILocation(line: 15, column: 13, scope: !1461)
!1476 = !DILocalVariable(name: "_ub", scope: !1461, file: !1462, line: 16, type: !74)
!1477 = !DILocation(line: 16, column: 13, scope: !1461)
!1478 = !DILocalVariable(name: "_arrayLen", scope: !1461, file: !1462, line: 17, type: !74)
!1479 = !DILocation(line: 17, column: 13, scope: !1461)
!1480 = !DILocalVariable(name: "ToString", scope: !1461, file: !1462, line: 4, type: !66)
!1481 = !DILocation(line: 4, column: 14, scope: !1461)
!1482 = !DILocation(line: 19, column: 9, scope: !1461)
!1483 = !DILocation(line: 20, column: 9, scope: !1461)
!1484 = !DILocation(line: 23, column: 9, scope: !1461)
!1485 = !DILocation(line: 26, column: 15, scope: !1461)
!1486 = !DILocation(line: 29, column: 9, scope: !1461)
!1487 = !DILocation(line: 24, column: 13, scope: !1461)
!1488 = !DILocation(line: 25, column: 13, scope: !1461)
!1489 = !DILocation(line: 32, column: 15, scope: !1461)
!1490 = !DILocation(line: 34, column: 9, scope: !1461)
!1491 = !DILocation(line: 30, column: 13, scope: !1461)
!1492 = !DILocation(line: 31, column: 13, scope: !1461)
!1493 = !DILocation(line: 37, column: 15, scope: !1461)
!1494 = !DILocation(line: 38, column: 9, scope: !1461)
!1495 = !DILocation(line: 40, column: 9, scope: !1461)
!1496 = !DILocation(line: 35, column: 13, scope: !1461)
!1497 = !DILocation(line: 36, column: 13, scope: !1461)
!1498 = !DILocation(line: 42, column: 15, scope: !1461)
!1499 = !DILocation(line: 44, column: 23, scope: !1461)
!1500 = !DILocation(line: 44, column: 13, scope: !1461)
!1501 = !DILocation(line: 44, column: 9, scope: !1461)
!1502 = !DILocation(line: 41, column: 13, scope: !1461)
!1503 = !DILocation(line: 46, column: 16, scope: !1461)
!1504 = !DILocation(line: 48, column: 17, scope: !1461)
!1505 = !DILocation(line: 45, column: 13, scope: !1461)
!1506 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Arrays.ToString$I@V@ARRAY [*] OF CHAR@arr", scope: !1463, file: !1462, line: 50, type: !1507, scopeLine: 50, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1507 = !DISubroutineType(types: !1508)
!1508 = !{!66, !214}
!1509 = !DILocalVariable(name: "arr", arg: 1, scope: !1506, file: !1462, line: 52, type: !214, flags: DIFlagTypePassByValue)
!1510 = !DILocation(line: 52, column: 13, scope: !1506)
!1511 = !DILocalVariable(name: "i", scope: !1506, file: !1462, line: 58, type: !74)
!1512 = !DILocation(line: 58, column: 13, scope: !1506)
!1513 = !DILocalVariable(name: "_lb", scope: !1506, file: !1462, line: 59, type: !74)
!1514 = !DILocation(line: 59, column: 13, scope: !1506)
!1515 = !DILocalVariable(name: "_ub", scope: !1506, file: !1462, line: 60, type: !74)
!1516 = !DILocation(line: 60, column: 13, scope: !1506)
!1517 = !DILocalVariable(name: "_arrayLen", scope: !1506, file: !1462, line: 61, type: !74)
!1518 = !DILocation(line: 61, column: 13, scope: !1506)
!1519 = !DILocalVariable(name: "ToString", scope: !1506, file: !1462, line: 50, type: !66)
!1520 = !DILocation(line: 50, column: 14, scope: !1506)
!1521 = !DILocation(line: 63, column: 9, scope: !1506)
!1522 = !DILocation(line: 64, column: 9, scope: !1506)
!1523 = !DILocation(line: 66, column: 9, scope: !1506)
!1524 = !DILocation(line: 68, column: 9, scope: !1506)
!1525 = !DILocation(line: 70, column: 15, scope: !1506)
!1526 = !DILocation(line: 72, column: 23, scope: !1506)
!1527 = !DILocation(line: 72, column: 13, scope: !1506)
!1528 = !DILocation(line: 72, column: 9, scope: !1506)
!1529 = !DILocation(line: 69, column: 13, scope: !1506)
!1530 = !DILocation(line: 74, column: 16, scope: !1506)
!1531 = !DILocation(line: 76, column: 17, scope: !1506)
!1532 = !DILocation(line: 73, column: 13, scope: !1506)
!1533 = distinct !DISubprogram(name: "CountDigits", linkageName: "Simatic.Ax.Conversion.CountDigits$I@V@Int64@value", scope: !7, file: !1534, line: 2, type: !1535, scopeLine: 2, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1534 = !DIFile(filename: "CountDigits.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1535 = !DISubroutineType(types: !1536)
!1536 = !{!32, !563}
!1537 = !DILocalVariable(name: "value", arg: 1, scope: !1533, file: !1534, line: 4, type: !563, flags: DIFlagTypePassByValue)
!1538 = !DILocation(line: 4, column: 13, scope: !1533)
!1539 = !DILocalVariable(name: "divisor", scope: !1533, file: !1534, line: 7, type: !563)
!1540 = !DILocation(line: 7, column: 13, scope: !1533)
!1541 = !DILocalVariable(name: "i", scope: !1533, file: !1534, line: 8, type: !32)
!1542 = !DILocation(line: 8, column: 13, scope: !1533)
!1543 = !DILocalVariable(name: "CountDigits", scope: !1533, file: !1534, line: 2, type: !32)
!1544 = !DILocation(line: 2, column: 14, scope: !1533)
!1545 = !DILocation(line: 14, column: 9, scope: !1533)
!1546 = !DILocation(line: 17, column: 15, scope: !1533)
!1547 = !DILocation(line: 19, column: 23, scope: !1533)
!1548 = !DILocation(line: 19, column: 13, scope: !1533)
!1549 = !DILocation(line: 19, column: 9, scope: !1533)
!1550 = !DILocation(line: 15, column: 13, scope: !1533)
!1551 = !DILocation(line: 16, column: 13, scope: !1533)
!1552 = !DILocation(line: 25, column: 16, scope: !1533)
!1553 = !DILocation(line: 26, column: 9, scope: !1533)
!1554 = !DILocation(line: 27, column: 17, scope: !1533)
!1555 = !DILocation(line: 20, column: 13, scope: !1533)
!1556 = !DILocation(line: 23, column: 19, scope: !1533)
!1557 = !DILocation(line: 24, column: 13, scope: !1533)
!1558 = !DILocation(line: 21, column: 17, scope: !1533)
!1559 = !DILocation(line: 22, column: 17, scope: !1533)
!1560 = distinct !DISubprogram(name: "CountDigits", linkageName: "Simatic.Ax.Conversion.CountDigits$I@V@UInt64@value", scope: !7, file: !1534, line: 29, type: !1561, scopeLine: 29, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1561 = !DISubroutineType(types: !1562)
!1562 = !{!32, !855}
!1563 = !DILocalVariable(name: "value", arg: 1, scope: !1560, file: !1534, line: 31, type: !855, flags: DIFlagTypePassByValue)
!1564 = !DILocation(line: 31, column: 13, scope: !1560)
!1565 = !DILocalVariable(name: "divisor", scope: !1560, file: !1534, line: 34, type: !855)
!1566 = !DILocation(line: 34, column: 13, scope: !1560)
!1567 = !DILocalVariable(name: "i", scope: !1560, file: !1534, line: 35, type: !32)
!1568 = !DILocation(line: 35, column: 13, scope: !1560)
!1569 = !DILocalVariable(name: "CountDigits", scope: !1560, file: !1534, line: 29, type: !32)
!1570 = !DILocation(line: 29, column: 14, scope: !1560)
!1571 = !DILocation(line: 41, column: 9, scope: !1560)
!1572 = !DILocation(line: 44, column: 15, scope: !1560)
!1573 = !DILocation(line: 46, column: 23, scope: !1560)
!1574 = !DILocation(line: 46, column: 13, scope: !1560)
!1575 = !DILocation(line: 46, column: 9, scope: !1560)
!1576 = !DILocation(line: 42, column: 13, scope: !1560)
!1577 = !DILocation(line: 43, column: 13, scope: !1560)
!1578 = !DILocation(line: 52, column: 16, scope: !1560)
!1579 = !DILocation(line: 53, column: 9, scope: !1560)
!1580 = !DILocation(line: 54, column: 17, scope: !1560)
!1581 = !DILocation(line: 47, column: 13, scope: !1560)
!1582 = !DILocation(line: 50, column: 19, scope: !1560)
!1583 = !DILocation(line: 51, column: 13, scope: !1560)
!1584 = !DILocation(line: 48, column: 17, scope: !1560)
!1585 = !DILocation(line: 49, column: 17, scope: !1560)
!1586 = distinct !DISubprogram(name: "CreateStringWithBlanksOfLength", linkageName: "Simatic.Ax.Conversion.CreateStringWithBlanksOfLength$I@V@STRING@str?I@V@Int16@len?I@V@STRING[1]@_tempString", scope: !7, file: !1587, line: 4, type: !1588, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1587 = !DIFile(filename: "CreateStringWithBlanksOfLength.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1588 = !DISubroutineType(types: !1589)
!1589 = !{!66, !214, !32, !214}
!1590 = !DILocalVariable(name: "str", arg: 1, scope: !1586, file: !1587, line: 6, type: !66, flags: DIFlagTypePassByValue)
!1591 = !DILocation(line: 6, column: 13, scope: !1586)
!1592 = !DILocalVariable(name: "len", arg: 2, scope: !1586, file: !1587, line: 7, type: !32, flags: DIFlagTypePassByValue)
!1593 = !DILocation(line: 7, column: 13, scope: !1586)
!1594 = !DILocalVariable(name: "_tempString", arg: 3, scope: !1586, file: !1587, line: 8, type: !1595, flags: DIFlagTypePassByValue)
!1595 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[1]", file: !1587, line: 8, size: 32, align: 8, flags: DIFlagTypePassByValue, elements: !1596)
!1596 = !{!1597}
!1597 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1595, file: !1587, line: 8, baseType: !1598, size: 16, align: 8, offset: 16)
!1598 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 16, align: 8, elements: !162)
!1599 = !DILocation(line: 8, column: 13, scope: !1586)
!1600 = !DILocalVariable(name: "i", scope: !1586, file: !1587, line: 11, type: !32)
!1601 = !DILocation(line: 11, column: 13, scope: !1586)
!1602 = !DILocalVariable(name: "CreateStringWithBlanksOfLength", scope: !1586, file: !1587, line: 4, type: !66)
!1603 = !DILocation(line: 4, column: 14, scope: !1586)
!1604 = !DILocation(line: 13, column: 9, scope: !1586)
!1605 = !DILocation(line: 15, column: 23, scope: !1586)
!1606 = !DILocation(line: 15, column: 13, scope: !1586)
!1607 = !DILocation(line: 15, column: 9, scope: !1586)
!1608 = !DILocation(line: 17, column: 16, scope: !1586)
!1609 = !DILocation(line: 19, column: 17, scope: !1586)
!1610 = !DILocation(line: 16, column: 13, scope: !1586)
!1611 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@Int8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 3, type: !1614, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1612 = !DIFile(filename: "IntToString.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1613 = !DINamespace(name: "Integer", scope: !7, exportSymbols: true)
!1614 = !DISubroutineType(types: !1615)
!1615 = !{!1616, !513, !5}
!1616 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[4]", file: !1612, line: 3, size: 56, align: 8, flags: DIFlagTypePassByValue, elements: !1617)
!1617 = !{!1618}
!1618 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1616, file: !1612, line: 3, baseType: !1619, size: 40, align: 8, offset: 16)
!1619 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 40, align: 8, elements: !1620)
!1620 = !{!1621}
!1621 = !DISubrange(count: 5)
!1622 = !DILocalVariable(name: "value", arg: 1, scope: !1611, file: !1612, line: 5, type: !513, flags: DIFlagTypePassByValue)
!1623 = !DILocation(line: 5, column: 13, scope: !1611)
!1624 = !DILocalVariable(name: "mode", arg: 2, scope: !1611, file: !1612, line: 6, type: !5, flags: DIFlagTypePassByValue)
!1625 = !DILocation(line: 6, column: 13, scope: !1611)
!1626 = !DILocalVariable(name: "ToString", scope: !1611, file: !1612, line: 3, type: !1616)
!1627 = !DILocation(line: 3, column: 14, scope: !1611)
!1628 = !DILocation(line: 10, column: 9, scope: !1611)
!1629 = !DILocation(line: 11, column: 17, scope: !1611)
!1630 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@UInt8@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 13, type: !1631, scopeLine: 13, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1631 = !DISubroutineType(types: !1632)
!1632 = !{!1616, !36, !5}
!1633 = !DILocalVariable(name: "value", arg: 1, scope: !1630, file: !1612, line: 15, type: !36, flags: DIFlagTypePassByValue)
!1634 = !DILocation(line: 15, column: 13, scope: !1630)
!1635 = !DILocalVariable(name: "mode", arg: 2, scope: !1630, file: !1612, line: 16, type: !5, flags: DIFlagTypePassByValue)
!1636 = !DILocation(line: 16, column: 13, scope: !1630)
!1637 = !DILocalVariable(name: "ToString", scope: !1630, file: !1612, line: 13, type: !1616)
!1638 = !DILocation(line: 13, column: 14, scope: !1630)
!1639 = !DILocation(line: 20, column: 9, scope: !1630)
!1640 = !DILocation(line: 21, column: 17, scope: !1630)
!1641 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@Int16@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 23, type: !1642, scopeLine: 23, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1642 = !DISubroutineType(types: !1643)
!1643 = !{!1644, !32, !5}
!1644 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[6]", file: !1612, line: 23, size: 72, align: 8, flags: DIFlagTypePassByValue, elements: !1645)
!1645 = !{!1646}
!1646 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1644, file: !1612, line: 23, baseType: !1647, size: 56, align: 8, offset: 16)
!1647 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 56, align: 8, elements: !1648)
!1648 = !{!1649}
!1649 = !DISubrange(count: 7)
!1650 = !DILocalVariable(name: "value", arg: 1, scope: !1641, file: !1612, line: 25, type: !32, flags: DIFlagTypePassByValue)
!1651 = !DILocation(line: 25, column: 13, scope: !1641)
!1652 = !DILocalVariable(name: "mode", arg: 2, scope: !1641, file: !1612, line: 26, type: !5, flags: DIFlagTypePassByValue)
!1653 = !DILocation(line: 26, column: 13, scope: !1641)
!1654 = !DILocalVariable(name: "ToString", scope: !1641, file: !1612, line: 23, type: !1644)
!1655 = !DILocation(line: 23, column: 14, scope: !1641)
!1656 = !DILocation(line: 30, column: 9, scope: !1641)
!1657 = !DILocation(line: 31, column: 17, scope: !1641)
!1658 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@UInt16@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 33, type: !1659, scopeLine: 33, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1659 = !DISubroutineType(types: !1660)
!1660 = !{!1644, !756, !5}
!1661 = !DILocalVariable(name: "value", arg: 1, scope: !1658, file: !1612, line: 35, type: !756, flags: DIFlagTypePassByValue)
!1662 = !DILocation(line: 35, column: 13, scope: !1658)
!1663 = !DILocalVariable(name: "mode", arg: 2, scope: !1658, file: !1612, line: 36, type: !5, flags: DIFlagTypePassByValue)
!1664 = !DILocation(line: 36, column: 13, scope: !1658)
!1665 = !DILocalVariable(name: "ToString", scope: !1658, file: !1612, line: 33, type: !1644)
!1666 = !DILocation(line: 33, column: 14, scope: !1658)
!1667 = !DILocation(line: 40, column: 9, scope: !1658)
!1668 = !DILocation(line: 41, column: 17, scope: !1658)
!1669 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@Int32@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 44, type: !1670, scopeLine: 44, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1670 = !DISubroutineType(types: !1671)
!1671 = !{!1672, !74, !5}
!1672 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[11]", file: !1612, line: 44, size: 112, align: 8, flags: DIFlagTypePassByValue, elements: !1673)
!1673 = !{!1674}
!1674 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1672, file: !1612, line: 44, baseType: !1675, size: 96, align: 8, offset: 16)
!1675 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 96, align: 8, elements: !1676)
!1676 = !{!1677}
!1677 = !DISubrange(count: 12)
!1678 = !DILocalVariable(name: "value", arg: 1, scope: !1669, file: !1612, line: 46, type: !74, flags: DIFlagTypePassByValue)
!1679 = !DILocation(line: 46, column: 13, scope: !1669)
!1680 = !DILocalVariable(name: "mode", arg: 2, scope: !1669, file: !1612, line: 47, type: !5, flags: DIFlagTypePassByValue)
!1681 = !DILocation(line: 47, column: 13, scope: !1669)
!1682 = !DILocalVariable(name: "ToString", scope: !1669, file: !1612, line: 44, type: !1672)
!1683 = !DILocation(line: 44, column: 14, scope: !1669)
!1684 = !DILocation(line: 51, column: 9, scope: !1669)
!1685 = !DILocation(line: 52, column: 17, scope: !1669)
!1686 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@UInt32@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 54, type: !1687, scopeLine: 54, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1687 = !DISubroutineType(types: !1688)
!1688 = !{!1672, !805, !5}
!1689 = !DILocalVariable(name: "value", arg: 1, scope: !1686, file: !1612, line: 56, type: !805, flags: DIFlagTypePassByValue)
!1690 = !DILocation(line: 56, column: 13, scope: !1686)
!1691 = !DILocalVariable(name: "mode", arg: 2, scope: !1686, file: !1612, line: 57, type: !5, flags: DIFlagTypePassByValue)
!1692 = !DILocation(line: 57, column: 13, scope: !1686)
!1693 = !DILocalVariable(name: "ToString", scope: !1686, file: !1612, line: 54, type: !1672)
!1694 = !DILocation(line: 54, column: 14, scope: !1686)
!1695 = !DILocation(line: 61, column: 9, scope: !1686)
!1696 = !DILocation(line: 62, column: 17, scope: !1686)
!1697 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@Int64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 64, type: !1698, scopeLine: 64, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1698 = !DISubroutineType(types: !1699)
!1699 = !{!1700, !563, !5}
!1700 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[20]", file: !1612, line: 64, size: 184, align: 8, flags: DIFlagTypePassByValue, elements: !1701)
!1701 = !{!1702}
!1702 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1700, file: !1612, line: 64, baseType: !1703, size: 168, align: 8, offset: 16)
!1703 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 168, align: 8, elements: !1704)
!1704 = !{!1705}
!1705 = !DISubrange(count: 21)
!1706 = !DILocalVariable(name: "value", arg: 1, scope: !1697, file: !1612, line: 66, type: !563, flags: DIFlagTypePassByValue)
!1707 = !DILocation(line: 66, column: 13, scope: !1697)
!1708 = !DILocalVariable(name: "mode", arg: 2, scope: !1697, file: !1612, line: 67, type: !5, flags: DIFlagTypePassByValue)
!1709 = !DILocation(line: 67, column: 13, scope: !1697)
!1710 = !DILocalVariable(name: "ToString", scope: !1697, file: !1612, line: 64, type: !1700)
!1711 = !DILocation(line: 64, column: 14, scope: !1697)
!1712 = !DILocation(line: 71, column: 9, scope: !1697)
!1713 = !DILocation(line: 72, column: 17, scope: !1697)
!1714 = distinct !DISubprogram(name: "ToString", linkageName: "Simatic.Ax.Conversion.Integer.ToString$I@V@UInt64@value?I@V@Simatic.Ax.Conversion.ConversionMode@mode", scope: !1613, file: !1612, line: 74, type: !1715, scopeLine: 74, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1715 = !DISubroutineType(types: !1716)
!1716 = !{!1717, !855, !5}
!1717 = !DICompositeType(tag: DW_TAG_structure_type, name: "STRING[21]", file: !1612, line: 74, size: 192, align: 8, flags: DIFlagTypePassByValue, elements: !1718)
!1718 = !{!1719}
!1719 = !DIDerivedType(tag: DW_TAG_member, name: "data", scope: !1717, file: !1612, line: 74, baseType: !1720, size: 176, align: 8, offset: 16)
!1720 = !DICompositeType(tag: DW_TAG_array_type, baseType: !60, size: 176, align: 8, elements: !1721)
!1721 = !{!1722}
!1722 = !DISubrange(count: 22)
!1723 = !DILocalVariable(name: "value", arg: 1, scope: !1714, file: !1612, line: 76, type: !855, flags: DIFlagTypePassByValue)
!1724 = !DILocation(line: 76, column: 13, scope: !1714)
!1725 = !DILocalVariable(name: "mode", arg: 2, scope: !1714, file: !1612, line: 77, type: !5, flags: DIFlagTypePassByValue)
!1726 = !DILocation(line: 77, column: 13, scope: !1714)
!1727 = !DILocalVariable(name: "ToString", scope: !1714, file: !1612, line: 74, type: !1717)
!1728 = !DILocation(line: 74, column: 14, scope: !1714)
!1729 = !DILocation(line: 81, column: 9, scope: !1714)
!1730 = !DILocation(line: 82, column: 17, scope: !1714)
!1731 = distinct !DISubprogram(name: "StringToAnyInt", linkageName: "Simatic.Ax.Conversion.StringToAnyInt$I@V@STRING@str?O@V@Int64@value", scope: !7, file: !1732, line: 4, type: !1733, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1732 = !DIFile(filename: "StringToAnyInt.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1733 = !DISubroutineType(types: !1734)
!1734 = !{!77, !214, !562}
!1735 = !DILocalVariable(name: "str", arg: 1, scope: !1731, file: !1732, line: 6, type: !66, flags: DIFlagTypePassByValue)
!1736 = !DILocation(line: 6, column: 13, scope: !1731)
!1737 = !DILocalVariable(name: "value", arg: 2, scope: !1731, file: !1732, line: 9, type: !562, flags: DIFlagTypePassByValue)
!1738 = !DILocation(line: 9, column: 13, scope: !1731)
!1739 = !DILocalVariable(name: "_len", scope: !1731, file: !1732, line: 12, type: !32)
!1740 = !DILocation(line: 12, column: 13, scope: !1731)
!1741 = !DILocalVariable(name: "i", scope: !1731, file: !1732, line: 13, type: !32)
!1742 = !DILocation(line: 13, column: 13, scope: !1731)
!1743 = !DILocalVariable(name: "_val", scope: !1731, file: !1732, line: 14, type: !32)
!1744 = !DILocation(line: 14, column: 13, scope: !1731)
!1745 = !DILocalVariable(name: "_sig", scope: !1731, file: !1732, line: 15, type: !32)
!1746 = !DILocation(line: 15, column: 13, scope: !1731)
!1747 = !DILocalVariable(name: "_start", scope: !1731, file: !1732, line: 16, type: !32)
!1748 = !DILocation(line: 16, column: 13, scope: !1731)
!1749 = !DILocalVariable(name: "_c", scope: !1731, file: !1732, line: 17, type: !66)
!1750 = !DILocation(line: 17, column: 13, scope: !1731)
!1751 = !DILocalVariable(name: "StringToAnyInt", scope: !1731, file: !1732, line: 4, type: !77)
!1752 = !DILocation(line: 4, column: 14, scope: !1731)
!1753 = !DILocation(line: 20, column: 9, scope: !1731)
!1754 = !DILocation(line: 22, column: 9, scope: !1731)
!1755 = !DILocation(line: 29, column: 13, scope: !1731)
!1756 = !DILocation(line: 30, column: 13, scope: !1731)
!1757 = !DILocation(line: 25, column: 9, scope: !1731)
!1758 = !DILocation(line: 31, column: 15, scope: !1731)
!1759 = !DILocation(line: 32, column: 9, scope: !1731)
!1760 = !DILocation(line: 33, column: 28, scope: !1731)
!1761 = !DILocation(line: 33, column: 13, scope: !1731)
!1762 = !DILocation(line: 33, column: 9, scope: !1731)
!1763 = !DILocation(line: 23, column: 13, scope: !1731)
!1764 = !DILocation(line: 24, column: 13, scope: !1731)
!1765 = !DILocation(line: 26, column: 13, scope: !1731)
!1766 = !DILocation(line: 27, column: 13, scope: !1731)
!1767 = !DILocation(line: 58, column: 16, scope: !1731)
!1768 = !DILocation(line: 59, column: 9, scope: !1731)
!1769 = !DILocation(line: 60, column: 9, scope: !1731)
!1770 = !DILocation(line: 35, column: 13, scope: !1731)
!1771 = !DILocation(line: 36, column: 13, scope: !1731)
!1772 = !DILocation(line: 37, column: 13, scope: !1731)
!1773 = !DILocation(line: 57, column: 13, scope: !1731)
!1774 = !DILocation(line: 38, column: 23, scope: !1731)
!1775 = !DILocation(line: 39, column: 23, scope: !1731)
!1776 = !DILocation(line: 40, column: 23, scope: !1731)
!1777 = !DILocation(line: 41, column: 23, scope: !1731)
!1778 = !DILocation(line: 42, column: 23, scope: !1731)
!1779 = !DILocation(line: 43, column: 23, scope: !1731)
!1780 = !DILocation(line: 44, column: 23, scope: !1731)
!1781 = !DILocation(line: 45, column: 23, scope: !1731)
!1782 = !DILocation(line: 46, column: 23, scope: !1731)
!1783 = !DILocation(line: 47, column: 23, scope: !1731)
!1784 = !DILocation(line: 49, column: 21, scope: !1731)
!1785 = !DILocation(line: 50, column: 21, scope: !1731)
!1786 = !DILocation(line: 51, column: 21, scope: !1731)
!1787 = !DILocation(line: 53, column: 17, scope: !1731)
!1788 = !DILocation(line: 54, column: 17, scope: !1731)
!1789 = !DILocation(line: 55, column: 17, scope: !1731)
!1790 = !DILocation(line: 64, column: 13, scope: !1731)
!1791 = !DILocation(line: 65, column: 15, scope: !1731)
!1792 = !DILocation(line: 67, column: 17, scope: !1731)
!1793 = !DILocation(line: 61, column: 13, scope: !1731)
!1794 = !DILocation(line: 62, column: 13, scope: !1731)
!1795 = distinct !DISubprogram(name: "StringToULint", linkageName: "Simatic.Ax.Conversion.StringToULint$I@V@STRING@str?O@V@UInt64@value", scope: !7, file: !1732, line: 69, type: !1796, scopeLine: 69, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1796 = !DISubroutineType(types: !1797)
!1797 = !{!77, !214, !854}
!1798 = !DILocalVariable(name: "str", arg: 1, scope: !1795, file: !1732, line: 71, type: !66, flags: DIFlagTypePassByValue)
!1799 = !DILocation(line: 71, column: 13, scope: !1795)
!1800 = !DILocalVariable(name: "value", arg: 2, scope: !1795, file: !1732, line: 74, type: !854, flags: DIFlagTypePassByValue)
!1801 = !DILocation(line: 74, column: 13, scope: !1795)
!1802 = !DILocalVariable(name: "_len", scope: !1795, file: !1732, line: 77, type: !32)
!1803 = !DILocation(line: 77, column: 13, scope: !1795)
!1804 = !DILocalVariable(name: "i", scope: !1795, file: !1732, line: 78, type: !32)
!1805 = !DILocation(line: 78, column: 13, scope: !1795)
!1806 = !DILocalVariable(name: "_val", scope: !1795, file: !1732, line: 79, type: !855)
!1807 = !DILocation(line: 79, column: 13, scope: !1795)
!1808 = !DILocalVariable(name: "_start", scope: !1795, file: !1732, line: 80, type: !32)
!1809 = !DILocation(line: 80, column: 13, scope: !1795)
!1810 = !DILocalVariable(name: "_c", scope: !1795, file: !1732, line: 81, type: !66)
!1811 = !DILocation(line: 81, column: 13, scope: !1795)
!1812 = !DILocalVariable(name: "StringToULint", scope: !1795, file: !1732, line: 69, type: !77)
!1813 = !DILocation(line: 69, column: 23, scope: !1795)
!1814 = !DILocation(line: 84, column: 9, scope: !1795)
!1815 = !DILocation(line: 86, column: 9, scope: !1795)
!1816 = !DILocation(line: 89, column: 13, scope: !1795)
!1817 = !DILocation(line: 90, column: 15, scope: !1795)
!1818 = !DILocation(line: 92, column: 9, scope: !1795)
!1819 = !DILocation(line: 94, column: 28, scope: !1795)
!1820 = !DILocation(line: 94, column: 13, scope: !1795)
!1821 = !DILocation(line: 94, column: 9, scope: !1795)
!1822 = !DILocation(line: 87, column: 13, scope: !1795)
!1823 = !DILocation(line: 118, column: 16, scope: !1795)
!1824 = !DILocation(line: 119, column: 9, scope: !1795)
!1825 = !DILocation(line: 121, column: 17, scope: !1795)
!1826 = !DILocation(line: 96, column: 13, scope: !1795)
!1827 = !DILocation(line: 97, column: 13, scope: !1795)
!1828 = !DILocation(line: 98, column: 13, scope: !1795)
!1829 = !DILocation(line: 117, column: 13, scope: !1795)
!1830 = !DILocation(line: 99, column: 23, scope: !1795)
!1831 = !DILocation(line: 100, column: 23, scope: !1795)
!1832 = !DILocation(line: 101, column: 23, scope: !1795)
!1833 = !DILocation(line: 102, column: 23, scope: !1795)
!1834 = !DILocation(line: 103, column: 23, scope: !1795)
!1835 = !DILocation(line: 104, column: 23, scope: !1795)
!1836 = !DILocation(line: 105, column: 23, scope: !1795)
!1837 = !DILocation(line: 106, column: 23, scope: !1795)
!1838 = !DILocation(line: 107, column: 23, scope: !1795)
!1839 = !DILocation(line: 108, column: 23, scope: !1795)
!1840 = !DILocation(line: 110, column: 17, scope: !1795)
!1841 = !DILocation(line: 111, column: 21, scope: !1795)
!1842 = !DILocation(line: 113, column: 17, scope: !1795)
!1843 = !DILocation(line: 114, column: 17, scope: !1795)
!1844 = !DILocation(line: 115, column: 17, scope: !1795)
!1845 = distinct !DISubprogram(name: "ToArray", linkageName: "Simatic.Ax.Conversion.Strings.ToArray$I@V@STRING@str?I@R@ARRAY [*] OF CHAR@arr", scope: !1847, file: !1846, line: 4, type: !1848, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1846 = !DIFile(filename: "StringToArray.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1847 = !DINamespace(name: "Strings", scope: !7, exportSymbols: true)
!1848 = !DISubroutineType(types: !1849)
!1849 = !{!74, !214, !945}
!1850 = !DILocalVariable(name: "str", arg: 1, scope: !1845, file: !1846, line: 6, type: !66, flags: DIFlagTypePassByValue)
!1851 = !DILocation(line: 6, column: 13, scope: !1845)
!1852 = !DILocalVariable(name: "arr", arg: 2, scope: !1845, file: !1846, line: 9, type: !945, flags: DIFlagTypePassByReference)
!1853 = !DILocation(line: 9, column: 13, scope: !1845)
!1854 = !DILocalVariable(name: "i", scope: !1845, file: !1846, line: 12, type: !74)
!1855 = !DILocation(line: 12, column: 13, scope: !1845)
!1856 = !DILocalVariable(name: "_lb", scope: !1845, file: !1846, line: 13, type: !74)
!1857 = !DILocation(line: 13, column: 13, scope: !1845)
!1858 = !DILocalVariable(name: "_ub", scope: !1845, file: !1846, line: 14, type: !74)
!1859 = !DILocation(line: 14, column: 13, scope: !1845)
!1860 = !DILocalVariable(name: "_maxLen", scope: !1845, file: !1846, line: 15, type: !74)
!1861 = !DILocation(line: 15, column: 13, scope: !1845)
!1862 = !DILocalVariable(name: "ToArray", scope: !1845, file: !1846, line: 4, type: !74)
!1863 = !DILocation(line: 4, column: 14, scope: !1845)
!1864 = !DILocation(line: 17, column: 9, scope: !1845)
!1865 = !DILocation(line: 18, column: 9, scope: !1845)
!1866 = !DILocation(line: 19, column: 9, scope: !1845)
!1867 = !DILocation(line: 21, column: 9, scope: !1845)
!1868 = !DILocation(line: 23, column: 15, scope: !1845)
!1869 = !DILocation(line: 25, column: 23, scope: !1845)
!1870 = !DILocation(line: 25, column: 13, scope: !1845)
!1871 = !DILocation(line: 25, column: 9, scope: !1845)
!1872 = !DILocation(line: 22, column: 13, scope: !1845)
!1873 = !DILocation(line: 27, column: 16, scope: !1845)
!1874 = !DILocation(line: 28, column: 9, scope: !1845)
!1875 = !DILocation(line: 29, column: 17, scope: !1845)
!1876 = !DILocation(line: 26, column: 13, scope: !1845)
!1877 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int8@value", scope: !1847, file: !1878, line: 4, type: !1879, scopeLine: 4, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1878 = !DIFile(filename: "ToInt.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@simatic-ax\\conversion\\src")
!1879 = !DISubroutineType(types: !1880)
!1880 = !{!77, !214, !512}
!1881 = !DILocalVariable(name: "str", arg: 1, scope: !1877, file: !1878, line: 6, type: !66, flags: DIFlagTypePassByValue)
!1882 = !DILocation(line: 6, column: 13, scope: !1877)
!1883 = !DILocalVariable(name: "value", arg: 2, scope: !1877, file: !1878, line: 9, type: !512, flags: DIFlagTypePassByValue)
!1884 = !DILocation(line: 9, column: 13, scope: !1877)
!1885 = !DILocalVariable(name: "_val", scope: !1877, file: !1878, line: 12, type: !563)
!1886 = !DILocation(line: 12, column: 13, scope: !1877)
!1887 = !DILocalVariable(name: "ToInt", scope: !1877, file: !1878, line: 4, type: !77)
!1888 = !DILocation(line: 4, column: 14, scope: !1877)
!1889 = !DILocation(line: 19, column: 9, scope: !1877)
!1890 = !DILocation(line: 21, column: 9, scope: !1877)
!1891 = !DILocation(line: 25, column: 13, scope: !1877)
!1892 = !DILocation(line: 26, column: 15, scope: !1877)
!1893 = !DILocation(line: 27, column: 17, scope: !1877)
!1894 = !DILocation(line: 22, column: 13, scope: !1877)
!1895 = !DILocation(line: 23, column: 13, scope: !1877)
!1896 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int16@value", scope: !1847, file: !1878, line: 29, type: !1897, scopeLine: 29, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1897 = !DISubroutineType(types: !1898)
!1898 = !{!77, !214, !279}
!1899 = !DILocalVariable(name: "str", arg: 1, scope: !1896, file: !1878, line: 31, type: !66, flags: DIFlagTypePassByValue)
!1900 = !DILocation(line: 31, column: 13, scope: !1896)
!1901 = !DILocalVariable(name: "value", arg: 2, scope: !1896, file: !1878, line: 34, type: !279, flags: DIFlagTypePassByValue)
!1902 = !DILocation(line: 34, column: 13, scope: !1896)
!1903 = !DILocalVariable(name: "_val", scope: !1896, file: !1878, line: 37, type: !563)
!1904 = !DILocation(line: 37, column: 13, scope: !1896)
!1905 = !DILocalVariable(name: "ToInt", scope: !1896, file: !1878, line: 29, type: !77)
!1906 = !DILocation(line: 29, column: 14, scope: !1896)
!1907 = !DILocation(line: 44, column: 9, scope: !1896)
!1908 = !DILocation(line: 46, column: 9, scope: !1896)
!1909 = !DILocation(line: 50, column: 13, scope: !1896)
!1910 = !DILocation(line: 51, column: 15, scope: !1896)
!1911 = !DILocation(line: 52, column: 17, scope: !1896)
!1912 = !DILocation(line: 47, column: 13, scope: !1896)
!1913 = !DILocation(line: 48, column: 13, scope: !1896)
!1914 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int32@value", scope: !1847, file: !1878, line: 54, type: !1915, scopeLine: 54, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1915 = !DISubroutineType(types: !1916)
!1916 = !{!77, !214, !612}
!1917 = !DILocalVariable(name: "str", arg: 1, scope: !1914, file: !1878, line: 56, type: !66, flags: DIFlagTypePassByValue)
!1918 = !DILocation(line: 56, column: 13, scope: !1914)
!1919 = !DILocalVariable(name: "value", arg: 2, scope: !1914, file: !1878, line: 59, type: !612, flags: DIFlagTypePassByValue)
!1920 = !DILocation(line: 59, column: 13, scope: !1914)
!1921 = !DILocalVariable(name: "_val", scope: !1914, file: !1878, line: 62, type: !563)
!1922 = !DILocation(line: 62, column: 13, scope: !1914)
!1923 = !DILocalVariable(name: "ToInt", scope: !1914, file: !1878, line: 54, type: !77)
!1924 = !DILocation(line: 54, column: 14, scope: !1914)
!1925 = !DILocation(line: 69, column: 9, scope: !1914)
!1926 = !DILocation(line: 71, column: 9, scope: !1914)
!1927 = !DILocation(line: 75, column: 13, scope: !1914)
!1928 = !DILocation(line: 76, column: 15, scope: !1914)
!1929 = !DILocation(line: 77, column: 17, scope: !1914)
!1930 = !DILocation(line: 72, column: 13, scope: !1914)
!1931 = !DILocation(line: 73, column: 13, scope: !1914)
!1932 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@Int64@value", scope: !1847, file: !1878, line: 79, type: !1733, scopeLine: 79, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1933 = !DILocalVariable(name: "str", arg: 1, scope: !1932, file: !1878, line: 81, type: !66, flags: DIFlagTypePassByValue)
!1934 = !DILocation(line: 81, column: 13, scope: !1932)
!1935 = !DILocalVariable(name: "value", arg: 2, scope: !1932, file: !1878, line: 84, type: !562, flags: DIFlagTypePassByValue)
!1936 = !DILocation(line: 84, column: 13, scope: !1932)
!1937 = !DILocalVariable(name: "_val", scope: !1932, file: !1878, line: 87, type: !563)
!1938 = !DILocation(line: 87, column: 13, scope: !1932)
!1939 = !DILocalVariable(name: "ToInt", scope: !1932, file: !1878, line: 79, type: !77)
!1940 = !DILocation(line: 79, column: 14, scope: !1932)
!1941 = !DILocation(line: 94, column: 9, scope: !1932)
!1942 = !DILocation(line: 96, column: 9, scope: !1932)
!1943 = !DILocation(line: 100, column: 13, scope: !1932)
!1944 = !DILocation(line: 101, column: 15, scope: !1932)
!1945 = !DILocation(line: 102, column: 17, scope: !1932)
!1946 = !DILocation(line: 97, column: 13, scope: !1932)
!1947 = !DILocation(line: 98, column: 13, scope: !1932)
!1948 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt8@value", scope: !1847, file: !1878, line: 104, type: !1949, scopeLine: 104, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1949 = !DISubroutineType(types: !1950)
!1950 = !{!77, !214, !707}
!1951 = !DILocalVariable(name: "str", arg: 1, scope: !1948, file: !1878, line: 106, type: !66, flags: DIFlagTypePassByValue)
!1952 = !DILocation(line: 106, column: 13, scope: !1948)
!1953 = !DILocalVariable(name: "value", arg: 2, scope: !1948, file: !1878, line: 109, type: !707, flags: DIFlagTypePassByValue)
!1954 = !DILocation(line: 109, column: 13, scope: !1948)
!1955 = !DILocalVariable(name: "_val", scope: !1948, file: !1878, line: 112, type: !563)
!1956 = !DILocation(line: 112, column: 13, scope: !1948)
!1957 = !DILocalVariable(name: "ToInt", scope: !1948, file: !1878, line: 104, type: !77)
!1958 = !DILocation(line: 104, column: 14, scope: !1948)
!1959 = !DILocation(line: 119, column: 9, scope: !1948)
!1960 = !DILocation(line: 121, column: 9, scope: !1948)
!1961 = !DILocation(line: 125, column: 13, scope: !1948)
!1962 = !DILocation(line: 126, column: 15, scope: !1948)
!1963 = !DILocation(line: 127, column: 17, scope: !1948)
!1964 = !DILocation(line: 122, column: 13, scope: !1948)
!1965 = !DILocation(line: 123, column: 13, scope: !1948)
!1966 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt16@value", scope: !1847, file: !1878, line: 129, type: !1967, scopeLine: 129, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1967 = !DISubroutineType(types: !1968)
!1968 = !{!77, !214, !755}
!1969 = !DILocalVariable(name: "str", arg: 1, scope: !1966, file: !1878, line: 131, type: !66, flags: DIFlagTypePassByValue)
!1970 = !DILocation(line: 131, column: 13, scope: !1966)
!1971 = !DILocalVariable(name: "value", arg: 2, scope: !1966, file: !1878, line: 134, type: !755, flags: DIFlagTypePassByValue)
!1972 = !DILocation(line: 134, column: 13, scope: !1966)
!1973 = !DILocalVariable(name: "_val", scope: !1966, file: !1878, line: 137, type: !563)
!1974 = !DILocation(line: 137, column: 13, scope: !1966)
!1975 = !DILocalVariable(name: "ToInt", scope: !1966, file: !1878, line: 129, type: !77)
!1976 = !DILocation(line: 129, column: 14, scope: !1966)
!1977 = !DILocation(line: 144, column: 9, scope: !1966)
!1978 = !DILocation(line: 146, column: 9, scope: !1966)
!1979 = !DILocation(line: 150, column: 13, scope: !1966)
!1980 = !DILocation(line: 151, column: 15, scope: !1966)
!1981 = !DILocation(line: 152, column: 17, scope: !1966)
!1982 = !DILocation(line: 147, column: 13, scope: !1966)
!1983 = !DILocation(line: 148, column: 13, scope: !1966)
!1984 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt32@value", scope: !1847, file: !1878, line: 154, type: !1985, scopeLine: 154, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!1985 = !DISubroutineType(types: !1986)
!1986 = !{!77, !214, !804}
!1987 = !DILocalVariable(name: "str", arg: 1, scope: !1984, file: !1878, line: 156, type: !66, flags: DIFlagTypePassByValue)
!1988 = !DILocation(line: 156, column: 13, scope: !1984)
!1989 = !DILocalVariable(name: "value", arg: 2, scope: !1984, file: !1878, line: 159, type: !804, flags: DIFlagTypePassByValue)
!1990 = !DILocation(line: 159, column: 13, scope: !1984)
!1991 = !DILocalVariable(name: "_val", scope: !1984, file: !1878, line: 162, type: !563)
!1992 = !DILocation(line: 162, column: 13, scope: !1984)
!1993 = !DILocalVariable(name: "ToInt", scope: !1984, file: !1878, line: 154, type: !77)
!1994 = !DILocation(line: 154, column: 14, scope: !1984)
!1995 = !DILocation(line: 169, column: 9, scope: !1984)
!1996 = !DILocation(line: 171, column: 9, scope: !1984)
!1997 = !DILocation(line: 175, column: 13, scope: !1984)
!1998 = !DILocation(line: 176, column: 15, scope: !1984)
!1999 = !DILocation(line: 177, column: 17, scope: !1984)
!2000 = !DILocation(line: 172, column: 13, scope: !1984)
!2001 = !DILocation(line: 173, column: 13, scope: !1984)
!2002 = distinct !DISubprogram(name: "ToInt", linkageName: "Simatic.Ax.Conversion.Strings.ToInt$I@V@STRING@str?O@V@UInt64@value", scope: !1847, file: !1878, line: 179, type: !1796, scopeLine: 179, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2003 = !DILocalVariable(name: "str", arg: 1, scope: !2002, file: !1878, line: 181, type: !66, flags: DIFlagTypePassByValue)
!2004 = !DILocation(line: 181, column: 13, scope: !2002)
!2005 = !DILocalVariable(name: "value", arg: 2, scope: !2002, file: !1878, line: 184, type: !854, flags: DIFlagTypePassByValue)
!2006 = !DILocation(line: 184, column: 13, scope: !2002)
!2007 = !DILocalVariable(name: "_val", scope: !2002, file: !1878, line: 187, type: !855)
!2008 = !DILocation(line: 187, column: 13, scope: !2002)
!2009 = !DILocalVariable(name: "ToInt", scope: !2002, file: !1878, line: 179, type: !77)
!2010 = !DILocation(line: 179, column: 14, scope: !2002)
!2011 = !DILocation(line: 194, column: 9, scope: !2002)
!2012 = !DILocation(line: 196, column: 9, scope: !2002)
!2013 = !DILocation(line: 200, column: 13, scope: !2002)
!2014 = !DILocation(line: 201, column: 15, scope: !2002)
!2015 = !DILocation(line: 202, column: 17, scope: !2002)
!2016 = !DILocation(line: 197, column: 13, scope: !2002)
!2017 = !DILocation(line: 198, column: 13, scope: !2002)
!2018 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@ARRAY [*] OF BYTE@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 3, type: !2021, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2019 = !DIFile(filename: "ByteArrayConverter.st", directory: "D:\\workspace\\JSONShowcase\\JSONShowcase\\.apax\\packages\\@ax\\axunit-library\\src")
!2020 = !DINamespace(name: "AxUnit", scope: null, exportSymbols: true)
!2021 = !DISubroutineType(types: !2022)
!2022 = !{!756, !756, !2023, !2025}
!2023 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2024, size: 64, align: 64, dwarfAddressSpace: 0)
!2024 = !DIDerivedType(tag: DW_TAG_typedef, name: "BYTE", baseType: !84, align: 8)
!2025 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2023, size: 64, align: 64, dwarfAddressSpace: 0)
!2026 = !DILocalVariable(name: "offset", arg: 1, scope: !2018, file: !2019, line: 5, type: !756, flags: DIFlagTypePassByValue)
!2027 = !DILocation(line: 5, column: 5, scope: !2018)
!2028 = !DILocalVariable(name: "value", arg: 2, scope: !2018, file: !2019, line: 6, type: !2023, flags: DIFlagTypePassByValue)
!2029 = !DILocation(line: 6, column: 5, scope: !2018)
!2030 = !DILocalVariable(name: "buffer", arg: 3, scope: !2018, file: !2019, line: 9, type: !2025, flags: DIFlagTypePassByReference)
!2031 = !DILocation(line: 9, column: 5, scope: !2018)
!2032 = !DILocalVariable(name: "index", scope: !2018, file: !2019, line: 12, type: !74)
!2033 = !DILocation(line: 12, column: 5, scope: !2018)
!2034 = !DILocalVariable(name: "WriteToArray", scope: !2018, file: !2019, line: 3, type: !756)
!2035 = !DILocation(line: 3, column: 10, scope: !2018)
!2036 = !DILocation(line: 15, column: 28, scope: !2018)
!2037 = !DILocation(line: 15, column: 9, scope: !2018)
!2038 = !DILocation(line: 15, column: 5, scope: !2018)
!2039 = !DILocation(line: 19, column: 12, scope: !2018)
!2040 = !DILocation(line: 21, column: 5, scope: !2018)
!2041 = !DILocation(line: 22, column: 13, scope: !2018)
!2042 = !DILocation(line: 16, column: 9, scope: !2018)
!2043 = !DILocation(line: 18, column: 15, scope: !2018)
!2044 = !DILocation(line: 17, column: 12, scope: !2018)
!2045 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int1@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 25, type: !2046, scopeLine: 25, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2046 = !DISubroutineType(types: !2047)
!2047 = !{!756, !756, !77, !2025}
!2048 = !DILocalVariable(name: "offset", arg: 1, scope: !2045, file: !2019, line: 27, type: !756, flags: DIFlagTypePassByValue)
!2049 = !DILocation(line: 27, column: 5, scope: !2045)
!2050 = !DILocalVariable(name: "value", arg: 2, scope: !2045, file: !2019, line: 28, type: !77, flags: DIFlagTypePassByValue)
!2051 = !DILocation(line: 28, column: 5, scope: !2045)
!2052 = !DILocalVariable(name: "buffer", arg: 3, scope: !2045, file: !2019, line: 31, type: !2025, flags: DIFlagTypePassByReference)
!2053 = !DILocation(line: 31, column: 5, scope: !2045)
!2054 = !DILocalVariable(name: "valueArray", scope: !2045, file: !2019, line: 34, type: !2055)
!2055 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..0] OF BYTE", file: !2019, line: 34, baseType: !2056, align: 8)
!2056 = !DICompositeType(tag: DW_TAG_array_type, baseType: !2024, size: 8, align: 8, elements: !474)
!2057 = !DILocation(line: 34, column: 5, scope: !2045)
!2058 = !DILocalVariable(name: "WriteToArray", scope: !2045, file: !2019, line: 25, type: !756)
!2059 = !DILocation(line: 25, column: 10, scope: !2045)
!2060 = !DILocation(line: 37, column: 5, scope: !2045)
!2061 = !DILocation(line: 38, column: 5, scope: !2045)
!2062 = !DILocation(line: 40, column: 13, scope: !2045)
!2063 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte16@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 43, type: !2064, scopeLine: 43, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2064 = !DISubroutineType(types: !2065)
!2065 = !{!756, !756, !2066, !2025}
!2066 = !DIDerivedType(tag: DW_TAG_typedef, name: "WORD", baseType: !2067, align: 16)
!2067 = !DIBasicType(name: "Byte16", size: 16, encoding: DW_ATE_unsigned)
!2068 = !DILocalVariable(name: "offset", arg: 1, scope: !2063, file: !2019, line: 45, type: !756, flags: DIFlagTypePassByValue)
!2069 = !DILocation(line: 45, column: 5, scope: !2063)
!2070 = !DILocalVariable(name: "value", arg: 2, scope: !2063, file: !2019, line: 46, type: !2066, flags: DIFlagTypePassByValue)
!2071 = !DILocation(line: 46, column: 5, scope: !2063)
!2072 = !DILocalVariable(name: "buffer", arg: 3, scope: !2063, file: !2019, line: 49, type: !2025, flags: DIFlagTypePassByReference)
!2073 = !DILocation(line: 49, column: 5, scope: !2063)
!2074 = !DILocalVariable(name: "valueArray", scope: !2063, file: !2019, line: 52, type: !2075)
!2075 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..1] OF BYTE", file: !2019, line: 52, baseType: !2076, align: 8)
!2076 = !DICompositeType(tag: DW_TAG_array_type, baseType: !2024, size: 16, align: 8, elements: !162)
!2077 = !DILocation(line: 52, column: 5, scope: !2063)
!2078 = !DILocalVariable(name: "WriteToArray", scope: !2063, file: !2019, line: 43, type: !756)
!2079 = !DILocation(line: 43, column: 10, scope: !2063)
!2080 = !DILocation(line: 55, column: 5, scope: !2063)
!2081 = !DILocation(line: 56, column: 5, scope: !2063)
!2082 = !DILocation(line: 58, column: 13, scope: !2063)
!2083 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte32@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 62, type: !2084, scopeLine: 62, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2084 = !DISubroutineType(types: !2085)
!2085 = !{!756, !756, !2086, !2025}
!2086 = !DIDerivedType(tag: DW_TAG_typedef, name: "DWORD", baseType: !2087, align: 32)
!2087 = !DIBasicType(name: "Byte32", size: 32, encoding: DW_ATE_unsigned)
!2088 = !DILocalVariable(name: "offset", arg: 1, scope: !2083, file: !2019, line: 64, type: !756, flags: DIFlagTypePassByValue)
!2089 = !DILocation(line: 64, column: 5, scope: !2083)
!2090 = !DILocalVariable(name: "value", arg: 2, scope: !2083, file: !2019, line: 65, type: !2086, flags: DIFlagTypePassByValue)
!2091 = !DILocation(line: 65, column: 5, scope: !2083)
!2092 = !DILocalVariable(name: "buffer", arg: 3, scope: !2083, file: !2019, line: 68, type: !2025, flags: DIFlagTypePassByReference)
!2093 = !DILocation(line: 68, column: 5, scope: !2083)
!2094 = !DILocalVariable(name: "valueArray", scope: !2083, file: !2019, line: 71, type: !2095)
!2095 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..3] OF BYTE", file: !2019, line: 71, baseType: !2096, align: 8)
!2096 = !DICompositeType(tag: DW_TAG_array_type, baseType: !2024, size: 32, align: 8, elements: !2097)
!2097 = !{!2098}
!2098 = !DISubrange(count: 4)
!2099 = !DILocation(line: 71, column: 5, scope: !2083)
!2100 = !DILocalVariable(name: "WriteToArray", scope: !2083, file: !2019, line: 62, type: !756)
!2101 = !DILocation(line: 62, column: 10, scope: !2083)
!2102 = !DILocation(line: 74, column: 5, scope: !2083)
!2103 = !DILocation(line: 75, column: 5, scope: !2083)
!2104 = !DILocation(line: 77, column: 13, scope: !2083)
!2105 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte64@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 79, type: !2106, scopeLine: 79, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2106 = !DISubroutineType(types: !2107)
!2107 = !{!756, !756, !2108, !2025}
!2108 = !DIDerivedType(tag: DW_TAG_typedef, name: "LWORD", baseType: !2109, align: 64)
!2109 = !DIBasicType(name: "Byte64", size: 64, encoding: DW_ATE_unsigned)
!2110 = !DILocalVariable(name: "offset", arg: 1, scope: !2105, file: !2019, line: 81, type: !756, flags: DIFlagTypePassByValue)
!2111 = !DILocation(line: 81, column: 5, scope: !2105)
!2112 = !DILocalVariable(name: "value", arg: 2, scope: !2105, file: !2019, line: 82, type: !2108, flags: DIFlagTypePassByValue)
!2113 = !DILocation(line: 82, column: 5, scope: !2105)
!2114 = !DILocalVariable(name: "buffer", arg: 3, scope: !2105, file: !2019, line: 85, type: !2025, flags: DIFlagTypePassByReference)
!2115 = !DILocation(line: 85, column: 5, scope: !2105)
!2116 = !DILocalVariable(name: "valueArray", scope: !2105, file: !2019, line: 88, type: !2117)
!2117 = !DIDerivedType(tag: DW_TAG_typedef, name: "ARRAY [0..7] OF BYTE", file: !2019, line: 88, baseType: !2118, align: 8)
!2118 = !DICompositeType(tag: DW_TAG_array_type, baseType: !2024, size: 64, align: 8, elements: !2119)
!2119 = !{!2120}
!2120 = !DISubrange(count: 8)
!2121 = !DILocation(line: 88, column: 5, scope: !2105)
!2122 = !DILocalVariable(name: "WriteToArray", scope: !2105, file: !2019, line: 79, type: !756)
!2123 = !DILocation(line: 79, column: 10, scope: !2105)
!2124 = !DILocation(line: 91, column: 5, scope: !2105)
!2125 = !DILocation(line: 92, column: 5, scope: !2105)
!2126 = !DILocation(line: 94, column: 13, scope: !2105)
!2127 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Byte8@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 96, type: !2128, scopeLine: 96, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2128 = !DISubroutineType(types: !2129)
!2129 = !{!756, !756, !2024, !2025}
!2130 = !DILocalVariable(name: "offset", arg: 1, scope: !2127, file: !2019, line: 98, type: !756, flags: DIFlagTypePassByValue)
!2131 = !DILocation(line: 98, column: 5, scope: !2127)
!2132 = !DILocalVariable(name: "value", arg: 2, scope: !2127, file: !2019, line: 99, type: !2024, flags: DIFlagTypePassByValue)
!2133 = !DILocation(line: 99, column: 5, scope: !2127)
!2134 = !DILocalVariable(name: "buffer", arg: 3, scope: !2127, file: !2019, line: 102, type: !2025, flags: DIFlagTypePassByReference)
!2135 = !DILocation(line: 102, column: 5, scope: !2127)
!2136 = !DILocalVariable(name: "valueArray", scope: !2127, file: !2019, line: 105, type: !2055)
!2137 = !DILocation(line: 105, column: 5, scope: !2127)
!2138 = !DILocalVariable(name: "WriteToArray", scope: !2127, file: !2019, line: 96, type: !756)
!2139 = !DILocation(line: 96, column: 10, scope: !2127)
!2140 = !DILocation(line: 108, column: 1, scope: !2127)
!2141 = !DILocation(line: 109, column: 5, scope: !2127)
!2142 = !DILocation(line: 111, column: 13, scope: !2127)
!2143 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int8@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 113, type: !2144, scopeLine: 113, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2144 = !DISubroutineType(types: !2145)
!2145 = !{!756, !756, !513, !2025}
!2146 = !DILocalVariable(name: "offset", arg: 1, scope: !2143, file: !2019, line: 115, type: !756, flags: DIFlagTypePassByValue)
!2147 = !DILocation(line: 115, column: 5, scope: !2143)
!2148 = !DILocalVariable(name: "value", arg: 2, scope: !2143, file: !2019, line: 116, type: !513, flags: DIFlagTypePassByValue)
!2149 = !DILocation(line: 116, column: 5, scope: !2143)
!2150 = !DILocalVariable(name: "buffer", arg: 3, scope: !2143, file: !2019, line: 119, type: !2025, flags: DIFlagTypePassByReference)
!2151 = !DILocation(line: 119, column: 5, scope: !2143)
!2152 = !DILocalVariable(name: "valueArray", scope: !2143, file: !2019, line: 122, type: !2055)
!2153 = !DILocation(line: 122, column: 5, scope: !2143)
!2154 = !DILocalVariable(name: "WriteToArray", scope: !2143, file: !2019, line: 113, type: !756)
!2155 = !DILocation(line: 113, column: 10, scope: !2143)
!2156 = !DILocation(line: 125, column: 5, scope: !2143)
!2157 = !DILocation(line: 126, column: 5, scope: !2143)
!2158 = !DILocation(line: 128, column: 13, scope: !2143)
!2159 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int16@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 130, type: !2160, scopeLine: 130, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2160 = !DISubroutineType(types: !2161)
!2161 = !{!756, !756, !32, !2025}
!2162 = !DILocalVariable(name: "offset", arg: 1, scope: !2159, file: !2019, line: 132, type: !756, flags: DIFlagTypePassByValue)
!2163 = !DILocation(line: 132, column: 5, scope: !2159)
!2164 = !DILocalVariable(name: "value", arg: 2, scope: !2159, file: !2019, line: 133, type: !32, flags: DIFlagTypePassByValue)
!2165 = !DILocation(line: 133, column: 5, scope: !2159)
!2166 = !DILocalVariable(name: "buffer", arg: 3, scope: !2159, file: !2019, line: 136, type: !2025, flags: DIFlagTypePassByReference)
!2167 = !DILocation(line: 136, column: 5, scope: !2159)
!2168 = !DILocalVariable(name: "valueArray", scope: !2159, file: !2019, line: 139, type: !2075)
!2169 = !DILocation(line: 139, column: 5, scope: !2159)
!2170 = !DILocalVariable(name: "WriteToArray", scope: !2159, file: !2019, line: 130, type: !756)
!2171 = !DILocation(line: 130, column: 10, scope: !2159)
!2172 = !DILocation(line: 141, column: 5, scope: !2159)
!2173 = !DILocation(line: 142, column: 5, scope: !2159)
!2174 = !DILocation(line: 144, column: 13, scope: !2159)
!2175 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int32@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 146, type: !2176, scopeLine: 146, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2176 = !DISubroutineType(types: !2177)
!2177 = !{!756, !756, !74, !2025}
!2178 = !DILocalVariable(name: "offset", arg: 1, scope: !2175, file: !2019, line: 148, type: !756, flags: DIFlagTypePassByValue)
!2179 = !DILocation(line: 148, column: 5, scope: !2175)
!2180 = !DILocalVariable(name: "value", arg: 2, scope: !2175, file: !2019, line: 149, type: !74, flags: DIFlagTypePassByValue)
!2181 = !DILocation(line: 149, column: 5, scope: !2175)
!2182 = !DILocalVariable(name: "buffer", arg: 3, scope: !2175, file: !2019, line: 152, type: !2025, flags: DIFlagTypePassByReference)
!2183 = !DILocation(line: 152, column: 5, scope: !2175)
!2184 = !DILocalVariable(name: "valueArray", scope: !2175, file: !2019, line: 155, type: !2095)
!2185 = !DILocation(line: 155, column: 5, scope: !2175)
!2186 = !DILocalVariable(name: "WriteToArray", scope: !2175, file: !2019, line: 146, type: !756)
!2187 = !DILocation(line: 146, column: 10, scope: !2175)
!2188 = !DILocation(line: 158, column: 5, scope: !2175)
!2189 = !DILocation(line: 159, column: 5, scope: !2175)
!2190 = !DILocation(line: 161, column: 13, scope: !2175)
!2191 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Int64@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 164, type: !2192, scopeLine: 164, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2192 = !DISubroutineType(types: !2193)
!2193 = !{!756, !756, !563, !2025}
!2194 = !DILocalVariable(name: "offset", arg: 1, scope: !2191, file: !2019, line: 166, type: !756, flags: DIFlagTypePassByValue)
!2195 = !DILocation(line: 166, column: 5, scope: !2191)
!2196 = !DILocalVariable(name: "value", arg: 2, scope: !2191, file: !2019, line: 167, type: !563, flags: DIFlagTypePassByValue)
!2197 = !DILocation(line: 167, column: 5, scope: !2191)
!2198 = !DILocalVariable(name: "buffer", arg: 3, scope: !2191, file: !2019, line: 170, type: !2025, flags: DIFlagTypePassByReference)
!2199 = !DILocation(line: 170, column: 5, scope: !2191)
!2200 = !DILocalVariable(name: "valueArray", scope: !2191, file: !2019, line: 173, type: !2117)
!2201 = !DILocation(line: 173, column: 5, scope: !2191)
!2202 = !DILocalVariable(name: "WriteToArray", scope: !2191, file: !2019, line: 164, type: !756)
!2203 = !DILocation(line: 164, column: 10, scope: !2191)
!2204 = !DILocation(line: 176, column: 5, scope: !2191)
!2205 = !DILocation(line: 177, column: 5, scope: !2191)
!2206 = !DILocation(line: 179, column: 13, scope: !2191)
!2207 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt8@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 181, type: !2208, scopeLine: 181, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2208 = !DISubroutineType(types: !2209)
!2209 = !{!756, !756, !36, !2025}
!2210 = !DILocalVariable(name: "offset", arg: 1, scope: !2207, file: !2019, line: 183, type: !756, flags: DIFlagTypePassByValue)
!2211 = !DILocation(line: 183, column: 5, scope: !2207)
!2212 = !DILocalVariable(name: "value", arg: 2, scope: !2207, file: !2019, line: 184, type: !36, flags: DIFlagTypePassByValue)
!2213 = !DILocation(line: 184, column: 5, scope: !2207)
!2214 = !DILocalVariable(name: "buffer", arg: 3, scope: !2207, file: !2019, line: 187, type: !2025, flags: DIFlagTypePassByReference)
!2215 = !DILocation(line: 187, column: 5, scope: !2207)
!2216 = !DILocalVariable(name: "valueArray", scope: !2207, file: !2019, line: 190, type: !2055)
!2217 = !DILocation(line: 190, column: 5, scope: !2207)
!2218 = !DILocalVariable(name: "WriteToArray", scope: !2207, file: !2019, line: 181, type: !756)
!2219 = !DILocation(line: 181, column: 10, scope: !2207)
!2220 = !DILocation(line: 193, column: 5, scope: !2207)
!2221 = !DILocation(line: 194, column: 5, scope: !2207)
!2222 = !DILocation(line: 196, column: 13, scope: !2207)
!2223 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt16@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 198, type: !2224, scopeLine: 198, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2224 = !DISubroutineType(types: !2225)
!2225 = !{!756, !756, !756, !2025}
!2226 = !DILocalVariable(name: "offset", arg: 1, scope: !2223, file: !2019, line: 200, type: !756, flags: DIFlagTypePassByValue)
!2227 = !DILocation(line: 200, column: 5, scope: !2223)
!2228 = !DILocalVariable(name: "value", arg: 2, scope: !2223, file: !2019, line: 201, type: !756, flags: DIFlagTypePassByValue)
!2229 = !DILocation(line: 201, column: 5, scope: !2223)
!2230 = !DILocalVariable(name: "buffer", arg: 3, scope: !2223, file: !2019, line: 204, type: !2025, flags: DIFlagTypePassByReference)
!2231 = !DILocation(line: 204, column: 5, scope: !2223)
!2232 = !DILocalVariable(name: "valueArray", scope: !2223, file: !2019, line: 207, type: !2075)
!2233 = !DILocation(line: 207, column: 5, scope: !2223)
!2234 = !DILocalVariable(name: "WriteToArray", scope: !2223, file: !2019, line: 198, type: !756)
!2235 = !DILocation(line: 198, column: 10, scope: !2223)
!2236 = !DILocation(line: 210, column: 5, scope: !2223)
!2237 = !DILocation(line: 211, column: 5, scope: !2223)
!2238 = !DILocation(line: 212, column: 13, scope: !2223)
!2239 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt32@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 214, type: !2240, scopeLine: 214, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2240 = !DISubroutineType(types: !2241)
!2241 = !{!756, !756, !805, !2025}
!2242 = !DILocalVariable(name: "offset", arg: 1, scope: !2239, file: !2019, line: 216, type: !756, flags: DIFlagTypePassByValue)
!2243 = !DILocation(line: 216, column: 5, scope: !2239)
!2244 = !DILocalVariable(name: "value", arg: 2, scope: !2239, file: !2019, line: 217, type: !805, flags: DIFlagTypePassByValue)
!2245 = !DILocation(line: 217, column: 5, scope: !2239)
!2246 = !DILocalVariable(name: "buffer", arg: 3, scope: !2239, file: !2019, line: 220, type: !2025, flags: DIFlagTypePassByReference)
!2247 = !DILocation(line: 220, column: 5, scope: !2239)
!2248 = !DILocalVariable(name: "valueArray", scope: !2239, file: !2019, line: 223, type: !2095)
!2249 = !DILocation(line: 223, column: 5, scope: !2239)
!2250 = !DILocalVariable(name: "WriteToArray", scope: !2239, file: !2019, line: 214, type: !756)
!2251 = !DILocation(line: 214, column: 10, scope: !2239)
!2252 = !DILocation(line: 226, column: 5, scope: !2239)
!2253 = !DILocation(line: 227, column: 5, scope: !2239)
!2254 = !DILocation(line: 229, column: 13, scope: !2239)
!2255 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@UInt64@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 231, type: !2256, scopeLine: 231, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2256 = !DISubroutineType(types: !2257)
!2257 = !{!756, !756, !855, !2025}
!2258 = !DILocalVariable(name: "offset", arg: 1, scope: !2255, file: !2019, line: 233, type: !756, flags: DIFlagTypePassByValue)
!2259 = !DILocation(line: 233, column: 5, scope: !2255)
!2260 = !DILocalVariable(name: "value", arg: 2, scope: !2255, file: !2019, line: 234, type: !855, flags: DIFlagTypePassByValue)
!2261 = !DILocation(line: 234, column: 5, scope: !2255)
!2262 = !DILocalVariable(name: "buffer", arg: 3, scope: !2255, file: !2019, line: 237, type: !2025, flags: DIFlagTypePassByReference)
!2263 = !DILocation(line: 237, column: 5, scope: !2255)
!2264 = !DILocalVariable(name: "valueArray", scope: !2255, file: !2019, line: 240, type: !2117)
!2265 = !DILocation(line: 240, column: 5, scope: !2255)
!2266 = !DILocalVariable(name: "WriteToArray", scope: !2255, file: !2019, line: 231, type: !756)
!2267 = !DILocation(line: 231, column: 10, scope: !2255)
!2268 = !DILocation(line: 243, column: 5, scope: !2255)
!2269 = !DILocation(line: 244, column: 5, scope: !2255)
!2270 = !DILocation(line: 246, column: 13, scope: !2255)
!2271 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Float@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 248, type: !2272, scopeLine: 248, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2272 = !DISubroutineType(types: !2273)
!2273 = !{!756, !756, !2274, !2025}
!2274 = !DIDerivedType(tag: DW_TAG_typedef, name: "REAL", baseType: !2275, align: 32)
!2275 = !DIBasicType(name: "Float", size: 32, encoding: DW_ATE_float)
!2276 = !DILocalVariable(name: "offset", arg: 1, scope: !2271, file: !2019, line: 250, type: !756, flags: DIFlagTypePassByValue)
!2277 = !DILocation(line: 250, column: 5, scope: !2271)
!2278 = !DILocalVariable(name: "value", arg: 2, scope: !2271, file: !2019, line: 251, type: !2274, flags: DIFlagTypePassByValue)
!2279 = !DILocation(line: 251, column: 5, scope: !2271)
!2280 = !DILocalVariable(name: "buffer", arg: 3, scope: !2271, file: !2019, line: 254, type: !2025, flags: DIFlagTypePassByReference)
!2281 = !DILocation(line: 254, column: 5, scope: !2271)
!2282 = !DILocalVariable(name: "valueArray", scope: !2271, file: !2019, line: 257, type: !2095)
!2283 = !DILocation(line: 257, column: 5, scope: !2271)
!2284 = !DILocalVariable(name: "WriteToArray", scope: !2271, file: !2019, line: 248, type: !756)
!2285 = !DILocation(line: 248, column: 10, scope: !2271)
!2286 = !DILocation(line: 260, column: 5, scope: !2271)
!2287 = !DILocation(line: 261, column: 5, scope: !2271)
!2288 = !DILocation(line: 263, column: 13, scope: !2271)
!2289 = distinct !DISubprogram(name: "WriteToArray", linkageName: "AxUnit.WriteToArray$I@V@UInt16@offset?I@V@Double@value?I@R@ARRAY [*] OF BYTE@buffer", scope: !2020, file: !2019, line: 265, type: !2290, scopeLine: 265, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2290 = !DISubroutineType(types: !2291)
!2291 = !{!756, !756, !2292, !2025}
!2292 = !DIDerivedType(tag: DW_TAG_typedef, name: "LREAL", baseType: !2293, align: 64)
!2293 = !DIBasicType(name: "Double", size: 64, encoding: DW_ATE_float)
!2294 = !DILocalVariable(name: "offset", arg: 1, scope: !2289, file: !2019, line: 267, type: !756, flags: DIFlagTypePassByValue)
!2295 = !DILocation(line: 267, column: 5, scope: !2289)
!2296 = !DILocalVariable(name: "value", arg: 2, scope: !2289, file: !2019, line: 268, type: !2292, flags: DIFlagTypePassByValue)
!2297 = !DILocation(line: 268, column: 5, scope: !2289)
!2298 = !DILocalVariable(name: "buffer", arg: 3, scope: !2289, file: !2019, line: 271, type: !2025, flags: DIFlagTypePassByReference)
!2299 = !DILocation(line: 271, column: 5, scope: !2289)
!2300 = !DILocalVariable(name: "valueArray", scope: !2289, file: !2019, line: 274, type: !2117)
!2301 = !DILocation(line: 274, column: 5, scope: !2289)
!2302 = !DILocalVariable(name: "WriteToArray", scope: !2289, file: !2019, line: 265, type: !756)
!2303 = !DILocation(line: 265, column: 10, scope: !2289)
!2304 = !DILocation(line: 276, column: 5, scope: !2289)
!2305 = !DILocation(line: 277, column: 5, scope: !2289)
!2306 = !DILocation(line: 278, column: 13, scope: !2289)
!2307 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Int1@value", scope: !2020, file: !2019, line: 494, type: !2308, scopeLine: 494, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2308 = !DISubroutineType(types: !2309)
!2309 = !{!2055, !77}
!2310 = !DILocalVariable(name: "value", arg: 1, scope: !2307, file: !2019, line: 496, type: !77, flags: DIFlagTypePassByValue)
!2311 = !DILocation(line: 496, column: 9, scope: !2307)
!2312 = !DILocalVariable(name: "ToByteArray", scope: !2307, file: !2019, line: 494, type: !2055)
!2313 = !DILocation(line: 494, column: 10, scope: !2307)
!2314 = !DILocation(line: 498, column: 5, scope: !2307)
!2315 = !DILocation(line: 499, column: 13, scope: !2307)
!2316 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Byte8@value", scope: !2020, file: !2019, line: 510, type: !2317, scopeLine: 510, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2317 = !DISubroutineType(types: !2318)
!2318 = !{!2055, !2024}
!2319 = !DILocalVariable(name: "value", arg: 1, scope: !2316, file: !2019, line: 512, type: !2024, flags: DIFlagTypePassByValue)
!2320 = !DILocation(line: 512, column: 9, scope: !2316)
!2321 = !DILocalVariable(name: "ToByteArray", scope: !2316, file: !2019, line: 510, type: !2055)
!2322 = !DILocation(line: 510, column: 10, scope: !2316)
!2323 = !DILocation(line: 514, column: 5, scope: !2316)
!2324 = !DILocation(line: 515, column: 13, scope: !2316)
!2325 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Int8@value", scope: !2020, file: !2019, line: 517, type: !2326, scopeLine: 517, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2326 = !DISubroutineType(types: !2327)
!2327 = !{!2055, !513}
!2328 = !DILocalVariable(name: "value", arg: 1, scope: !2325, file: !2019, line: 519, type: !513, flags: DIFlagTypePassByValue)
!2329 = !DILocation(line: 519, column: 9, scope: !2325)
!2330 = !DILocalVariable(name: "ToByteArray", scope: !2325, file: !2019, line: 517, type: !2055)
!2331 = !DILocation(line: 517, column: 10, scope: !2325)
!2332 = !DILocation(line: 521, column: 5, scope: !2325)
!2333 = !DILocation(line: 522, column: 13, scope: !2325)
!2334 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@UInt8@value", scope: !2020, file: !2019, line: 524, type: !2335, scopeLine: 524, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2335 = !DISubroutineType(types: !2336)
!2336 = !{!2055, !36}
!2337 = !DILocalVariable(name: "value", arg: 1, scope: !2334, file: !2019, line: 526, type: !36, flags: DIFlagTypePassByValue)
!2338 = !DILocation(line: 526, column: 9, scope: !2334)
!2339 = !DILocalVariable(name: "ToByteArray", scope: !2334, file: !2019, line: 524, type: !2055)
!2340 = !DILocation(line: 524, column: 10, scope: !2334)
!2341 = !DILocation(line: 528, column: 5, scope: !2334)
!2342 = !DILocation(line: 529, column: 13, scope: !2334)
!2343 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Byte16@value", scope: !2020, file: !2019, line: 531, type: !2344, scopeLine: 531, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2344 = !DISubroutineType(types: !2345)
!2345 = !{!2075, !2066}
!2346 = !DILocalVariable(name: "value", arg: 1, scope: !2343, file: !2019, line: 533, type: !2066, flags: DIFlagTypePassByValue)
!2347 = !DILocation(line: 533, column: 9, scope: !2343)
!2348 = !DILocalVariable(name: "ToByteArray", scope: !2343, file: !2019, line: 531, type: !2075)
!2349 = !DILocation(line: 531, column: 10, scope: !2343)
!2350 = !DILocation(line: 535, column: 5, scope: !2343)
!2351 = !DILocation(line: 536, column: 13, scope: !2343)
!2352 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Byte32@value", scope: !2020, file: !2019, line: 538, type: !2353, scopeLine: 538, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2353 = !DISubroutineType(types: !2354)
!2354 = !{!2095, !2086}
!2355 = !DILocalVariable(name: "value", arg: 1, scope: !2352, file: !2019, line: 540, type: !2086, flags: DIFlagTypePassByValue)
!2356 = !DILocation(line: 540, column: 9, scope: !2352)
!2357 = !DILocalVariable(name: "ToByteArray", scope: !2352, file: !2019, line: 538, type: !2095)
!2358 = !DILocation(line: 538, column: 10, scope: !2352)
!2359 = !DILocation(line: 542, column: 5, scope: !2352)
!2360 = !DILocation(line: 543, column: 13, scope: !2352)
!2361 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@UInt32@value", scope: !2020, file: !2019, line: 545, type: !2362, scopeLine: 545, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2362 = !DISubroutineType(types: !2363)
!2363 = !{!2095, !805}
!2364 = !DILocalVariable(name: "value", arg: 1, scope: !2361, file: !2019, line: 547, type: !805, flags: DIFlagTypePassByValue)
!2365 = !DILocation(line: 547, column: 9, scope: !2361)
!2366 = !DILocalVariable(name: "ToByteArray", scope: !2361, file: !2019, line: 545, type: !2095)
!2367 = !DILocation(line: 545, column: 10, scope: !2361)
!2368 = !DILocation(line: 549, column: 5, scope: !2361)
!2369 = !DILocation(line: 550, column: 13, scope: !2361)
!2370 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Int16@value", scope: !2020, file: !2019, line: 552, type: !2371, scopeLine: 552, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2371 = !DISubroutineType(types: !2372)
!2372 = !{!2075, !32}
!2373 = !DILocalVariable(name: "value", arg: 1, scope: !2370, file: !2019, line: 554, type: !32, flags: DIFlagTypePassByValue)
!2374 = !DILocation(line: 554, column: 9, scope: !2370)
!2375 = !DILocalVariable(name: "ToByteArray", scope: !2370, file: !2019, line: 552, type: !2075)
!2376 = !DILocation(line: 552, column: 10, scope: !2370)
!2377 = !DILocation(line: 556, column: 5, scope: !2370)
!2378 = !DILocation(line: 557, column: 13, scope: !2370)
!2379 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@UInt16@value", scope: !2020, file: !2019, line: 559, type: !2380, scopeLine: 559, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2380 = !DISubroutineType(types: !2381)
!2381 = !{!2075, !756}
!2382 = !DILocalVariable(name: "value", arg: 1, scope: !2379, file: !2019, line: 561, type: !756, flags: DIFlagTypePassByValue)
!2383 = !DILocation(line: 561, column: 9, scope: !2379)
!2384 = !DILocalVariable(name: "ToByteArray", scope: !2379, file: !2019, line: 559, type: !2075)
!2385 = !DILocation(line: 559, column: 10, scope: !2379)
!2386 = !DILocation(line: 563, column: 5, scope: !2379)
!2387 = !DILocation(line: 564, column: 13, scope: !2379)
!2388 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Int32@value", scope: !2020, file: !2019, line: 566, type: !2389, scopeLine: 566, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2389 = !DISubroutineType(types: !2390)
!2390 = !{!2095, !74}
!2391 = !DILocalVariable(name: "value", arg: 1, scope: !2388, file: !2019, line: 568, type: !74, flags: DIFlagTypePassByValue)
!2392 = !DILocation(line: 568, column: 9, scope: !2388)
!2393 = !DILocalVariable(name: "ToByteArray", scope: !2388, file: !2019, line: 566, type: !2095)
!2394 = !DILocation(line: 566, column: 10, scope: !2388)
!2395 = !DILocation(line: 570, column: 5, scope: !2388)
!2396 = !DILocation(line: 571, column: 13, scope: !2388)
!2397 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Int64@value", scope: !2020, file: !2019, line: 573, type: !2398, scopeLine: 573, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2398 = !DISubroutineType(types: !2399)
!2399 = !{!2117, !563}
!2400 = !DILocalVariable(name: "value", arg: 1, scope: !2397, file: !2019, line: 575, type: !563, flags: DIFlagTypePassByValue)
!2401 = !DILocation(line: 575, column: 9, scope: !2397)
!2402 = !DILocalVariable(name: "ToByteArray", scope: !2397, file: !2019, line: 573, type: !2117)
!2403 = !DILocation(line: 573, column: 10, scope: !2397)
!2404 = !DILocation(line: 577, column: 5, scope: !2397)
!2405 = !DILocation(line: 578, column: 13, scope: !2397)
!2406 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Float@value", scope: !2020, file: !2019, line: 580, type: !2407, scopeLine: 580, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2407 = !DISubroutineType(types: !2408)
!2408 = !{!2095, !2274}
!2409 = !DILocalVariable(name: "value", arg: 1, scope: !2406, file: !2019, line: 582, type: !2274, flags: DIFlagTypePassByValue)
!2410 = !DILocation(line: 582, column: 9, scope: !2406)
!2411 = !DILocalVariable(name: "ToByteArray", scope: !2406, file: !2019, line: 580, type: !2095)
!2412 = !DILocation(line: 580, column: 10, scope: !2406)
!2413 = !DILocation(line: 584, column: 5, scope: !2406)
!2414 = !DILocation(line: 585, column: 13, scope: !2406)
!2415 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Byte64@value", scope: !2020, file: !2019, line: 587, type: !2416, scopeLine: 587, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2416 = !DISubroutineType(types: !2417)
!2417 = !{!2117, !2108}
!2418 = !DILocalVariable(name: "value", arg: 1, scope: !2415, file: !2019, line: 589, type: !2108, flags: DIFlagTypePassByValue)
!2419 = !DILocation(line: 589, column: 9, scope: !2415)
!2420 = !DILocalVariable(name: "ToByteArray", scope: !2415, file: !2019, line: 587, type: !2117)
!2421 = !DILocation(line: 587, column: 10, scope: !2415)
!2422 = !DILocation(line: 591, column: 5, scope: !2415)
!2423 = !DILocation(line: 592, column: 13, scope: !2415)
!2424 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@UInt64@value", scope: !2020, file: !2019, line: 594, type: !2425, scopeLine: 594, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2425 = !DISubroutineType(types: !2426)
!2426 = !{!2117, !855}
!2427 = !DILocalVariable(name: "value", arg: 1, scope: !2424, file: !2019, line: 596, type: !855, flags: DIFlagTypePassByValue)
!2428 = !DILocation(line: 596, column: 9, scope: !2424)
!2429 = !DILocalVariable(name: "ToByteArray", scope: !2424, file: !2019, line: 594, type: !2117)
!2430 = !DILocation(line: 594, column: 10, scope: !2424)
!2431 = !DILocation(line: 598, column: 5, scope: !2424)
!2432 = !DILocation(line: 599, column: 13, scope: !2424)
!2433 = distinct !DISubprogram(name: "ToByteArray", linkageName: "AxUnit.ToByteArray$I@V@Double@value", scope: !2020, file: !2019, line: 601, type: !2434, scopeLine: 601, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2434 = !DISubroutineType(types: !2435)
!2435 = !{!2117, !2292}
!2436 = !DILocalVariable(name: "value", arg: 1, scope: !2433, file: !2019, line: 603, type: !2292, flags: DIFlagTypePassByValue)
!2437 = !DILocation(line: 603, column: 9, scope: !2433)
!2438 = !DILocalVariable(name: "ToByteArray", scope: !2433, file: !2019, line: 601, type: !2117)
!2439 = !DILocation(line: 601, column: 10, scope: !2433)
!2440 = !DILocation(line: 605, column: 5, scope: !2433)
!2441 = !DILocation(line: 606, column: 13, scope: !2433)
!2442 = distinct !DISubprogram(name: "ToByteArray64", linkageName: "AxUnit.ToByteArray64$I@V@Byte64@value?I@R@ARRAY [0..7] OF BYTE@arr", scope: !2020, file: !2019, line: 619, type: !2443, scopeLine: 619, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2443 = !DISubroutineType(types: !2444)
!2444 = !{null, !2108, !2445}
!2445 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2117, size: 64, align: 64, dwarfAddressSpace: 0)
!2446 = !DILocalVariable(name: "value", arg: 1, scope: !2442, file: !2019, line: 621, type: !2108, flags: DIFlagTypePassByValue)
!2447 = !DILocation(line: 621, column: 9, scope: !2442)
!2448 = !DILocalVariable(name: "arr", arg: 2, scope: !2442, file: !2019, line: 624, type: !2445, flags: DIFlagTypePassByReference)
!2449 = !DILocation(line: 624, column: 9, scope: !2442)
!2450 = !DILocation(line: 627, column: 5, scope: !2442)
!2451 = !DILocation(line: 628, column: 5, scope: !2442)
!2452 = !DILocation(line: 629, column: 5, scope: !2442)
!2453 = !DILocation(line: 630, column: 5, scope: !2442)
!2454 = !DILocation(line: 632, column: 5, scope: !2442)
!2455 = !DILocation(line: 633, column: 5, scope: !2442)
!2456 = !DILocation(line: 634, column: 5, scope: !2442)
!2457 = !DILocation(line: 635, column: 5, scope: !2442)
!2458 = !DILocation(line: 636, column: 13, scope: !2442)
!2459 = distinct !DISubprogram(name: "ToByteArray32", linkageName: "AxUnit.ToByteArray32$I@V@Byte32@value?I@R@ARRAY [0..3] OF BYTE@arr", scope: !2020, file: !2019, line: 639, type: !2460, scopeLine: 639, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2460 = !DISubroutineType(types: !2461)
!2461 = !{null, !2086, !2462}
!2462 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2095, size: 64, align: 64, dwarfAddressSpace: 0)
!2463 = !DILocalVariable(name: "value", arg: 1, scope: !2459, file: !2019, line: 641, type: !2086, flags: DIFlagTypePassByValue)
!2464 = !DILocation(line: 641, column: 9, scope: !2459)
!2465 = !DILocalVariable(name: "arr", arg: 2, scope: !2459, file: !2019, line: 644, type: !2462, flags: DIFlagTypePassByReference)
!2466 = !DILocation(line: 644, column: 9, scope: !2459)
!2467 = !DILocation(line: 647, column: 5, scope: !2459)
!2468 = !DILocation(line: 648, column: 5, scope: !2459)
!2469 = !DILocation(line: 649, column: 5, scope: !2459)
!2470 = !DILocation(line: 650, column: 5, scope: !2459)
!2471 = !DILocation(line: 651, column: 13, scope: !2459)
!2472 = distinct !DISubprogram(name: "ToByteArray16", linkageName: "AxUnit.ToByteArray16$I@V@Byte16@value?I@R@ARRAY [0..1] OF BYTE@arr", scope: !2020, file: !2019, line: 654, type: !2473, scopeLine: 654, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2473 = !DISubroutineType(types: !2474)
!2474 = !{null, !2066, !2475}
!2475 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2075, size: 64, align: 64, dwarfAddressSpace: 0)
!2476 = !DILocalVariable(name: "value", arg: 1, scope: !2472, file: !2019, line: 656, type: !2066, flags: DIFlagTypePassByValue)
!2477 = !DILocation(line: 656, column: 9, scope: !2472)
!2478 = !DILocalVariable(name: "arr", arg: 2, scope: !2472, file: !2019, line: 659, type: !2475, flags: DIFlagTypePassByReference)
!2479 = !DILocation(line: 659, column: 9, scope: !2472)
!2480 = !DILocation(line: 662, column: 5, scope: !2472)
!2481 = !DILocation(line: 663, column: 5, scope: !2472)
!2482 = !DILocation(line: 664, column: 13, scope: !2472)
!2483 = distinct !DISubprogram(name: "ToByteArray8", linkageName: "AxUnit.ToByteArray8$I@V@Byte8@value?I@R@ARRAY [0..0] OF BYTE@arr", scope: !2020, file: !2019, line: 667, type: !2484, scopeLine: 667, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2484 = !DISubroutineType(types: !2485)
!2485 = !{null, !2024, !2486}
!2486 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2055, size: 64, align: 64, dwarfAddressSpace: 0)
!2487 = !DILocalVariable(name: "value", arg: 1, scope: !2483, file: !2019, line: 669, type: !2024, flags: DIFlagTypePassByValue)
!2488 = !DILocation(line: 669, column: 9, scope: !2483)
!2489 = !DILocalVariable(name: "arr", arg: 2, scope: !2483, file: !2019, line: 672, type: !2486, flags: DIFlagTypePassByReference)
!2490 = !DILocation(line: 672, column: 9, scope: !2483)
!2491 = !DILocation(line: 675, column: 5, scope: !2483)
!2492 = !DILocation(line: 676, column: 13, scope: !2483)
!2493 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.AbstractJsonElement", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2494 = !DILocation(line: 56, column: 23, scope: !2493)
!2495 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.AbstractJsonElement", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2496 = !DISubroutineType(types: !2497)
!2497 = !{!908}
!2498 = !DILocation(line: 52, column: 23, scope: !2495)
!2499 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.AbstractJsonElement", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2500 = !DISubroutineType(types: !2501)
!2501 = !{!77}
!2502 = !DILocation(line: 48, column: 23, scope: !2499)
!2503 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.AbstractJsonElement", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2504 = !DILocation(line: 17, column: 32, scope: !2503)
!2505 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.AbstractJsonElement", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.AbstractJsonElement$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2506 = !DISubroutineType(types: !2507)
!2507 = !{!66}
!2508 = !DILocation(line: 14, column: 32, scope: !2505)
!2509 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.BaseJsonNumber", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2510 = !DILocation(line: 56, column: 23, scope: !2509)
!2511 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.BaseJsonNumber", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2512 = !DILocation(line: 52, column: 23, scope: !2511)
!2513 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.BaseJsonNumber", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2514 = !DILocation(line: 48, column: 23, scope: !2513)
!2515 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.BaseJsonNumber", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2516 = !DILocation(line: 21, column: 32, scope: !2515)
!2517 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.BaseJsonNumber", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.BaseJsonNumber$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2518 = !DILocation(line: 17, column: 32, scope: !2517)
!2519 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonBoolean", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2520 = !DILocation(line: 56, column: 23, scope: !2519)
!2521 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonBoolean", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2522 = !DILocation(line: 52, column: 23, scope: !2521)
!2523 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonBoolean", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2524 = !DILocation(line: 48, column: 23, scope: !2523)
!2525 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonBoolean", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2526 = !DILocation(line: 18, column: 32, scope: !2525)
!2527 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonBoolean", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonBoolean$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2528 = !DILocation(line: 10, column: 32, scope: !2527)
!2529 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonString", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2530 = !DILocation(line: 56, column: 23, scope: !2529)
!2531 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonString", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2532 = !DILocation(line: 52, column: 23, scope: !2531)
!2533 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonString", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2534 = !DILocation(line: 48, column: 23, scope: !2533)
!2535 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonString", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2536 = !DILocation(line: 20, column: 32, scope: !2535)
!2537 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonString", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonString$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2538 = !DILocation(line: 12, column: 32, scope: !2537)
!2539 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonDInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2540 = !DILocation(line: 56, column: 23, scope: !2539)
!2541 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonDInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2542 = !DILocation(line: 52, column: 23, scope: !2541)
!2543 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonDInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2544 = !DILocation(line: 48, column: 23, scope: !2543)
!2545 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonDInt", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2546 = !DILocation(line: 21, column: 32, scope: !2545)
!2547 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonDInt", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonDInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2548 = !DILocation(line: 9, column: 32, scope: !2547)
!2549 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2550 = !DILocation(line: 56, column: 23, scope: !2549)
!2551 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2552 = !DILocation(line: 52, column: 23, scope: !2551)
!2553 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2554 = !DILocation(line: 48, column: 23, scope: !2553)
!2555 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonInt", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2556 = !DILocation(line: 21, column: 32, scope: !2555)
!2557 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonInt", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2558 = !DILocation(line: 10, column: 32, scope: !2557)
!2559 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonLInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2560 = !DILocation(line: 56, column: 23, scope: !2559)
!2561 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonLInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2562 = !DILocation(line: 52, column: 23, scope: !2561)
!2563 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonLInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2564 = !DILocation(line: 48, column: 23, scope: !2563)
!2565 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonLInt", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2566 = !DILocation(line: 21, column: 32, scope: !2565)
!2567 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonLInt", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonLInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2568 = !DILocation(line: 9, column: 32, scope: !2567)
!2569 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonUSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2570 = !DILocation(line: 56, column: 23, scope: !2569)
!2571 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonUSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2572 = !DILocation(line: 52, column: 23, scope: !2571)
!2573 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonUSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2574 = !DILocation(line: 48, column: 23, scope: !2573)
!2575 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonUSInt", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2576 = !DILocation(line: 21, column: 32, scope: !2575)
!2577 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonUSInt", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonUSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2578 = !DILocation(line: 9, column: 32, scope: !2577)
!2579 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2580 = !DILocation(line: 56, column: 23, scope: !2579)
!2581 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2582 = !DILocation(line: 52, column: 23, scope: !2581)
!2583 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonSInt", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2584 = !DILocation(line: 48, column: 23, scope: !2583)
!2585 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonSInt", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2586 = !DILocation(line: 21, column: 32, scope: !2585)
!2587 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonSInt", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonSInt$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2588 = !DILocation(line: 9, column: 32, scope: !2587)
!2589 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonObject", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.AddElement_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this?I@V@REF_TO Simatic.Ax.Json.IJsonElement@elem", scope: null, file: !3, type: !1375, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2590 = !DILocation(line: 74, column: 32, scope: !2589)
!2591 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonObject", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.GetNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2496, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2592 = !DILocation(line: 52, column: 23, scope: !2591)
!2593 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonObject", linkageName: "$Simatic.Ax.Json.IJsonElementMuteable.HasNext_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElementMuteable@this", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2594 = !DILocation(line: 48, column: 23, scope: !2593)
!2595 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonObject", linkageName: "$Simatic.Ax.Json.IJsonElement.Serialize_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this?I@V@REF_TO Simatic.Ax.Json.JsonDocument@doc", scope: null, file: !3, type: !2500, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2596 = !DILocation(line: 39, column: 32, scope: !2595)
!2597 = distinct !DISubprogram(name: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonObject", linkageName: "$Simatic.Ax.Json.IJsonElement.ToString_Simatic.Ax.Json.JsonObject$I@V@REF_TO Simatic.Ax.Json.IJsonElement@this", scope: null, file: !3, type: !2506, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !2, retainedNodes: !10)
!2598 = !DILocation(line: 11, column: 32, scope: !2597)
!2599 = !{!2600, !2600, i64 0}
!2600 = !{!"any pointer", !2601, i64 0}
!2601 = !{!"omnipotent char", !2602, i64 0}
!2602 = !{!"Simple C++ TBAA"}
!2603 = !{!2604, !2604, i64 0}
!2604 = !{!"long long", !2601, i64 0}
!2605 = !{!2606, !2607, i64 8}
!2606 = !{!"?AU_$ax.ArrayWithBounds@@", !2600, i64 0, !2607, i64 8, !2600, i64 16}
!2607 = !{!"int", !2601, i64 0}
!2608 = !{!2606, !2600, i64 16}
!2609 = !{!2610, !2607, i64 0}
!2610 = !{!"?AU_$ax.Bounds@@", !2607, i64 0, !2607, i64 4, !2607, i64 8}
!2611 = !{!2610, !2607, i64 4}
!2612 = !{!2613, !2614, i64 16}
!2613 = !{!"?AU_ClassDescriptorStub@@", !2600, i64 0, !2604, i64 8, !2614, i64 16, !2600, i64 24}
!2614 = !{!"short", !2601, i64 0}
!2615 = !{!2613, !2600, i64 24}
!2616 = !{!2617, !2604, i64 8}
!2617 = !{!"?AU_InterfaceTableEntry@@", !2604, i64 0, !2604, i64 8, !2600, i64 16}
!2618 = !{!2617, !2604, i64 0}
!2619 = !{!2620, !2600, i64 0}
!2620 = !{!"?AU_InterfaceDescriptorStub@@", !2600, i64 0}
!2621 = !{!2613, !2600, i64 0}
!2622 = !{!2617, !2600, i64 16}
!2623 = !{!2624, !2601, i64 1}
!2624 = !{!"?AU$ax.ST_STRING@@", !2601, i64 0, !2601, i64 1, !2601, i64 2}
!2625 = !{!2601, !2601, i64 0}
!2626 = !{!2627, !2614, i64 2}
!2627 = !{!"?AU$ax.ST_WSTRING@@", !2614, i64 0, !2614, i64 2, !2601, i64 4}
!2628 = !{!2614, !2614, i64 0}
!2629 = !{!2624, !2601, i64 0}
!2630 = !{!2631}
!2631 = distinct !{!2631, !2632}
!2632 = distinct !{!2632, !"LVerDomain"}
!2633 = !{!2634}
!2634 = distinct !{!2634, !2632}
!2635 = distinct !{!2635, !2636}
!2636 = !{!"llvm.loop.isvectorized", i32 1}
!2637 = distinct !{!2637, !2638}
!2638 = !{!"llvm.loop.unroll.disable"}
!2639 = distinct !{!2639, !2636}
!2640 = !{!2627, !2614, i64 0}
!2641 = !{!2642}
!2642 = distinct !{!2642, !2643}
!2643 = distinct !{!2643, !"LVerDomain"}
!2644 = !{!2645}
!2645 = distinct !{!2645, !2643}
!2646 = distinct !{!2646, !2636}
!2647 = distinct !{!2647, !2638}
!2648 = distinct !{!2648, !2636}
